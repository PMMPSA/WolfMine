<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools;

use czechpmdevs\buildertools\commands\BlockInfoCommand;
use czechpmdevs\buildertools\commands\ClearInventoryCommand;
use czechpmdevs\buildertools\commands\CopyCommand;
use czechpmdevs\buildertools\commands\CubeCommand;
use czechpmdevs\buildertools\commands\CylinderCommand;
use czechpmdevs\buildertools\commands\DrawCommand;
use czechpmdevs\buildertools\commands\FillCommand;
use czechpmdevs\buildertools\commands\FirstPositionCommand;
use czechpmdevs\buildertools\commands\FixCommand;
use czechpmdevs\buildertools\commands\FlipCommand;
use czechpmdevs\buildertools\commands\HelpCommand;
use czechpmdevs\buildertools\commands\HollowCubeCommand;
use czechpmdevs\buildertools\commands\HollowCylinderCommand;
use czechpmdevs\buildertools\commands\HollowPyramidCommand;
use czechpmdevs\buildertools\commands\HollowSphereCommand;
use czechpmdevs\buildertools\commands\IdCommand;
use czechpmdevs\buildertools\commands\MergeCommand;
use czechpmdevs\buildertools\commands\MoveCommand;
use czechpmdevs\buildertools\commands\NaturalizeCommand;
use czechpmdevs\buildertools\commands\OutlineCommand;
use czechpmdevs\buildertools\commands\PasteCommand;
use czechpmdevs\buildertools\commands\PyramidCommand;
use czechpmdevs\buildertools\commands\RedoCommand;
use czechpmdevs\buildertools\commands\ReplaceCommand;
use czechpmdevs\buildertools\commands\RotateCommand;
use czechpmdevs\buildertools\commands\SchematicCommand;
use czechpmdevs\buildertools\commands\SecondPositionCommand;
use czechpmdevs\buildertools\commands\SphereCommand;
use czechpmdevs\buildertools\commands\StackCommand;
use czechpmdevs\buildertools\commands\TreeCommand;
use czechpmdevs\buildertools\commands\UndoCommand;
use czechpmdevs\buildertools\commands\WandCommand;
use czechpmdevs\buildertools\editors\Canceller;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Decorator;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Filler;
use czechpmdevs\buildertools\editors\Fixer;
use czechpmdevs\buildertools\editors\Naturalizer;
use czechpmdevs\buildertools\editors\Printer;
use czechpmdevs\buildertools\editors\Replacement;
use czechpmdevs\buildertools\event\listener\EventListener;
use czechpmdevs\buildertools\schematics\SchematicsManager;
use pocketmine\command\Command;
use pocketmine\item\enchantment\Enchantment;
use pocketmine\plugin\PluginBase;

/**
 * Class BuilderTools
 * @package buildertools
 */
class BuilderTools extends PluginBase {

    /** @var  BuilderTools $instance */
    private static $instance;

    /** @var  string $prefix */
    private static $prefix;

    /** @var  Editor[] $editors */
    private static $editors = [];

    /** @var EventListener $listener */
    private static $listener;

    /** @var SchematicsManager $schematicManager */
    private static $schematicsManager;

    /** @var Command[] $commands */
    private static $commands = [];

    /** @var array $config */
    private static $configuration = [];

    public function onEnable() {
        self::$instance = $this;
        self::$prefix = "§7[BuilderTools] §a";
        $this->initConfig();
        $this->registerCommands();
        $this->initListner();
        $this->registerEditors();
        $this->registerEnchantment();
        self::$schematicsManager = new SchematicsManager($this);
    }

    private function initConfig() {
        if(!is_dir($this->getDataFolder())) {
            @mkdir($this->getDataFolder());
        }
        self::$configuration = $this->getConfig()->getAll();
    }

    private function registerEditors() {
        self::$editors["Filler"] = new Filler;
        self::$editors["Printer"] = new Printer;
        self::$editors["Replacement"] = new Replacement;
        self::$editors["Naturalizer"] = new Naturalizer;
        self::$editors["Copier"] = new Copier;
        self::$editors["Canceller"] = new Canceller;
        self::$editors["Decorator"] = new Decorator;
        self::$editors["Fixer"] = new Fixer;
    }

    private function initListner() {
        $this->getServer()->getPluginManager()->registerEvents(self::$listener = new EventListener, $this);
    }

    private function registerEnchantment() {
        Enchantment::registerEnchantment(new Enchantment(50, "BuilderTools", Enchantment::RARITY_COMMON, 0, 0, 1));
    }

    private function registerCommands() {
        $map = $this->getServer()->getCommandMap();
        self::$commands = [
            new FirstPositionCommand,
            new SecondPositionCommand,
            new WandCommand,
            new FillCommand,
            new HelpCommand,
            new DrawCommand,
            new SphereCommand,
            new HollowSphereCommand,
            new ReplaceCommand,
            new IdCommand,
            new CubeCommand,
            new HollowCubeCommand,
            new CopyCommand,
            new PasteCommand,
            new MergeCommand,
            new RotateCommand,
            new FlipCommand,
            new UndoCommand,
            new RedoCommand,
            new TreeCommand,
            new FixCommand,
            new BlockInfoCommand,
            new ClearInventoryCommand,
            new NaturalizeCommand,
            new SchematicCommand,
            new PyramidCommand,
            new HollowPyramidCommand,
            new CylinderCommand,
            new HollowCylinderCommand,
            new StackCommand,
            new OutlineCommand,
            new MoveCommand
        ];
        foreach (self::$commands as $command) {
            $map->register("BuilderTools", $command);
        }
        HelpCommand::buildPages();
    }

    /**
     * @param string $name
     * @return Editor $editor
     */
    public static function getEditor(string $name): Editor {
        return self::$editors[$name];
    }

    /**
     * @return Command[] $commands
     */
    public static function getAllCommands(): array {
        return self::$commands;
    }

    /**
     * @return string $prefix
     */
    public static function getPrefix(): string {
        return self::$prefix;
    }

    /**
     * @return array
     */
    public static function getConfiguration(): array {
        return self::$configuration;
    }

    /**
     * @return EventListener $listener
     */
    public static function getListener(): EventListener {
        return self::$listener;
    }

    /**
     * @return SchematicsManager $schematicsManager
     */
    public static function getSchematicsManager(): SchematicsManager {
        return self::$schematicsManager;
    }

    /**
     * @return BuilderTools $instance
     */
    public static function getInstance(): BuilderTools {
        return self::$instance;
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\level\Position;
use pocketmine\Player;

/**
 * Class FirstPositionCommand
 * @package buildertools\commands
 */
class FirstPositionCommand extends BuilderToolsCommand {

    /**
     * FirstPositionCommand constructor.
     */
    public function __construct() {
        parent::__construct("/pos1", "Select first position", null, ["/1"]);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        Selectors::addSelector($sender, 1, $position = new Position((int)round($sender->getX()), (int)round($sender->getY()), (int)round($sender->getZ()), $sender->getLevel()));
        $sender->sendMessage(BuilderTools::getPrefix()."§aSelected first position at {$position->getX()}, {$position->getY()}, {$position->getZ()}");
    }
}<?php

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\plugin\Plugin;

/**
 * Class BuilderToolsCommand
 * @package czechpmdevs\buildertools\commands
 */
abstract class BuilderToolsCommand extends Command implements PluginIdentifiableCommand {

    /**
     * BuilderToolsCommand constructor.
     * @param string $name
     * @param string $description
     * @param string|null $usageMessage
     * @param array $aliases
     */
    public function __construct(string $name, string $description = "", string $usageMessage = null, $aliases = []) {
        $this->setPermission($this->getPerms($name));
        parent::__construct($name, $description, $usageMessage, $aliases);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$sender->hasPermission($this->getPermission())) {
            $sender->sendMessage((string)$this->getPermissionMessage());
            return;
        }
    }

    /**
     * @param string $name
     * @return string
     */
    private function getPerms(string $name) {
        return "bt.cmd." . str_replace("/", "", strtolower($name));
    }

    /**
     * @return Plugin|BuilderTools
     */
    public function getPlugin(): Plugin {
        return BuilderTools::getInstance();
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\level\Position;
use pocketmine\Player;


/**
 * Class SecondPositionCommand
 * @package buildertools\commands
 */
class SecondPositionCommand extends BuilderToolsCommand {

    /**
     * SecondPositionCommand constructor.
     */
    public function __construct() {
        parent::__construct("/pos2", "Select second position", null, ["/2"]);
    }

    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;

        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        Selectors::addSelector($sender, 2, $position = new Position((int)round($sender->getX()), (int)round($sender->getY()), (int)round($sender->getZ()), $sender->getLevel()));
        $sender->sendMessage(BuilderTools::getPrefix()."§aSelected second position at {$position->getX()}, {$position->getY()}, {$position->getZ()}");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\item\enchantment\Enchantment;
use pocketmine\item\enchantment\EnchantmentInstance;
use pocketmine\item\Item;
use pocketmine\Player;

/**
 * Class WandCommand
 * @package buildertools\commands
 */
class WandCommand extends BuilderToolsCommand {

    /**
     * WandCommand constructor.
     */
    public function __construct() {
        parent::__construct("/wand", "Switch wand tool", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(BuilderTools::getConfiguration()["items"]["wand-axe"]["enabled"]) {
            $item = Item::get(Item::WOODEN_AXE);
            $item->setCustomName(BuilderTools::getConfiguration()["items"]["wand-axe"]["name"]);
            $item->addEnchantment(new EnchantmentInstance(Enchantment::getEnchantment(50), 1));
            $sender->getInventory()->addItem($item);
            $sender->sendMessage(BuilderTools::getPrefix() . "§aWand axe added to your inventory!");
            return;
        }
        Selectors::switchWandSelector($sender);
        $switch = Selectors::isWandSelector($sender) ? "ON" : "OFF";
        $sender->sendMessage(BuilderTools::getPrefix()."§aWand tool turned {$switch}!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Filler;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class FillCommand
 * @package buildertools\commands
 */
class FillCommand extends BuilderToolsCommand {

    /**
     * FillCommand constructor.
     */
    public function __construct() {
        parent::__construct("/fill", "Fill selected positions.", null, ["/set", "/change"]);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cUsage: §7//fill <id1:meta1,id2:meta2,...>");
            return;
        }

        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }

        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }

        $firstPos = Selectors::getPosition($sender, 1);
        $secondPos = Selectors::getPosition($sender, 2);

        if($firstPos->getLevel()->getName() != $secondPos->getLevel()->getName()) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cPositions must be in same level");
            return;
        }

        $startTime = microtime(true);

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);

        $blocks = $filler->prepareFill($firstPos->asVector3(), $secondPos->asVector3(), $firstPos->getLevel(), $args[0]);
        $result = $filler->fill($sender, $blocks);

        $sender->sendMessage(BuilderTools::getPrefix()."§aSelected area filled in " . (string)round(microtime(true)-$startTime, 2) . " (" . (string)$result->countBlocks . " block changed)");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class HelpCommand
 * @package buildertools\commands
 */
class HelpCommand extends BuilderToolsCommand {

    public const COMMANDS_PER_PAGE = 5;

    /** @var string[] $pages */
    public static $pages = [];

    /**
     * HelpCommand constructor.
     */
    public function __construct() {
        parent::__construct("/commands", "Displays BuilderTools commands", null, ["/?", "buildertools", "/help"]);
    }

    public static function buildPages() {
        $commandsPerList = self::COMMANDS_PER_PAGE;

        $count = (int)(count(BuilderTools::getAllCommands())/$commandsPerList);
        $list = 1;
        $command = 1;
        $text = "";
        $all = 0;

        //sort
        $commands = [];

        /**
         * @var Command $cmd
         */
        foreach (BuilderTools::getAllCommands() as $i => $cmd) {
            $commands[$i] = $cmd->getName();
        }

        asort($commands);

        foreach ($commands as $index => $name) {
            $all++;
            if($command == 1) {
                $text = "§2--- Showing help page {$list} of {$count} ---";
            }
            $text .= "\n§2/{$name}: §f" . BuilderTools::getAllCommands()[$index]->getDescription();
            if($command == self::COMMANDS_PER_PAGE || (count(BuilderTools::getAllCommands()) == $all)) {
                $command = 1;
                self::$pages[$list] = $text;
                $list++;
            }
            else {
                $command++;
            }
        }
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        $page = 1;
        if(isset($args[0]) && is_numeric($args[0]) && (int)$args[0] <= ((int)(count(BuilderTools::getAllCommands())/self::COMMANDS_PER_PAGE))) {
            $page = (int)$args[0];
        }

        $sender->sendMessage(self::$pages[$page]);
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Printer;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class DrawCommand
 * @package buildertools\commands
 */
class DrawCommand extends BuilderToolsCommand {

    /** @var int $minBrush */
    private $minBrush = 1;

    /** @var int $maxBrush */
    private $maxBrush = 6;

    /**
     * DrawCommand constructor.
     */
    public function __construct() {
        parent::__construct("/draw", "Draw witch blocks", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//draw <cube|sphere|off> [brush: {$this->minBrush}-{$this->maxBrush} | on | off]  [fall = false]");
            return;
        }
        if(!in_array(strval($args[0]), ["on", "off", "cube", "sphere", "custom"])) {
            $sender->sendMessage("§cUsage: §7//draw <cube|sphere|off> [brush: {$this->minBrush}-{$this->maxBrush}]  [fall = false]");
            return;
        }
        if(isset($args[1]) && is_numeric($args[1]) && intval($args[1]) >= $this->maxBrush && intval($args[1]) <= $this->minBrush) {
            $sender->sendMessage("§cBrush #{$args[1]} does not exists!");
            return;
        }
        if($args[0] == "off") {
            Selectors::removeDrawnigPlayer($sender);
            $sender->sendMessage(BuilderTools::getPrefix()."§aBrush removed!");
            return;
        }

        $mode = 0;

        if($args[0] == "cube") $mode = Printer::CUBE;
        if($args[0] == "sphere") $mode = Printer::SPHERE;

        $brush = 1;

        if(isset($args[1]) && is_numeric($args[1])) {
            $brush = intval($args[1]);
        }

        $fall = false;

        if(isset($args[2]) && $args[2] == "true") {
            $fall = true;
        }

        Selectors::addDrawingPlayer($sender, $brush, $mode, $fall);

        $fall = $fall ? "§2true§a" : "§cfalse§a";

        $sender->sendMessage(BuilderTools::getPrefix()."§aSelected brush §7#{$brush} §a(§7shape: §a{$args[0]} §7Fall:$fall)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\level\Position;
use pocketmine\Player;

/**
 * Class SphereCommand
 * @package buildertools\commands
 */
class SphereCommand extends BuilderToolsCommand {

    /**
     * SphereCommand constructor.
     */
    public function __construct() {
        parent::__construct("/sphere", "Create sphere", null, []);
    }

    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//sphere <id1:dmg1,id2:dmg2:,...> <radius>");
            return;
        }
        $radius = isset($args[1]) ? (int)($args[1]) : 5;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);
        /** @var EditorResult $result */
        $result = $printer->makeSphere($sender, $sender, $radius, $args[0]);
        $sender->sendMessage(BuilderTools::getPrefix()."§aSphere created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\level\Position;
use pocketmine\Player;

/**
 * Class HollowSphereCommand
 * @package czechpmdevs\buildertools\commands
 */
class HollowSphereCommand extends BuilderToolsCommand {

    /**
     * SphereCommand constructor.
     */
    public function __construct() {
        parent::__construct("/hsphere", "Create hollow sphere", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//hsphere <id1:dmg1,id2:dmg2:,...> [radius]");
            return;
        }

        $radius = isset($args[1]) ? (int)($args[1]) : 5;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);
        /** @var EditorResult $result */
        $result = $printer->makeHollowSphere($sender, $sender, $radius, $args[0]);
        $sender->sendMessage(BuilderTools::getPrefix() . "§aHollow sphere created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Filler;
use czechpmdevs\buildertools\editors\Replacement;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class ReplaceCommand
 * @package buildertools\commands
 */
class ReplaceCommand extends BuilderToolsCommand {

    /**
     * ReplaceCommand constructor.
     */
    public function __construct() {
        parent::__construct("/replace", "Replace selected blocks", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0]) || !isset($args[1])) {
            $sender->sendMessage("§cUsage: §7//replace <BlocksToReplace - id1:meta1,id2:meta2,...> <Blocks - id1:meta1,id2:meta2,...>");
            return;
        }
        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }
        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }
        $firstPos = Selectors::getPosition($sender, 1);
        $secondPos = Selectors::getPosition($sender, 2);
        if($firstPos->getLevel()->getName() != $secondPos->getLevel()->getName()) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cPositions must be in same level");
            return;
        }

        $startTime = microtime(true);

        /** @var Replacement $replacement */
        $replacement = BuilderTools::getEditor(Editor::REPLACEMENT);
        $list = $replacement->prepareReplace($firstPos, $secondPos, $firstPos->getLevel(), $args[0], $args[1]);

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        $result = $filler->fill($sender, $list);

        $count = $result->countBlocks;
        $sender->sendMessage(BuilderTools::getPrefix()."§aSelected area filled in ".round(microtime(true)-$startTime, 2)." ({$count} blocks changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class IdCommand
 * @package buildertools\commands
 */
class IdCommand extends BuilderToolsCommand {

    /**
     * IdCommand constructor.
     */
    public function __construct() {
        parent::__construct("/id", "Send id of item in your hands", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        $sender->sendMessage(BuilderTools::getPrefix()."§aID: §9{$sender->getInventory()->getItemInHand()->getId()}:{$sender->getInventory()->getItemInHand()->getDamage()}");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\Player;

/**
 * Class CubeCommand
 * @package buildertools\commands
 */
class CubeCommand extends BuilderToolsCommand {

    /**
     * CubeCommand constructor.
     */
    public function __construct() {
        parent::__construct("/cube", "Create cube", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§7Usage: §c//cube <id1:dmg1,id2:dmg2,...> <radius>");
            return;
        }
        $radius = isset($args[1]) ? (int)$args[1] : 5;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);
        /** @var EditorResult $result */
        $result = $printer->makeCube($sender, $sender->asPosition(), $radius, (string)$args[0]);
        $sender->sendMessage(BuilderTools::getPrefix()."§aCube created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." block changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class HollowCubeCommand
 * @package czechpmdevs\buildertools\commands
 */
class HollowCubeCommand extends BuilderToolsCommand {

    /**
     * CubeCommand constructor.
     */
    public function __construct() {
        parent::__construct("/hcube", "Create hollow cube", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        if(!isset($args[0])) {
            $sender->sendMessage("§7Usage: §c//hcube <id1:dmg1,id2:dmg2,...> <radius>");
            return;
        }

        $radius = isset($args[1]) ? (int)$args[1] : 5;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);
        /** @var EditorResult $result */
        $result = $printer->makeHollowCube($sender, $sender->asPosition(), $radius, (string)$args[0]);
        $sender->sendMessage(BuilderTools::getPrefix()."§aHollow cube created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." block changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class CopyCommand
 * @package buildertools\commands
 */
class CopyCommand extends BuilderToolsCommand {

    /**
     * CopyCommand constructor.
     */
    public function __construct() {
        parent::__construct("/copy", "Copy selected area", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }
        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }
        $pos1 = Selectors::getPosition($sender, 1);
        $pos2 = Selectors::getPosition($sender, 2);
        /** @var Copier $copier */
        $copier = BuilderTools::getEditor(Editor::COPIER);
        $copier->copy($pos1->getX(), $pos1->getY(), $pos1->getZ(), $pos2->getX(), $pos2->getY(), $pos2->getZ(), $sender);
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\level\Position;
use pocketmine\Player;

/**
 * Class CopyCommand
 * @package buildertools\commands
 */
class PasteCommand extends BuilderToolsCommand {

    /**
     * PasteCommand constructor.
     */
    public function __construct() {
        parent::__construct("/paste", "Paste copied area", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        /** @var Copier $copier */
        $copier = BuilderTools::getEditor(Editor::COPIER);
        $copier->paste($sender);
        $sender->sendMessage(BuilderTools::getPrefix()."§aCopied area successfully pasted!");
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class MergeCommand
 * @package buildertools\commands
 */
class MergeCommand extends BuilderToolsCommand {

    /**
     * PasteCommand constructor.
     */
    public function __construct() {
        parent::__construct("/merge", "Merge copied area", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }
        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }
        /** @var Copier $copier */
        $copier = BuilderTools::getEditor(Editor::COPIER);
        $copier->merge($sender);
        $sender->sendMessage(BuilderTools::getPrefix()."§aCopied area successfully merged!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class RotateCommand
 * @package buildertools\commands
 */
class RotateCommand extends BuilderToolsCommand {

    /**
     * RotateCommand constructor.
     */
    public function __construct() {
        parent::__construct("/rotate", "Rotate selected area", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        /** @var Copier $copier */
        $copier = BuilderTools::getEditor(Editor::COPIER);
        $copier->addToRotate($sender);
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class FlipCommand
 * @package buildertools\commands
 */
class FlipCommand extends BuilderToolsCommand {

    /**
     * FlipCommand constructor.
     */
    public function __construct() {
        parent::__construct("/flip", "Flip selected area", null, []);
    }

    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        /** @var Copier $copier */
        $copier = BuilderTools::getEditor(Editor::COPIER);

        if(!isset($copier->copyData[$sender->getName()])) {
            $sender->sendMessage(BuilderTools::getPrefix() . "§cUse //copy first!");
        }
        $copier->flip($sender);
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Canceller;
use czechpmdevs\buildertools\editors\Editor;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class UndoCommand
 * @package buildertools\commands
 */
class UndoCommand extends BuilderToolsCommand {

    /**
     * UndoCommand constructor.
     */
    public function __construct() {
        parent::__construct("/undo", "Undo last BuilderTools actions", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        /** @var Canceller $canceller */
        $canceller = BuilderTools::getEditor(Editor::CANCELLER);
        $result = $canceller->undo($sender);

        if(!$result->error) $sender->sendMessage(BuilderTools::getPrefix()."§aStep was cancelled!");
    }

}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Canceller;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class UndoCommand
 * @package buildertools\commands
 */
class RedoCommand extends BuilderToolsCommand {

    /**
     * UndoCommand constructor.
     */
    public function __construct() {
        parent::__construct("/redo", "Redo last BuilderTools actions", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        /** @var Canceller $canceller */
        $canceller = BuilderTools::getEditor(Editor::CANCELLER);

        /** @var EditorResult $result */
        $result = $canceller->redo($sender);

        if(!$result->error) $sender->sendMessage(BuilderTools::getPrefix()."§aUndo was cancelled!");
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use pocketmine\command\CommandSender;
use pocketmine\level\generator\object\BirchTree;
use pocketmine\level\generator\object\JungleTree;
use pocketmine\level\generator\object\OakTree;
use pocketmine\level\generator\object\SpruceTree;
use pocketmine\Player;
use pocketmine\utils\Random;

/**
 * Class TreeCommand
 * @package buildertools\commands
 */
class TreeCommand extends BuilderToolsCommand {

    /**
     * TreeCommand constructor.
     */
    public function __construct() {
        parent::__construct("/tree", "Place tree object", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7/tree <list|treeType>");
            return;
        }

        if(strtolower($args[0]) == "list") {
            $sender->sendMessage(BuilderTools::getPrefix()."§aTree list: Birch, Oak, Jungle, Spruce");
            return;
        }

        $object = null;

        switch (strtolower($args[0])) {
            case "oak":
                $object = new OakTree;
                break;
            case "birch":
                $object = new BirchTree;
                break;
            case "jungle":
                $object = new JungleTree;
                break;
            case "spruce":
                $object = new SpruceTree;
                break;
        }

        if($object === null) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cObject {$args[0]} does not found!");
            return;
        }

        $object->placeObject($sender->getLevel(), (int)$sender->getX(), (int)$sender->getY(), (int)$sender->getZ(), new Random($sender->getLevel()->getSeed()));
        $sender->sendMessage(BuilderTools::getPrefix()."§aObject {$args[0]} placed!");
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Fixer;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class FixCommand
 * @package buildertools\commands
 */
class FixCommand extends BuilderToolsCommand {

    /**
     * FixCommand constructor.
     */
    public function __construct() {
        parent::__construct("/fix", "Fix selected area");
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }

        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }

        $firstPos = Selectors::getPosition($sender, 1);
        $secondPos = Selectors::getPosition($sender, 2);
        
        if($firstPos->getLevel()->getName() != $secondPos->getLevel()->getName()) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cPositions must be in same level");
            return;
        }

        /** @var Fixer $fixer */
        $fixer = BuilderTools::getEditor(Editor::FIXER);
        $fixer->fix($firstPos->getX(), $firstPos->getY(), $firstPos->getZ(), $secondPos->getX(), $secondPos->getY(), $secondPos->getZ(), $sender->getLevel(), $sender);
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\item\enchantment\Enchantment;
use pocketmine\item\enchantment\EnchantmentInstance;
use pocketmine\item\Item;
use pocketmine\Player;

/**
 * Class BlockInfoCommand
 * @package czechpmdevs\buildertools\commands
 */
class BlockInfoCommand extends BuilderToolsCommand {

    /**
     * ReplaceCommand constructor.
     */
    public function __construct() {
        parent::__construct("/blockinfo", "Switch block info mode", null, ["/bi", "/debug"]);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(BuilderTools::getConfiguration()["items"]["blockinfo-stick"]["enabled"]) {
            $item = Item::get(Item::STICK);
            $item->setCustomName(BuilderTools::getConfiguration()["items"]["blockinfo-stick"]["name"]);
            $item->addEnchantment(new EnchantmentInstance(Enchantment::getEnchantment(50), 1));
            $sender->getInventory()->addItem($item);
            $sender->sendMessage(BuilderTools::getPrefix() . "§aBlock info stick added to your inventory!");
            return;
        }
        Selectors::switchBlockInfoSelector($sender);
        $sender->sendMessage(BuilderTools::getPrefix() . "Block info mode turned " . (Selectors::isBlockInfoPlayer($sender) ? "on" : "off") . "!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use pocketmine\command\CommandSender;
use pocketmine\item\Item;
use pocketmine\Player;

/**
 * Class ClearInventoryCommand
 * @package buildertools\commands
 */
class ClearInventoryCommand extends BuilderToolsCommand {

    /**
     * ClearInventoryCommand constructor.
     */
    public function __construct() {
        parent::__construct("/clearinventory", "Clear inventory", null, ["/ci"]);
    }

    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        $removed = 0;
        foreach ($sender->getInventory()->getContents() as $index => $item) {
            $sender->getInventory()->setItem($index, Item::get(Item::AIR));
            $removed++;
        }

        $sender->sendMessage(BuilderTools::getPrefix()."§aInventory cleared, $removed items removed.");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Filler;
use czechpmdevs\buildertools\editors\Naturalizer;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class NaturalizeCommand
 * @package buildertools\commands
 */
class NaturalizeCommand extends BuilderToolsCommand {

    /**
     * NaturalizeCommand constructor.
     */
    public function __construct() {
        parent::__construct("/naturalize", "Naturalize selected area.", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }
        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }
        $firstPos = Selectors::getPosition($sender, 1);
        $secondPos = Selectors::getPosition($sender, 2);
        if($firstPos->getLevel()->getName() != $secondPos->getLevel()->getName()) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cPositions must be in same level");
            return;
        }
        /** @var Naturalizer $filler */
        $filler = BuilderTools::getEditor(Editor::NATURALIZER);
        $count = $filler->naturalize($firstPos->getX(), $firstPos->getY(), $firstPos->getZ(), $secondPos->getX(), $secondPos->getY(), $secondPos->getZ(), $sender->getLevel(), $sender);
        $sender->sendMessage(BuilderTools::getPrefix()."§aSelected area successfully naturalized!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\schematics\Schematic;
use czechpmdevs\buildertools\schematics\SchematicsManager;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class SchematicCommand
 * @package czechpmdevs\buildertools\commands
 */
class SchematicCommand extends BuilderToolsCommand {

    /**
     * SchematicCommand constructor.
     */
    public function __construct() {
        parent::__construct("/schematic", "Schematics commands", null, ["/schem", "//schematics"]);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0]) || !in_array($args[0], ["load", "reload", "list", "paste"])) {
            $sender->sendMessage("§cUsage: §7//schem <reload|load|list|paste> [filename]");
            return;
        }
        switch ($args[0]) {
            case "load":
                if(!isset($args[1])) {
                    $sender->sendMessage("§cUsage: §7//schem <load> <filename>");
                    break;
                }

                $schematic = BuilderTools::getSchematicsManager()->getSchematic(str_replace(".schematic", "", $args[1]));

                if($schematic === null) {
                    $sender->sendMessage(BuilderTools::getPrefix() . "§cSchematic was not found!");
                    return;
                }

                BuilderTools::getSchematicsManager()->addToPaste($sender, $schematic);
                $sender->sendMessage(BuilderTools::getPrefix() . "§aSchematic copied to clipboard, type §2//schem paste§a to paste!");
                break;
            case "paste":
                BuilderTools::getSchematicsManager()->pasteSchematic($sender);
                $sender->sendMessage(BuilderTools::getPrefix() . "§aSchematic pasted successfully!");
                break;
            case "list":
                $list = [];
                foreach (BuilderTools::getSchematicsManager()->getLoadedSchematics() as $name => $schematic) {
                    $list[] = $name;
                }
                $sender->sendMessage(BuilderTools::getPrefix() . (string)count($list) . " loaded schematics: " . implode(", ", $list));
                break;
            case "reload":
                BuilderTools::getSchematicsManager()->loadSchematics();
                $sender->sendMessage(BuilderTools::getPrefix() . "§aSchematics reloaded. Type §2//schem list §ato get list of all loaded schematics.");
                break;
        }
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class CylinderCommand
 * @package czechpmdevs\buildertools\commands
 */
class PyramidCommand extends BuilderToolsCommand {

    /**
     * SphereCommand constructor.
     */
    public function __construct() {
        parent::__construct("/pyramid", "Create pyramid", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     *
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//pyramid <id1:dmg1,id2:dmg2:,...> [size]");
            return;
        }

        $size = isset($args[1]) ? (int)($args[1]) : 5;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);

        /** @var EditorResult $result */
        $result = $printer->makePyramid($sender, $sender, $size, $args[0]);

        $sender->sendMessage(BuilderTools::getPrefix()."§aPyramid created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class CylinderCommand
 * @package czechpmdevs\buildertools\commands
 */
class HollowPyramidCommand extends BuilderToolsCommand {

    /**
     * SphereCommand constructor.
     */
    public function __construct() {
        parent::__construct("/hpyramid", "Create hollow pyramid", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     *
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//hpyramid <id1:dmg1,id2:dmg2,...> [size]");
            return;
        }

        $size = isset($args[1]) ? (int)($args[1]) : 5;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);

        /** @var EditorResult $result */
        $result = $printer->makeHollowPyramid($sender, $sender, $size, $args[0]);

        $sender->sendMessage(BuilderTools::getPrefix()."§aHollow pyramid created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class CylinderCommand
 * @package czechpmdevs\buildertools\commands
 */
class CylinderCommand extends BuilderToolsCommand {

    /**
     * SphereCommand constructor.
     */
    public function __construct() {
        parent::__construct("/cylinder", "Create cylinder", null, ["/cyl"]);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     *
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//cylinder <id1:dmg1,id2:dmg2:,...> [radius] [height]");
            return;
        }
        $radius = isset($args[1]) ? (int)($args[1]) : 5;
        $height = isset($args[2]) ? (int)($args[2]) : 8;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);

        /** @var EditorResult $result */
        $result = $printer->makeCylinder($sender, $sender, $radius, $height, $args[0]);

        $sender->sendMessage(BuilderTools::getPrefix()."§aCylinder created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\editors\Printer;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class CylinderCommand
 * @package czechpmdevs\buildertools\commands
 */
class HollowCylinderCommand extends BuilderToolsCommand {

    /**
     * SphereCommand constructor.
     */
    public function __construct() {
        parent::__construct("/hcylinder", "Create hollow cylinder", null, ["/hcyl"]);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     *
     * @return mixed|void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//hcylinder <id1:dmg1,id2:dmg2:...> [radius] [height]");
            return;
        }

        $radius = isset($args[1]) ? (int)($args[1]) : 5;
        $height = isset($args[2]) ? (int)($args[2]) : 8;

        /** @var Printer $printer */
        $printer = BuilderTools::getEditor(Editor::PRINTER);

        /** @var EditorResult $result */
        $result = $printer->makeHollowCylinder($sender, $sender, $radius, $height, $args[0]);

        $sender->sendMessage(BuilderTools::getPrefix()."§aHollow cylinder created in ".(string)round($result->time, 2)." (".(string)$result->countBlocks." changed)!");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class StackCommand
 * @package czechpmdevs\buildertools\commands
 */
class StackCommand extends BuilderToolsCommand {

    /**
     * StackCommand constructor.
     */
    public function __construct() {
        parent::__construct("/stack", "Stack copied area", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage("§cUsage: §7//stack <count> [side|up|down]");
            return;
        }
        if(!is_numeric($args[0])) {
            $sender->sendMessage(BuilderTools::getPrefix() . "§cType number!");
            return;
        }

        $count = (int)$args[0];
        $mode = Copier::DIRECTION_PLAYER;
        if(isset($args[1])) {
            switch (strtoupper($args[1])) {
                case "UP":
                    $mode = Copier::DIRECTION_UP;
                    break;
                case "DOWN":
                    $mode = Copier::DIRECTION_DOWN;
                    break;
            }
        }

        /** @var Copier $copier */
        $copier = BuilderTools::getEditor(Editor::COPIER);
        $copier->stack($sender, $count, $mode);
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Filler;
use czechpmdevs\buildertools\Selectors;
use pocketmine\command\CommandSender;
use pocketmine\Player;

/**
 * Class OutlineCommand
 * @package czechpmdevs\buildertools\commands
 */
class OutlineCommand extends BuilderToolsCommand {

    /**
     * OutlineCommand constructor.
     */
    public function __construct() {
        parent::__construct("/outline", "Fills hollow selected area.", null, ["/hset"]);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     * @return void
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }
        if(!isset($args[0])) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cUsage: §7//outline <id1:meta1,id2:meta2,...>");
            return;
        }

        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }

        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }

        $firstPos = Selectors::getPosition($sender, 1);
        $secondPos = Selectors::getPosition($sender, 2);

        if($firstPos->getLevel()->getName() != $secondPos->getLevel()->getName()) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cPositions must be in same level");
            return;
        }

        $startTime = microtime(true);

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);

        $blocks = $filler->prepareFill($firstPos->asVector3(), $secondPos->asVector3(), $firstPos->getLevel(), $args[0], false);
        $result = $filler->fill($sender, $blocks);

        $sender->sendMessage(BuilderTools::getPrefix()."§aSelected area filled in " . (string)round(microtime(true)-$startTime, 2) . " (" . (string)$result->countBlocks . " block changed)");
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\commands;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Filler;
use czechpmdevs\buildertools\editors\object\BlockList;
use czechpmdevs\buildertools\Selectors;
use pocketmine\block\Block;
use pocketmine\command\CommandSender;
use pocketmine\math\Vector3;
use pocketmine\Player;

/**
 * Class MoveCommand
 * @package czechpmdevs\buildertools\commands
 */
class MoveCommand extends BuilderToolsCommand {

    /**
     * MoveCommand constructor.
     */
    public function __construct() {
        parent::__construct("/move", "Move selected area", null, []);
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param array $args
     */
    public function execute(CommandSender $sender, string $commandLabel, array $args) {
        if(!$this->testPermission($sender)) return;
        if(!$sender instanceof Player) {
            $sender->sendMessage("§cThis command can be used only in game!");
            return;
        }

        if(count($args) < 3 || !is_numeric($args[0]) || !is_numeric($args[1]) || !is_numeric($args[2])) {
            $sender->sendMessage("§cUsage: §7//move <x> <y> <z>");
            return;
        }

        if(!Selectors::isSelected(1, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the first position.");
            return;
        }

        if(!Selectors::isSelected(2, $sender)) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cFirst you need to select the second position.");
            return;
        }

        $firstPos = Selectors::getPosition($sender, 1);
        $secondPos = Selectors::getPosition($sender, 2);

        if($firstPos->getLevel()->getName() != $secondPos->getLevel()->getName()) {
            $sender->sendMessage(BuilderTools::getPrefix()."§cPositions must be in same level");
            return;
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);

        $blocks = BlockList::build($sender->getLevel(), $firstPos, $secondPos);
        $toFill = $blocks->add(new Vector3((int)$args[0], (int)$args[1], (int)$args[2]));

        $toRemove = $filler->prepareFill($firstPos, $secondPos, $firstPos->getLevel(), "air", true);

        $filler->fill($sender, $toRemove);
        $filler->fill($sender, $toFill);
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\event\listener;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Copier;
use czechpmdevs\buildertools\editors\Editor;
use czechpmdevs\buildertools\editors\Printer;
use czechpmdevs\buildertools\Selectors;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerChatEvent;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\item\Item;
use pocketmine\level\Position;

/**
 * Class EventListener
 * @package buildertools\events\listener
 */
class EventListener implements Listener {

    /** @var int[] $directionCheck */
    public $directionCheck = [];

    /** @var array $toRotate */
    public $toRotate = [];

    /** @var array $rotateCache */
    public $rotateCache = [];

    /** @var array $wandClicks */
    private $wandClicks = [];

    /** @var array $blockInfoClicks */
    private $blockInfoClicks = [];

    /**
     * @param PlayerMoveEvent $event
     */
    public function onDirectionChange(PlayerMoveEvent $event) {
        if(count($this->directionCheck) == 0) {
            return;
        }

        $player = $event->getPlayer();

        if(!isset($this->directionCheck[$player->getName()])) {
            return;
        }

        $direction = (int)$this->directionCheck[$player->getName()];

        if($direction != $player->getDirection()) {
            if(isset($this->rotateCache[$player->getName()])) {
                if($this->rotateCache[$player->getName()] == $event->getPlayer()->getDirection()) {
                    return;
                }
            }
            $this->rotateCache[$player->getName()] = $player->getDirection();
            $player->sendMessage(BuilderTools::getPrefix()."If you want to rotate object changing direction from {$direction} to {$player->getDirection()} type into the chat §bconfirm§a.");
            $this->toRotate[$player->getName()] = [$player, $direction, $player->getDirection()];
            return;
        }


    }

    /**
     * @param PlayerChatEvent $event
     */
    public function onChatConfirm(PlayerChatEvent $event) {
        if(count($this->toRotate) == 0) {
            return;
        }

        $player = $event->getPlayer();
        $msg = explode(" ", strtolower($event->getMessage()))[0];


        if(!isset($this->toRotate[$player->getName()])) {
            return;
        }

        if(!in_array($msg, ["confirm", "cancel"])) {
            $player->sendMessage(BuilderTools::getPrefix()."You are rotating object. If you want to cancel it, type into the chat§b cancel§a.");
            $event->setCancelled(true);
            return;
        }

        if($msg == "cancel") {
            unset($this->toRotate[$player->getName()]);
            unset($this->directionCheck[$player->getName()]);
            $player->sendMessage(BuilderTools::getPrefix()."You are cancelled rotating an object.");
            $event->setCancelled(true);
            return;
        }

        $player->sendMessage(BuilderTools::getPrefix()."§aRotating selected area...");
        $event->setCancelled(true);

        $toRotate = $this->toRotate[$player->getName()];

        unset($this->toRotate[$player->getName()]);
        unset($this->directionCheck[$player->getName()]);

        /** @var Copier $copier */
        $copier = BuilderTools::getEditor(Editor::COPIER);
        $copier->rotate($player, $toRotate[1], $toRotate[2]);

    }

    /**
     * @param PlayerInteractEvent $event
     */
    public function onAirClick(PlayerInteractEvent $event) {
        if(!Selectors::isDrawingPlayer($player = $event->getPlayer())) return;
        $position = $player->getTargetBlock(64)->asPosition();
        $printer = BuilderTools::getEditor(Editor::PRINTER);
        if($printer instanceof Printer) {
            $printer->draw($player, $position, $player->getInventory()->getItemInHand()->getBlock(), Selectors::getDrawingPlayerBrush($player), Selectors::getDrawingPlayerMode($player), Selectors::getDrawingPlayerFall($player));
        }
        $event->setCancelled(true);
    }

    /**
     * @param BlockBreakEvent $event
     */
    public function onBlockBreak(BlockBreakEvent $event) {
        if(Selectors::isWandSelector($player = $event->getPlayer()) || ($event->getItem()->getId() == Item::WOODEN_AXE && $event->getItem()->hasEnchantment(50))) {
            Selectors::addSelector($player, 1, $position = new Position((int)($event->getBlock()->getX()), (int)($event->getBlock()->getY()), (int)($event->getBlock()->getZ()), $player->getLevel()));
            $player->sendMessage(BuilderTools::getPrefix()."§aSelected first position at {$position->getX()}, {$position->getY()}, {$position->getZ()}");
            $event->setCancelled(true);
        }
    }

    /**
     * @param PlayerInteractEvent $event
     */
    public function onBlockTouch(PlayerInteractEvent $event) {
        if($event->getAction() !== PlayerInteractEvent::RIGHT_CLICK_BLOCK) return;
        if(Selectors::isWandSelector($player = $event->getPlayer()) || ($event->getItem()->getId() == Item::WOODEN_AXE && $event->getItem()->hasEnchantment(50))) {
            // antispam ._.
            if(isset($this->wandClicks[$player->getName()]) && microtime(true)-$this->wandClicks[$player->getName()] < 0.5) return;
            $this->wandClicks[$player->getName()] = microtime(true);
            Selectors::addSelector($player, 2, $position = new Position((int)($event->getBlock()->getX()), (int)($event->getBlock()->getY()), (int)($event->getBlock()->getZ()), $player->getLevel()));
            $player->sendMessage(BuilderTools::getPrefix()."§aSelected second position at {$position->getX()}, {$position->getY()}, {$position->getZ()}");
            $event->setCancelled(true);
        }
        if(Selectors::isBlockInfoPlayer($player = $event->getPlayer()) || ($event->getItem()->getId() == Item::STICK && $event->getItem()->hasEnchantment(50))) {
            // antispam ._.
            if(isset($this->blockInfoClicks[$player->getName()]) && microtime(true)-$this->blockInfoClicks[$player->getName()] < 0.5) return;
            $this->blockInfoClicks[$player->getName()] = microtime(true);
            $block = $event->getBlock();
            $player->sendTip("§aID: §7" . (string)$block->getId(). ":" . (string)$block->getDamage() . "\n" .
            "§aName: §7" . (string)$block->getName() . "\n" .
            "§aPosition: §7" . (string)$block->getX() . ", " . (string)$block->getY() . ", " . (string)$block->getZ() . "\n" .
            "§aLevel: §7" . $block->getLevel()->getName());
        }
    }

    /**
     * @return BuilderTools $builderTools
     */
    public function getPlugin():BuilderTools {
        return BuilderTools::getInstance();
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\object\BlockList;
use czechpmdevs\buildertools\editors\object\EditorResult;
use pocketmine\block\Block;
use pocketmine\level\Level;
use pocketmine\level\utils\SubChunkIteratorManager;
use pocketmine\math\Vector3;
use pocketmine\network\mcpe\protocol\FullChunkDataPacket;
use pocketmine\network\mcpe\protocol\LevelChunkPacket;
use pocketmine\Player;

/**
 * Class Filler
 * @package buildertools\editors
 */
class Filler extends Editor {

    /**
     * @param Vector3 $pos1
     * @param Vector3 $pos2
     * @param Level $level
     * @param string $blockArgs
     * @param bool $filled
     *
     * @return BlockList
     */
    public function prepareFill(Vector3 $pos1, Vector3 $pos2, Level $level, string $blockArgs, $filled = true): BlockList {
        $blockList = new BlockList;
        $blockList->setLevel($level);

        for($x = min($pos1->getX(), $pos2->getX()); $x <= max($pos1->getX(), $pos2->getX()); $x++) {
            for($y = min($pos1->getY(), $pos2->getY()); $y <= max($pos1->getY(), $pos2->getY()); $y++) {
                for($z = min($pos1->getZ(), $pos2->getZ()); $z <= max($pos1->getZ(), $pos2->getZ()); $z++) {
                    if(!$filled) {
                        if($x != min($pos1->getX(), $pos2->getX()) && $x != max($pos1->getX(), $pos2->getX())) {
                            if($y != min($pos1->getY(), $pos2->getY()) && $y != max($pos1->getY(), $pos2->getY())) {
                                if($z != min($pos1->getZ(), $pos2->getZ()) && $z != max($pos1->getZ(), $pos2->getZ())) {
                                    continue;
                                }
                            }
                        }
                    }
                    $blockList->addBlock(new Vector3($x, $y, $z), $this->getBlockFromString($blockArgs));
                }
            }
        }

        return $blockList;
    }


    /**
     * @param Player $player
     * @param BlockList $blockList
     * @param bool[] $settings
     *
     * @return EditorResult
     */
    public function fill(Player $player, BlockList $blockList, array $settings = []): EditorResult {
        $startTime = microtime(true);
        /** @var  $blocks */
        $blocks = $blockList->getAll();

        /** @var bool $saveUndo */
        $saveUndo = true;
        /** @var bool $saveRedo */
        $saveRedo = false;

        if(isset($settings["saveUndo"]) && is_bool($settings["saveUndo"])) $saveUndo = $settings["saveUndo"];
        if(isset($settings["saveRedo"]) && is_bool($settings["saveRedo"])) $saveRedo = $settings["saveRedo"];

        $undoList = new BlockList;
        $redoList = new BlockList;

        if($saveUndo) $undoList->setLevel($blockList->getLevel());
        if($saveRedo) $redoList->setLevel($blockList->getLevel());

        $iterator = new SubChunkIteratorManager($blockList->getLevel());

        /** @var int $minX */
        $minX = null;
        /** @var int $maxX */
        $maxX = null;
        /** @var int $minZ */
        $minZ = null;
        /** @var int $maxZ */
        $maxZ = null;

        /**
         * @param Level $level
         * @param int $x1
         * @param int $z1
         * @param $x2
         * @param $z2
         */
        $reloadChunks = function (Level $level, int $x1, int $z1, int $x2, int $z2) {
            for($x = $x1 >> 4; $x <= $x2 >> 4; $x++) {
                for($z = $z1 >> 4; $z <= $z2 >> 4; $z++) {
                    $tiles = $level->getChunkTiles($x, $z);
                    $chunk = $level->getChunk($x, $z);
                    $level->setChunk($x, $z, $chunk);

                    foreach ($tiles as $tile) {
                        $tile->closed = false;
                        $tile->setLevel($level);
                        $level->addTile($tile);
                    }


                    foreach ($level->getChunkLoaders($x, $z) as $chunkLoader) {
                        if($chunkLoader instanceof Player) {
                            if(class_exists(FullChunkDataPacket::class)) {
                                $pk = new FullChunkDataPacket();
                                $pk->chunkX = $x;
                                $pk->chunkZ = $z;
                                $pk->data = $chunk->networkSerialize();
                            }
                            else {
                                $pk = LevelChunkPacket::withoutCache($x, $z, $chunk->getSubChunkSendCount(), $chunk->networkSerialize());
                            }
                            $chunkLoader->dataPacket($pk);
                        }
                    }
                }
            }
        };

        foreach ($blocks as $block) {
            // min and max positions
            if($minX === null || $block->getX() < $minX) $minX = $block->getX();
            if($minZ === null || $block->getZ() < $minZ) $minZ = $block->getZ();
            if($maxX === null || $block->getX() > $maxX) $maxX = $block->getX();
            if($maxZ === null || $block->getZ() > $maxZ) $maxZ = $block->getZ();

            $iterator->moveTo((int)$block->getX(), (int)$block->getY(), (int)$block->getZ());

            if($iterator->currentSubChunk === null) {
                $this->getPlugin()->getLogger()->error("Error while filling: Could not found sub chunk at {$block->getX()}:{$block->getY()}:{$block->getZ()}");
                continue;
            }

            if($saveUndo) $undoList->addBlock($block->asVector3(), Block::get($iterator->currentSubChunk->getBlockId($block->getX() & 0x0f, $block->getY() & 0x0f, $block->getZ() & 0x0f), $iterator->currentSubChunk->getBlockData($block->getX() & 0x0f, $block->getY() & 0x0f, $block->getZ() & 0x0f)));
            if($saveRedo) $redoList->addBlock($block->asVector3(), Block::get($iterator->currentSubChunk->getBlockId($block->getX() & 0x0f, $block->getY() & 0x0f, $block->getZ() & 0x0f), $iterator->currentSubChunk->getBlockData($block->getX() & 0x0f, $block->getY() & 0x0f, $block->getZ() & 0x0f)));
            $iterator->currentSubChunk->setBlock($block->getX() & 0x0f, $block->getY() & 0x0f, $block->getZ() & 0x0f, $block->getId(), $block->getDamage());
        }

        $reloadChunks($blockList->getLevel(), (int)$minX, (int)$minZ, (int)$maxX, (int)$maxZ);

        if($saveUndo) {
            /** @var Canceller $canceller */
            $canceller = BuilderTools::getEditor(static::CANCELLER);
            $canceller->addStep($player, $undoList);
        }

        if($saveRedo) {
            /** @var Canceller $canceller */
            $canceller = BuilderTools::getEditor(static::CANCELLER);
            $canceller->addRedo($player, $redoList);
        }


        return new EditorResult(count($blocks), microtime(true)-$startTime);
    }

    /**
     * @return string
     */
    public function getName(): string {
        return "Filler";
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use pocketmine\block\Block;
use pocketmine\item\Item;

/**
 * Class Editor
 * @package buildertools\editors
 */
abstract class Editor {

    const CANCELLER = "Canceller";
    const COPIER = "Copier";
    const DECORATOR = "Decorator";
    const FILLER = "Filler";
    const FIXER = "Fixer";
    const NATURALIZER = "Naturalizer";
    const PRINTER = "Printer";
    const REPLACEMENT = "Replacement";

    /**
     * @return string
     */
    abstract function getName(): string;

    /**
     * @return BuilderTools
     */
    public function getPlugin(): BuilderTools {
        return BuilderTools::getInstance();
    }

    /**
     * @param string $string
     * @param int $id
     *
     * @return bool
     */
    public function isBlockInString(string $string, int $id): bool {
        $itemArgs = explode(",", $string);

        $items = [];
        foreach ($itemArgs as $itemString) {
            // Item::fromString() throws exception
            try {
                 $block = Item::fromString($itemString)->getBlock();
                 $items[] =  $block->getId();
            }
            catch (\Exception $exception) {}
        }

        return (bool)in_array($id, $items);
    }

    /**
     * @param string $string
     * @return Block $block
     */
    public function getBlockFromString(string $string): Block {
        $itemArgs = explode(",", $string);

        /** @var Item $item */
        $item = null;
        try {
            $item = Item::fromString($itemArgs[array_rand($itemArgs, 1)]);
        }
        catch (\Exception $exception) {
            $item = Item::get(Item::AIR);
        }

        if(!$item instanceof Item) return Block::get(Block::AIR);

        /** @var Block $block */
        $block = null;
        try {
            $block = $item->getBlock();
        }
        catch (\Exception $exception) {
            $block = Block::get(Block::AIR);
        }

        if(!$block instanceof Block) {
            return Block::get(Block::AIR);
        }

        return $block;
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\object\BlockList;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\utils\Math;
use const pocketmine\BASE_VERSION;
use pocketmine\block\Block;
use pocketmine\level\Position;
use pocketmine\math\Vector3;
use pocketmine\Player;

/**
 * Class Printer
 * @package buildertools\editors
 */
class Printer extends Editor {

    public const CUBE = 0x00;
    public const SPHERE = 0x01;
    public const CYLINDER = 0x02;
    public const HCUBE = 0x03;
    public const HSPHERE = 0x04;
    public const HCYLINDER = 0x05;

    public const X_AXIS = 0x01;
    public const Y_AXIS = 0x02;
    public const Z_AXIS = 0x03;

    /**
     * @param Player $player
     * @param Position $center
     * @param Block $block
     * @param int $brush
     * @param int $mode
     * @param bool $fall
     */
    public function draw(Player $player, Position $center, Block $block, int $brush = 4, int $mode = 0x00, bool $fall = false) {
        $undoList = new BlockList;
        $center = Math::roundPosition($center);
        switch ($mode) {
            case self::CUBE:
                for ($x = $center->getX()-$brush; $x <= $center->getX()+$brush; $x++) {
                    for ($y = $center->getY()-$brush; $y <= $center->getY()+$brush; $y++) {
                        for ($z = $center->getZ()-$brush; $z <= $center->getZ()+$brush; $z++) {
                            if($fall) {
                                $finalPos = $this->throwBlock(new Position($x, $y, $z, $center->getLevel()), $block);
                                $undoList->addBlock($finalPos, $block);
                            } else {
                                if($y > 0) {
                                    $level = $center->getLevel();
                                    if(version_compare(BASE_VERSION, "4.0.0") < 0) {
                                        $level->setBlockIdAt($x, $y, $z, $block->getId());
                                        $level->setBlockDataAt($x, $y, $z, $block->getDamage());
                                    }
                                    else {
                                        $level->setBlockAt($x, $y, $z, $block);
                                    }
                                    $undoList->addBlock(new Vector3($x, $y, $z), $block);
                                }
                            }
                        }
                    }
                }
                break;

            case self::SPHERE:
                for ($x = $center->getX()-$brush; $x <= $center->getX()+$brush; $x++) {
                    $xsqr = ($center->getX()-$x) * ($center->getX()-$x);
                    for ($y = $center->getY()-$brush; $y <= $center->getY()+$brush; $y++) {
                        $ysqr = ($center->getY()-$y) * ($center->getY()-$y);
                        for ($z = $center->getZ()-$brush; $z <= $center->getZ()+$brush; $z++) {
                            $zsqr = ($center->getZ()-$z) * ($center->getZ()-$z);
                            if(($xsqr + $ysqr + $zsqr) <= ($brush*$brush)) {
                                if($fall) {
                                    $finalPos = $this->throwBlock(new Position($x, $y, $z, $center->getLevel()), $block);
                                    $undoList->addBlock($finalPos, $block);
                                }
                                else {
                                    if($y > 0) {
                                        $level = $center->getLevel();
                                        if(version_compare(BASE_VERSION, "4.0.0") < 0) {
                                            $level->setBlockIdAt($x, $y, $z, $block->getId());
                                            $level->setBlockDataAt($x, $y, $z, $block->getDamage());
                                        }
                                        else {
                                            $level->setBlockAt($x, $y, $z, $block);
                                        }
                                        $undoList->addBlock(new Vector3($x, $y, $z), $block);
                                    }
                                }
                            }
                        }
                    }
                }
                break;
        }
    }

    /**
     * @param Position $position
     * @param Block $block
     *
     * @return Vector3 $pos
     */
    private function throwBlock(Position $position, Block $block): Vector3 {
        $level = $position->getLevel();

        $x = $position->getX();
        $y = $position->getY();
        $z = $position->getZ();

        $finalY = $y;

        for($a = $y+1; $a > 0 && $level->getBlockAt($x, $a-1, $z)->getId() == Block::AIR; $a--) {
            $finalY = $a-1;
        }

        if(version_compare(BASE_VERSION, "4.0.0") < 0) {
            $level->setBlockIdAt($x, $finalY, $z, $block->getId());
            $level->setBlockDataAt($x, $finalY, $z, $block->getDamage());
        }
        else {
            $level->setBlockAt($x, $finalY, $z, $block);
        }

        return new Vector3($x, $finalY, $z);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $radius
     * @param $blocks
     * @param bool $hollow
     *
     * @return EditorResult
     */
    public function makeSphere(Player $player, Position $center, int $radius, $blocks, bool $hollow = false): EditorResult {
        $center = Math::roundPosition($center);
        $blockList = new BlockList(BlockList::SAVE_TYPE_BLOCKMAP);
        $blockList->setLevel($center->getLevel());

        $invRadiusX = 1 / $radius;
        $invRadiusY = 1 / $radius;
        $invRadiusZ = 1 / $radius;

        $nextXn = 0;
        $breakX = false;
        for($x = 0; $x <= $radius and $breakX === false; ++$x){
            $xn = $nextXn;
            $nextXn = ($x + 1) * $invRadiusX;
            $nextYn = 0;
            $breakY = false;
            for($y = 0; $y <= $radius and $breakY === false; ++$y){
                $yn = $nextYn;
                $nextYn = ($y + 1) * $invRadiusY;
                $nextZn = 0;
                for($z = 0; $z <= $radius; ++$z){
                    $zn = $nextZn;
                    $nextZn = ($z + 1) * $invRadiusZ;
                    $distanceSq = Math::lengthSq($xn, $yn, $zn);
                    if($distanceSq > 1){
                        if($z === 0){
                            if($y === 0){
                                $breakX = true;
                                $breakY = true;
                                break;
                            }
                            $breakY = true;
                            break;
                        }
                        break;
                    }

                    if($hollow) {
                        if(Math::lengthSq($nextXn, $yn, $zn) <= 1 and Math::lengthSq($xn, $nextYn, $zn) <= 1 and Math::lengthSq($xn, $yn, $nextZn) <= 1){
                            continue;
                        }
                    }


                    $blockList->addBlock($center->add($x, $y, $z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add(-$x, $y, $z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add($x, -$y, $z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add($x, $y, -$z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add(-$x, -$y, $z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add($x, -$y, -$z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add(-$x, $y, -$z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add(-$x, -$y, -$z), $this->getBlockFromString($blocks));
                }
            }
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        return $filler->fill($player, $blockList);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $radius
     * @param $blocks
     *
     * @return EditorResult
     */
    public function makeHollowSphere(Player $player, Position $center, int $radius, $blocks): EditorResult {
        return $this->makeSphere($player, $center, $radius, $blocks, true);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $radius
     * @param int $height
     * @param $blocks
     * @param bool $hollow
     *
     * @return EditorResult
     */
    public function makeCylinder(Player $player, Position $center, int $radius, int $height, $blocks, bool $hollow = false): EditorResult {
        $center = Math::roundPosition($center);
        $blockList = new BlockList(BlockList::SAVE_TYPE_BLOCKMAP);
        $blockList->setLevel($center->getLevel());

        if ($height == 0) {
            return new EditorResult(0, 0, true);
        } elseif ($height < 0) {
            $height = -$height;
            $center = $center->setComponents($center->getY(), $height, $center->getZ());
        }

        if ($center->getFloorY() < 0) {
            return new EditorResult(0,0, true);
        }

        $invRadiusX = 1 / $radius;
        $invRadiusZ = 1 / $radius;


        $nextXn = 0;
        $breakX = false;
        for ($x = 0; $x <= $radius && $breakX === false; ++$x) {
            $xn = $nextXn;
            $nextXn = ($x + 1) * $invRadiusX;
            $nextZn = 0;
            $breakZ = false;
            for ($z = 0; $z <= $radius && $breakZ === false; ++$z) {
                $zn = $nextZn;
                $nextZn = ($z + 1) * $invRadiusZ;

                $distanceSq = Math::lengthSq($xn, $zn);
                if ($distanceSq > 1) {
                    if ($z == 0) {
                        $breakX = true;
                    }
                    $breakZ = true;
                }

                if ($hollow) {
                    if (Math::lengthSq($nextXn, $zn) <= 1 && Math::lengthSq($xn, $nextZn) <= 1) {
                        continue;
                    }
                }

                for ($y = 0; $y < $height; ++$y) {
                    $blockList->addBlock($center->add($x, $y, $z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add(-$x, $y, $z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add($x, $y, -$z), $this->getBlockFromString($blocks));
                    $blockList->addBlock($center->add(-$x, $y, -$z), $this->getBlockFromString($blocks));
                }
            }
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        return $filler->fill($player, $blockList);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $radius
     * @param int $height
     * @param $blocks
     *
     * @return EditorResult
     */
    public function makeHollowCylinder(Player $player, Position $center, int $radius, int $height, $blocks): EditorResult {
        return $this->makeCylinder($player, $center, $radius, $height, $blocks, true);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $size
     * @param $blocks
     * @param bool $hollow
     *
     * @return EditorResult
     */
    public function makePyramid(Player $player, Position $center, int $size, $blocks, bool $hollow = false): EditorResult {
        $blockList = new BlockList(BlockList::SAVE_TYPE_BLOCKMAP);
        $blockList->setLevel($center->getLevel());
        $height = $size;
        for ($y = 0; $y <= $height; ++$y) {
            $size--;
            for ($x = 0; $x <= $size; ++$x) {
                for ($z = 0; $z <= $size; ++$z) {
                    if ((!$hollow && $z <= $size && $x <= $size) || $z == $size || $x == $size) {
                        $blockList->addBlock($center->add($x, $y, $z), $this->getBlockFromString($blocks));
                        $blockList->addBlock($center->add(-$x, $y, $z), $this->getBlockFromString($blocks));
                        $blockList->addBlock($center->add($x, $y, -$z), $this->getBlockFromString($blocks));
                        $blockList->addBlock($center->add(-$x, $y, -$z), $this->getBlockFromString($blocks));
                    }
                }
            }
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        return $filler->fill($player, $blockList);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $size
     * @param $blocks
     *
     * @return EditorResult
     */
    public function makeHollowPyramid(Player $player, Position $center, int $size, $blocks): EditorResult {
        return $this->makePyramid($player, $center, $size, $blocks, true);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $radius
     * @param $blocks
     * @param bool $hollow
     *
     * @return EditorResult
     */
    public function makeCube(Player $player, Position $center, int $radius, $blocks, bool $hollow = false): EditorResult {
        $center = Math::roundPosition($center);
        $blockList = new BlockList(BlockList::SAVE_TYPE_NORMAL);
        $blockList->setLevel($center->getLevel());
        for($x = -$radius; $x <= $radius; $x++) {
            for($y = -$radius; $y <= $radius; $y++) {
                for($z = -$radius; $z <= $radius; $z++) {
                    if($hollow) {
                        if(in_array($radius, [$x, $y, $z, -$x, -$y, -$z])) $blockList->addBlock($center->add($x, $y, $z), $this->getBlockFromString($blocks));
                    } else {
                        $blockList->addBlock($center->add($x, $y, $z), $this->getBlockFromString($blocks));
                    }
                }
            }
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        return $filler->fill($player, $blockList);
    }

    /**
     * @param Player $player
     * @param Position $center
     * @param int $radius
     * @param $blocks
     *
     * @return EditorResult
     */
    public function makeHollowCube(Player $player, Position $center, int $radius, $blocks): EditorResult {
        return $this->makeCube($player, $center, $radius, $blocks, true);
    }



    /**
     * @return string
     */
    public function getName(): string {
        return "Printer";
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\editors\object\BlockList;
use pocketmine\level\Level;
use pocketmine\math\Vector3;

/**
 * Class Replacement
 * @package buildertools\editors
 */
class Replacement extends Editor {

    /**
     * @param Vector3 $pos1
     * @param Vector3 $pos2
     * @param Level $level
     *
     * Blocks that will replaced
     * @param string $blocks
     *
     * Blocks that will placed
     * @param string $replace
     *
     * @return BlockList
     */
    public function prepareReplace(Vector3 $pos1, Vector3 $pos2, Level $level, string $blocks, string $replace): BlockList {
        $blockList = new BlockList;
        $blockList->setLevel($level);

        for($x = min($pos1->getX(), $pos2->getX()); $x <= max($pos1->getX(), $pos2->getX()); $x++) {
            for($y = min($pos1->getY(), $pos2->getY()); $y <= max($pos1->getY(), $pos2->getY()); $y++) {
                for($z = min($pos1->getZ(), $pos2->getZ()); $z <= max($pos1->getZ(), $pos2->getZ()); $z++) {
                    if($this->isBlockInString($blocks, $level->getBlockAt($x, $y, $z)->getId())) {
                        $blockList->addBlock(new Vector3($x, $y, $z), $this->getBlockFromString($replace));
                    }
                }
            }
        }

        return $blockList;
    }

    /**
     * @return string
     */
    public function getName(): string {
        return "Replacement";
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\object\BlockList;
use pocketmine\block\Block;
use pocketmine\level\Level;
use pocketmine\math\Vector2;
use pocketmine\math\Vector3;
use pocketmine\Player;

/**
 * Class Naturalizer
 * @package buildertools\editors
 */
class Naturalizer extends Editor {

    /** @var BlockList $undo */
    protected $undo;

    public function __construct() {
        $this->undo = new BlockList();
    }

    /**
     * @param int $x1
     * @param int $y1
     * @param int $z1
     * @param int $x2
     * @param int $y2
     * @param int $z2
     * @param Level $level
     * @param Player $player
     */
    public function naturalize(int $x1, int $y1, int $z1, int $x2, int $y2, int $z2, Level $level, Player $player) {
        $list = new BlockList();
        $list->saveBlockMap(true);
        $list->setLevel($level);

        for($x = min($x1, $x2); $x <= max($x1, $x2); $x++) {
            for($z = min($z1, $z2); $z <= max($z1, $z2); $z++) {
                $this->fix($list, new Vector2($x, $z), (int)min($y1, $y2), (int)max($y1, $y2), $level);
            }
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        $filler->fill($player, $list);
    }

    /**
     * @param BlockList $list
     * @param Vector2 $vector2
     * @param Level $level
     * @param int $minY
     * @param int $maxY
     */
    private function fix(BlockList $list, Vector2 $vector2, int $minY, int $maxY, Level $level) {
        $x = (int)$vector2->getX();
        $z = (int)$vector2->getY();

        $blockY = null;
        for($y = $minY; $y < $maxY; $y++) {
            if($level->getBlockAt($x, $y, $z)->getId() !== Block::AIR && ($blockY === null || $blockY < $y)) {
                $blockY = $y;
            }
        }

        if($blockY === null) return;

        for($y = $blockY; $y > $minY; $y--) {
            switch ($blockY-$y) {
                case 0:
                    $list->addBlock(new Vector3($x, $y, $z), Block::get(Block::GRASS));
                    break;
                case 1:
                case 2:
                case 3:
                    if($level->getBlockAt($x, $y, $z)->getId() != Block::AIR) {
                        $list->addBlock(new Vector3($x, $y, $z), Block::get(Block::DIRT));
                    }
                    break;
                case 4:
                    if($level->getBlockAt($x, $y, $z)->getId() != Block::AIR) {
                        $list->addBlock(new Vector3($x, $y, $z), (rand(0, 1) ? Block::get(Block::DIRT) : Block::get(Block::STONE)));
                    }
                    break;
                default:
                    if($level->getBlockAt($x, $y, $z)->getId() != Block::AIR) {
                        $list->addBlock(new Vector3($x, $y, $z), Block::get(Block::STONE));
                    }
            }
        }
    }


    /**
     * @return string
     */
    public function getName(): string {
        return "Naturalizer";
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors\object;

use pocketmine\block\Block;
use pocketmine\inventory\ArmorInventoryEventProcessor;
use pocketmine\level\Level;
use pocketmine\math\Vector3;

/**
 * Class BlockList
 * @package buildertools\editors\object
 */
class BlockList extends BlockMap {

    public const SAVE_TYPE_NORMAL = 0x01;
    public const SAVE_TYPE_BLOCKMAP = 0x02;
    //public const SAVE_TYPE_OPTIMIZED = 0x03; TODO

    /** @var bool $save */
    private $save;

    /** @var Block[] $blocks */
    private $blocks = [];

    /** @var Level $level */
    private $level;

    /** @var Vector3 $playerPosition */
    private $playerPosition = null;

    /**
     * BlockList constructor.
     * @param int $save
     */
    public function __construct(int $save = self::SAVE_TYPE_NORMAL) {
        $this->save = $save;
    }

    /**
     * @param Vector3 $pos
     * @param Block $block
     * @param bool $saveMap
     */
    public function addBlock(Vector3 $pos, Block $block) {
        if($this->save === self::SAVE_TYPE_NORMAL) {
            $block = clone $block;
            $block->setComponents($pos->getX(), $pos->getY(), $pos->getZ());
            $this->blocks[] = $block;
        }
        elseif($this->save === self::SAVE_TYPE_BLOCKMAP) {
            $this->blockMap[$pos->getX()][$pos->getY()][$pos->getZ()] = clone $block;
        }
    }

    /**
     * @return Block[] $blocks
     */
    public function getAll() {
        if($this->save === self::SAVE_TYPE_NORMAL) {
            return $this->blocks;
        }
        elseif($this->save === self::SAVE_TYPE_BLOCKMAP) {
            return parent::getAll();
        }
        return null;
    }

    /**
     * @param Block[] $blocks
     */
    public function setAll(array $blocks) {
        if($this->save === self::SAVE_TYPE_NORMAL) {
            $this->blocks = $blocks;
        }
        elseif ($this->save === self::SAVE_TYPE_BLOCKMAP) {
            parent::setAll($blocks);
        }
    }

    /**
     * TODO: Implement other modes
     *
     * @param int|Vector3 $x
     * @param int|null $y
     * @param int|null $z
     *
     * @return BlockList
     */
    public function add($x = 0, $y = 0, $z = 0) {
        $blockList = clone $this;
        /** @var Vector3 $vec */
        $vec = null;
        if($x instanceof Vector3) {
            $vec = $x;
        } else {
            $vec = new Vector3($x, $y, $z);
        }
        foreach ($blockList->getAll() as $block) {
            $block->setComponents($block->getX()+$vec->getX(), $block->getY()+$vec->getY(), $block->getZ()+$vec->getZ());
        }
        return $blockList;
    }

    /**
     * TODO: Implement other modes
     *
     * @param int|Vector3 $x
     * @param int|null $y
     * @param int|null $z
     *
     * @return BlockList
     */
    public function subtract($x = 0, $y = 0, $z = 0) {
        /** @var Vector3 $vec */
        $vec = null;
        if($x instanceof Vector3) {
            $vec = $x;
        } else {
            $vec = new Vector3($x, $y, $z);
        }
        return $this->add($vec->multiply(-1));
    }

    /**
     * @param Level $level
     */
    public function setLevel(Level $level) {
        $this->level = $level;
    }

    /**
     * @return Level $level
     */
    public function getLevel() {
        return $this->level;
    }

    /**
     * @return Vector3|null
     */
    public function getPlayerPosition(): ?Vector3 {
        return $this->playerPosition;
    }

    /**
     * @param Vector3 $position
     */
    public function setPlayerPosition(Vector3 $position) {
        $this->playerPosition = $position;
    }


    /**
     * @return array
     */
    public function toCopyData(): array {
        $data = [];
        $data["center"] = $this->playerPosition === null ? new Vector3(0, 0, 0) : $this->playerPosition;
        $data["direction"] = 0;
        $data["rotated"] = false;

        foreach ($this->getAll() as $index => $block) {
            $data["data"][$index] = [$block->asVector3(), $block];
        }

        return $data;
    }

    /**
     * @param array $copyData
     * @param int $save
     *
     * @return BlockList
     */
    public static function fromCopyData(array $copyData, int $save = self::SAVE_TYPE_NORMAL): BlockList {
        $list = new BlockList($save);
        $list->setPlayerPosition($copyData["center"]);

        /**
         * @var Vector3 $vector3
         * @var Block $block
         */
        foreach ($copyData["data"] as [$vector3, $block]) {
            $list->addBlock($vector3, $block);
        }

        return $list;
    }

    /**
     * @param Level $level
     * @param Vector3 $pos1
     * @param Vector3 $pos2
     * @param int $save
     *
     * @return BlockList
     */
    public static function build(Level $level, Vector3 $pos1, Vector3 $pos2, int $save = self::SAVE_TYPE_NORMAL): BlockList {
        $blockList = new BlockList($save);
        $blockList->setLevel($level);

        for($x = min($pos1->getX(), $pos2->getX()); $x <= max($pos1->getX(), $pos2->getX()); $x++) {
            for($y = min($pos1->getY(), $pos2->getY()); $y <= max($pos1->getY(), $pos2->getY()); $y++) {
                for($z = min($pos1->getZ(), $pos2->getZ()); $z <= max($pos1->getZ(), $pos2->getZ()); $z++) {
                    $blockList->addBlock($v = new Vector3($x, $y, $z), $level->getBlock($v));
                }
            }
        }

        return $blockList;
    }
}<?php

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors\object;

use pocketmine\block\Block;
use pocketmine\level\Level;
use vixikhd\skywars\math\Vector3;

/**
 * Class BlockMap
 * @package czechpmdevs\buildertools\editors\object
 */
class BlockMap {

    /** @var Block[][][] $blockMap */
    protected $blockMap = [];

    /**
     * @return array
     */
    public function getBlockMap(): array {
        return $this->blockMap;
    }

    /**
     * @param Vector3 $vector3
     * @return Block|null
     */
    public function getBlockAt(Vector3 $vector3) {
        if(isset($this->blockMap[$vector3->getX()])) {
            if(isset($this->blockMap[$vector3->getY()])) {
                if(isset($this->blockMap[$vector3->getX()][$vector3->getY()][$vector3->getZ()])) {
                    return $this->blockMap[$vector3->getX()][$vector3->getY()][$vector3->getZ()];
                }
                else return null;
            }
            else return null;
        }
        else return null;
    }

    /**
     * @param Block[] $blocks
     */
    public function setAll(array $blocks) {
        foreach ($blocks as $block) {
            $this->blockMap[$block->getX()][$block->getY()][$block->getZ()] = $block;
        }
    }

    /**
     * @return Block[] $blocks
     */
    public function getAll() {
        $blocks = [];
        foreach ($this->blockMap as $x => $yzb) {
            foreach ($yzb as $y => $zb) {
                foreach ($zb as $z => $block) {
                    $block->setComponents($x, $y, $z);
                    $blocks[] = $block;
                }
            }
        }
        return $blocks;
    }


    /**
     * @param int $x
     * @param int $y
     * @param int $z
     *
     * @return bool
     */
    public function isAirAt(int $x, int $y, int $z): bool {
        return $this->isVectorInBlockMap(new Vector3($x, $y, $z)) && $this->blockMap[$x][$y][$z]->getId() == 0;
    }

    /**
     * @param Level $level
     * @param int $x
     * @param int $y
     * @param int $z
     *
     * @return bool
     */
    public function isAirInLevel(Level $level, int $x, int $y, int $z): bool {
        return $this->isVectorInBlockMap(new Vector3($x, $y, $z)) && $this->blockMap[$x][$y][$z]->getId() == 0 && $level->getBlockIdAt($x, $y, $z) == 0;
    }

    /**
     * @param Vector3 $vector3
     *
     * @return bool
     */
    public function isVectorInBlockMap(Vector3 $vector3): bool {
        try {
            $block = $this->blockMap[$vector3->getX()][$vector3->getY()][$vector3->getZ()];
            if($block instanceof Block) {
                return true;
            }
            return false;
        }
        catch (\Exception $exception) {
            return false;
        }
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\object\BlockList;
use czechpmdevs\buildertools\editors\object\EditorResult;
use czechpmdevs\buildertools\utils\Math;
use pocketmine\block\Block;
use pocketmine\item\Item;
use pocketmine\level\format\EmptySubChunk;
use pocketmine\level\Position;
use pocketmine\math\Vector2;
use pocketmine\math\Vector3;
use pocketmine\Player;

/**
 * Class Copier
 * @package buildertools\editors
 */
class Copier extends Editor {

    public const DIRECTION_PLAYER = 0;
    public const DIRECTION_UP = 1;
    public const DIRECTION_DOWN = 2;

    public const FLIP_DATA = [
        // stairs
        0 => [0 => 4, 1 => 5, 2 => 6, 3 => 7, 4 => 0, 5 => 1, 6 => 2, 7 => 3],
        // slabs
        1 => [0 => 8, 1 => 9, 2 => 10, 3 => 11, 4 => 12, 5 => 13, 6 => 14, 7 => 15, 8 => 0, 9 => 1, 10 => 2, 11 => 3, 12 => 4, 13 => 5, 14 => 6, 15 => 7]
    ];

    /** @var array $copyData */
    public $copyData = [];

    /**
     * @return string $copier
     */
    public function getName(): string {
        return "Copier";
    }

    /**
     * @param int $x1
     * @param int $y1
     * @param int $z1
     * @param int $x2
     * @param int $y2
     * @param int $z2
     * @param Player $player
     */
    public function copy(int $x1, int $y1, int $z1, int $x2, int $y2, int $z2, Player $player) {
        $this->copyData[$player->getName()] = [
            "data" => [],
            "center" => $player->asPosition(),
            "direction" => $player->getDirection(),
            "rotated" => false
        ];
        $count = 0;
        for($x = min($x1, $x2); $x <= max($x1, $x2); $x++) {
            for ($y = min($y1, $y2); $y <= max($y1, $y2); $y++) {
                for ($z = min($z1, $z2); $z <= max($z1, $z2); $z++) {
                    $this->copyData[$player->getName()]["data"][$count] = [($vec = Math::roundVector3(new Vector3($x, $y, $z)))->subtract(Math::roundVector3($player->asVector3())), $player->getLevel()->getBlock($vec)];
                    $count++;
                }
            }
        }
        $player->sendMessage(BuilderTools::getPrefix()."§a{$count} blocks copied to clipboard! Use //paste to paste");
    }

    /**
     * @param Player $player
     */
    public function merge(Player $player) {
        if(!isset($this->copyData[$player->getName()])) {
            $player->sendMessage(BuilderTools::getPrefix() . "§cUse //copy first!");
            return;
        }

        /** @var array $blocks */
        $blocks = $this->copyData[$player->getName()]["data"];

        $list = new BlockList();
        $list->setLevel($player->getLevel());

        /**
         * @var Vector3 $vec
         * @var Block $block
         */
        foreach ($blocks as [$vec, $block]) {
            if($player->getLevel()->getBlock($vec->add($player->asVector3()))->getId() == 0) {
                $list->addBlock($vec->add($player->asVector3()), $block);
            }
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        $filler->fill($player, $list);
    }

    /**
     * @param Player $player
     */
    public function paste(Player $player) {
        if(!isset($this->copyData[$player->getName()])) {
            $player->sendMessage(BuilderTools::getPrefix()."§cUse //copy first!");
            return;
        }

        /** @var array $blocks */
        $blocks = $this->copyData[$player->getName()]["data"];

        $list = new BlockList();
        $list->setLevel($player->getLevel());

        /**
         * @var Vector3 $vec
         * @var Block $block
         */
        foreach ($blocks as [$vec, $block]) {
            $list->addBlock($vec->add($player->asVector3()), $block);
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        $filler->fill($player, $list);
    }

    /**
     * @param Player $player
     */
    public function addToRotate(Player $player) {
        if(!isset($this->copyData[$player->getName()])) {
            $player->sendMessage(BuilderTools::getPrefix()."§cUse //copy first!");
            return;
        }
        if($this->copyData[$player->getName()]["rotated"] == true) {
            $player->sendMessage(BuilderTools::getPrefix()."§cSelected area is already rotated!");
            return;
        }
        $player->sendMessage(BuilderTools::getPrefix()."Select direction to rotate moving.");
        BuilderTools::getListener()->directionCheck[$player->getName()] = intval($player->getDirection());
    }

    /**
     * @param Player $player
     * @param int $fromDirection
     * @param int $toDirection
     */
    public function rotate(Player $player, int $fromDirection, int $toDirection) {
        $this->copyData[$player->getName()]["rotated"] = true;
        $min = min($fromDirection, $toDirection);
        $max = max($fromDirection, $toDirection);

        if($min == $max) {
            $player->sendMessage(BuilderTools::getPrefix()."§aSelected area rotated!");
            return;
        }

        $id = "{$fromDirection}:{$toDirection}";

        switch ($id) {
            case "0:0":
            case "1:1":
            case "2:2":
            case "3:3":
                $player->sendMessage(BuilderTools::getPrefix()."§aSelected area rotated! ($id)");
                break;

            case "0:1":
            case "1:2":
            case "2:3":
            case "3:0":
                /**
                 * @var Vector3 $vec
                 * @var Block $block
                 */
                foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
                    $vec->setComponents($vec->getZ(), $vec->getY(), $vec->getX());
                }
                $player->sendMessage(BuilderTools::getPrefix()."§aSelected area rotated! ($id)");
                break;

            case "0:2":
            case "1:3":
            case "2:0":
            case "3:1":
                /**
                 * @var Vector3 $vec
                 * @var Block $block
                 */
                foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
                    $vec->setComponents(-$vec->getX(), $vec->getY(), -$vec->getZ());
                }
                $player->sendMessage(BuilderTools::getPrefix()."§aSelected area rotated! ($id)");
                break;

            case "1:0":
            case "2:1":
            case "3:2":
            case "0:3":
                /**
                 * @var Vector3 $vec
                 * @var Block $block
                 */
                foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
                    $vec->setComponents(-$vec->getX(), $vec->getY(), -$vec->getZ());
                }
                /**
                 * @var Vector3 $vec
                 * @var Block $block
                 */
                foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
                    $vec->setComponents($vec->getZ(), $vec->getY(), $vec->getX());
                }

                $player->sendMessage(BuilderTools::getPrefix()."§aSelected area rotated! ($id)");
                break;
        }
    }

    /**
     * @param Player $player
     */
    public function flip(Player $player) {
        if(!isset($this->copyData[$player->getName()])) {
            $player->sendMessage(BuilderTools::getPrefix() . "§cUse //copy first!");
                return;
        }

        $minY = null;
        $maxY = null;

        /**
         * @var Vector3 $vec
         */
        foreach ($this->copyData[$player->getName()]["data"] as [$vec]) {
            if($minY === null || $vec->getY() < $minY) {
                $minY = $vec->getY();
            }
            if($maxY === null || $vec->getY() > $maxY) {
                $maxY = $vec->getY();
            }
        }

        $add = (int)round(abs($maxY-$minY)/2);

        /**
         * @var Vector3 $vec
         * @var Block $block
         */
        foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
            $vec->setComponents($vec->getX(), (-$vec->getY())+$add, $vec->getZ());
            if(in_array($block->getId(), [Block::OAK_STAIRS, Block::COBBLESTONE_STAIRS, Block::ACACIA_STAIRS, Block::ACACIA_STAIRS, Block::DARK_OAK_STAIRS, Block::JUNGLE_STAIRS, Block::NETHER_BRICK_STAIRS, Block::PURPUR_STAIRS, Block::QUARTZ_STAIRS, Block::BRICK_STAIRS])) {
                $block->setDamage(self::FLIP_DATA[0][$block->getDamage()]);
            }
            if(in_array($block->getId(), [Block::STONE_SLAB, Block::STONE_SLAB2, Block::WOODEN_SLAB])) {
                $block->setDamage(self::FLIP_DATA[1][$block->getDamage()]);
            }
        }

        $player->sendMessage(BuilderTools::getPrefix()."§aSelected area flipped!");
    }

    /**
     * @param Player $player
     * @param int $pasteCount
     * @param int $mode
     */
    public function stack(Player $player, int $pasteCount, int $mode = Copier::DIRECTION_PLAYER) {
        if (!isset($this->copyData[$player->getName()])) {
            $player->sendMessage(BuilderTools::getPrefix() . "§cUse //copy first!");
            return;
        }

        $list = new BlockList();
        $list->setLevel($player->getLevel());

        /** @var Position $center */
        $center = $this->copyData[$player->getName()]["center"];
        $center = $center->add(1, 0 , 1); // why???

        switch ($mode) {
            case self::DIRECTION_PLAYER:
                $d = $player->getDirection();
                switch ($d) {
                    case 0:
                    case 2:
                        $minX = null;
                        $maxX = null;

                        /**
                         * @var Vector3 $vec
                         */
                        foreach ($this->copyData[$player->getName()]["data"] as [$vec]) {
                            if ($minX === null || $vec->getX() < $minX) {
                                $minX = $vec->getX();
                            }
                            if ($maxX === null || $vec->getX() > $maxX) {
                                $maxX = $vec->getX();
                            }
                        }

                        $length = (int)(round(abs($maxX - $minX))+1);
                        if ($d == 2) $length = -$length;
                        for ($pasted = 0; $pasted < $pasteCount; ++$pasted) {
                            $addX = $length * $pasted;
                            foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
                                $list->addBlock($center->add($vec->add($addX)), $block);
                            }
                        }
                        break;
                    case 1:
                    case 3:
                        $minZ = null;
                        $maxZ = null;

                        /**
                         * @var Vector3 $vec
                         */
                        foreach ($this->copyData[$player->getName()]["data"] as [$vec]) {
                            if ($minZ === null || $vec->getZ() < $minZ) {
                                $minZ = $vec->getZ();
                            }
                            if ($maxZ === null || $vec->getZ() > $maxZ) {
                                $maxZ = $vec->getZ();
                            }
                        }

                        $length = (int)(round(abs($maxZ - $minZ))+1);
                        if ($d == 3) $length = -$length;
                        for ($pasted = 0; $pasted < $pasteCount; ++$pasted) {
                            $addZ = $length * $pasted;
                            foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
                                $list->addBlock($center->add($vec->add(0, 0, $addZ)), $block);
                            }
                        }
                        break;
                }
                break;
            case self::DIRECTION_UP:
            case self::DIRECTION_DOWN:
                $minY = null;
                $maxY = null;

                /**
                 * @var Vector3 $vec
                 */
                foreach ($this->copyData[$player->getName()]["data"] as [$vec]) {
                    if ($minY === null || $vec->getY() < $minY) {
                        $minY = $vec->getY();
                    }
                    if ($maxY === null || $vec->getY() > $maxY) {
                        $maxY = $vec->getY();
                    }
                }

                $length = (int)(round(abs($maxY - $minY))+1);
                if ($mode == self::DIRECTION_DOWN) $length = -$length;
                for ($pasted = 0; $pasted <= $pasteCount; ++$pasted) {
                    $addY = $length * $pasted;
                    foreach ($this->copyData[$player->getName()]["data"] as [$vec, $block]) {
                        $list->addBlock($center->add($vec->add(0, $addY)), $block);
                    }
                }
                break;
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(self::FILLER);
        $filler->fill($player, $list);
        $player->sendMessage(BuilderTools::getPrefix()."§aCopied area stacked!");
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\object\BlockList;
use czechpmdevs\buildertools\editors\object\EditorResult;
use pocketmine\Player;


/**
 * Class Canceller
 * @package buildertools\editors
 */
class Canceller extends Editor {

    /** @var BlockList[][] $undoData */
    public $undoData = [];

    /** @var BlockList[][] $redoData */
    public $redoData = [];

    /**
     * @return string $name
     */
    public function getName(): string {
        return "Canceller";
    }

    /**
     * @param Player $player
     * @param BlockList $blocks
     */
    public function addStep(Player $player, BlockList $blocks) {
        $this->undoData[$player->getName()][] = $blocks;
    }

    /**
     * @param Player $player
     * @return EditorResult|null
     */
    public function undo(Player $player): EditorResult {
        if(!isset($this->undoData[$player->getName()]) || count($this->undoData[$player->getName()]) == 0) {
            $player->sendMessage(BuilderTools::getPrefix()."§cThere are not actions to undo!");
            return new EditorResult(0, 0, true);
        }

        $blockList = array_pop($this->undoData[$player->getName()]);

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(static::FILLER);

        return $filler->fill($player, $blockList, [
            "saveUndo" => false,
            "saveRedo" => true
        ]);
    }

    /**
     * @param Player $player
     * @param BlockList $blocks
     */
    public function addRedo(Player $player, BlockList $blocks) {
        $this->redoData[$player->getName()][] = $blocks;
    }

    /**
     * @param Player $player
     * @return EditorResult
     */
    public function redo(Player $player) {
        if(!isset($this->redoData[$player->getName()]) || count($this->redoData[$player->getName()]) == 0) {
            $player->sendMessage(BuilderTools::getPrefix()."§cThere are not actions to redo!");
            return new EditorResult(0, 0, true);
        }

        $blockList = array_pop($this->redoData[$player->getName()]);

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(static::FILLER);
        return $filler->fill($player, $blockList);
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use pocketmine\item\Item;
use pocketmine\level\Position;
use pocketmine\math\Vector3;

/**
 * Class Decorator
 * @package worldfixer\editors
 */
class Decorator extends Editor {

    /**
     * @return string
     */
    public function getName(): string {
        return "Decorator";
    }

    /**
     * @param Position $center
     * @param string $blocks
     * @param int $radius
     * @param int $percentage
     * @param null $player
     */
    public function addDecoration(Position $center, string $blocks, int $radius, int $percentage, $player = null) {
        $undo = [];
        for ($x = $center->getX()-$radius; $x <= $center->getX()+$radius; $x++) {
            for ($z = $center->getZ()-$radius; $z <= $center->getZ()+$radius; $z++) {
                if(rand(1, 100) <= $percentage) {
                    $y = $center->getY()+$radius;
                    check:
                    if($y > 0) {
                        $vec = new Vector3($x, $y, $z);
                        if($center->getLevel()->getBlock($vec)->getId() == 0) {
                            $y--;
                            goto check;
                        }
                        else {
                            $blockArgs = explode(",", $blocks);
                            array_push($undo, $center->getLevel()->getBlock($vec));
                            $undo[] = $center->getLevel()->getBlock($vec->add(0, 1));
                            $center->getLevel()->setBlock($vec->add(0, 1), Item::fromString($blockArgs[array_rand($blockArgs,1)])->getBlock());
                        }
                    }
                }
            }
        }

        /** @var Canceller $canceller */
        $canceller = BuilderTools::getEditor("Canceller");
        $canceller->addStep($player, $undo);
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace czechpmdevs\buildertools\editors;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\object\BlockList;
use pocketmine\block\Block;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\tile\Banner;
use pocketmine\tile\Bed;
use pocketmine\tile\Chest;
use pocketmine\tile\Sign;

/**
 * Class Fixer
 * @package buildertools\editors
 */
class Fixer extends Editor {

    const REMOVE_HEADS = false;
    const FIX_TILES = true;

    /**
     * @var array $blocks
     */
    private static $blocks = [
        158 => [Block::WOODEN_SLAB, 0],
        125 => [Block::DOUBLE_WOODEN_SLAB, ""],
        188 => [Block::FENCE, 0],
        189 => [Block::FENCE, 1],
        190 => [Block::FENCE, 2],
        191 => [Block::FENCE, 3],
        192 => [Block::FENCE, 4],
        193 => [Block::FENCE, 5],
        166 => [Block::INVISIBLE_BEDROCK, 0],
        208 => [Block::GRASS_PATH, 0],
        198 => [Block::END_ROD, 0],
        126 => [Block::WOODEN_SLAB, ""],
        95 => [Block::STAINED_GLASS, ""],
        199 => [Block::CHORUS_PLANT, 0],
        202 => [Block::PURPUR_BLOCK, 0],
        251 => [Block::CONCRETE, 0],
        204 => [Block::PURPUR_BLOCK, 0]
    ];

    /**
     * @param BlockList $blockList
     * @return BlockList
     */
    public function fixBlockList(BlockList $blockList): BlockList {
        $newList = new BlockList();
        foreach ($blockList->getAll() as $block) {
            $id = $block->getId();
            $damage = $block->getDamage();
            $x = $block->getX();
            $y = $block->getY();
            $z = $block->getZ();
            if(isset(self::$blocks[$id])) {
                if(is_int(self::$blocks[$id][1])) $damage = self::$blocks[$id][1];
                $id = self::$blocks[$id][0];
            }

            $block = Block::get($id, $damage);
            $block->setComponents($x, $y, $z);
            $newList->addBlock($block->asVector3(), $block);
        }
        return $newList;
    }

    /**
     * @param $x1
     * @param $y1
     * @param $z1
     * @param $x2
     * @param $y2
     * @param $z2
     * @param Level $level
     * @param Player $player
     */
    public function fix($x1, $y1, $z1, $x2, $y2, $z2, Level $level, Player $player) {
        $blocks = self::$blocks;

        if(self::REMOVE_HEADS) $blocks[Block::MOB_HEAD_BLOCK] = [Block::AIR, 0];

        $blockList = new BlockList();
        $blockList->setLevel($level);

        for($x = min($x1, $x2); $x <= max($x1, $x2); $x++) {
            for ($y = min($y1, $y2); $y <= max($y1, $y2); $y++) {
                for ($z = min($z1, $z2); $z <= max($z1, $z2); $z++) {
                    #$id = $level->getBlockIdAt($x, $y, $z);
                    $id = $level->getBlockAt($x, $y, $z)->getId();

                    if(self::FIX_TILES && \pocketmine\BASE_VERSION != "4.0.0") {
                        switch ($id) {
                            case Block::CHEST:
                                if($level->getTile(new Vector3($x, $y, $z)) === null)
                                    $level->addTile(new Chest($level, Chest::createNBT(new Vector3($x, $y, $z))));
                                break;
                            case Block::SIGN_POST:
                            case Block::WALL_SIGN:
                                if($level->getTile(new Vector3($x, $y, $z)) === null)
                                    $level->addTile(new Sign($level, Sign::createNBT(new Vector3($x, $y, $z))));
                                break;
                            case Block::BED_BLOCK:
                                if($level->getTile(new Vector3($x, $y, $z)) === null)
                                    $level->addTile(new Bed($level, Bed::createNBT(new Vector3($x, $y, $z))));
                                break;
                            case Block::STANDING_BANNER:
                            case Block::WALL_BANNER:
                                if($level->getTile(new Vector3($x, $y, $z)) === null)
                                    $level->addTile(new Banner($level, Banner::createNBT(new Vector3($x, $y, $z))));
                                break;
                        }
                    }


                    if(isset($blocks[$id])) $blockList->addBlock(new Vector3($x, $y, $z), Block::get($blocks[$id][0], (is_int($blocks[$id][1]) ? $blocks[$id][1] : $level->getBlockAt($x, $y, $z)->getDamage())));
                }
            }
        }

        /** @var Filler $filler */
        $filler = BuilderTools::getEditor(Editor::FILLER);
        $result = $filler->fill($player, $blockList);

        $player->sendMessage(BuilderTools::getPrefix()."Selected area successfully fixed! (".(string)($result->countBlocks)." blocks changed!)");
    }

    /**
     * @return string
     */
    public function getName(): string {
        return "Fixer";
    }
}
<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools\schematics;

use czechpmdevs\buildertools\BuilderTools;
use czechpmdevs\buildertools\editors\Filler;
use czechpmdevs\buildertools\editors\object\BlockList;
use pocketmine\Player;

/**
 * Class SchematicsManager
 * @package czechpmdevs\buildertools\schematics
 */
class SchematicsManager {

    /** @var BuilderTools $plugin */
    protected $plugin;

    /** @var Schematic[] $schematics */
    public $schematics = [];

    /** @var Schematic[] $players */
    public $players;

    /**
     * SchematicsManager constructor.
     * @param BuilderTools $plugin
     */
    public function __construct(BuilderTools $plugin) {
        $this->plugin = $plugin;
        $this->init();
        $this->loadSchematics();
    }

    public function init() {
        if(!file_exists($this->plugin->getDataFolder() . "schematics")) {
            @mkdir($this->plugin->getDataFolder() . "schematics");
        }
        if(!file_exists($this->plugin->getDataFolder() . "schematics")) {
            @mkdir($this->plugin->getDataFolder() . "schematics");
        }
    }

    public function loadSchematics() {
        $this->schematics = [];
        $unloaded = BuilderTools::getConfiguration()["schematics"]["load"] != "startup";
        foreach (glob($this->plugin->getDataFolder() . "schematics/*.schematic") as $file) {
            if($unloaded)
                $this->schematics[basename($file, ".schematic")] = new UnloadedSchematic($file);
            else
                $this->schematics[basename($file, ".schematic")] = new Schematic($file);
        }
    }

    /**
     * @param Player $player
     * @param Schematic $schematic
     */
    public function addToPaste(Player $player, Schematic $schematic) {
        $this->players[$player->getName()] = $schematic;
    }

    /**
     * @param Player $player
     */
    public function pasteSchematic(Player $player) {
        if(!isset($this->players[$player->getName()])) {
            $player->sendMessage(BuilderTools::getPrefix(). "§cType //schem load <filename> to load schematic first!");
            return;
        }

        $schematic = $this->players[$player->getName()];
        $blockList = $schematic->getBlockList();

        if($blockList === null) {
            $player->sendMessage(BuilderTools::getPrefix() . "§cInvalid schematic format (Sponge) isn't supported.");
            return;
        }

        $fillList = new BlockList();
        $fillList->setLevel($player->getLevel());
        foreach ($blockList->getAll() as $block) {
            $fillList->addBlock($block->add($player), $block);
        }

        /** @var Filler $filler */
        $filler = new Filler();
        $filler->fill($player, $fillList);
        $player->sendMessage(BuilderTools::getPrefix() . "Schematic successfully pasted.");
    }

    /**
     * @param string $name
     * @return Schematic|null
     */
    public function getSchematic(string $name): ?Schematic {
        return isset($this->schematics[$name]) ? $this->schematics[$name] : null;
    }

    /**
     * @return Schematic[] $schematics
     */
    public function getLoadedSchematics(): array {
        /** @var Schematic $value */
        return array_filter($this->getAllSchematics(), function ($value) {
            return $value->isLoaded;
        }, ARRAY_FILTER_USE_BOTH);
    }

    /**
     * @return Schematic[] $schematics
     */
    public function getAllSchematics(): array {
        return $this->schematics;
    }
}<?php

/**
 * Copyright (C) 2018-2019  CzechPMDevs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace czechpmdevs\buildertools;

use pocketmine\level\Position;
use pocketmine\Player;

/**
 * Class Selectors
 * @package buildertools
 */
class Selectors {

    /** @var Position[] $pos1 */
    private static $pos1 = [];

    /** @var Position[] $pos2 */
    private static $pos2 = [];

    /** @var Player[] $wandSelectors */
    private static $wandSelectors = [];

    /** @var int[] $drawingPlayers */
    private static $drawingPlayers = [];

    /** @var Player[] $blockInfoPlayers */
    private static $blockInfoPlayers = [];

    /**
     * @param Player $player
     * @param int $brush
     */
    public static function addDrawingPlayer(Player $player, int $brush, int $mode, bool $fall) {
        self::$drawingPlayers[strtolower($player->getName())] = [$brush, $mode, $fall];
    }

    /**
     * @param Player $player
     */
    public static function removeDrawnigPlayer(Player $player) {
        unset(self::$drawingPlayers[strtolower($player->getName())]);
    }

    /**
     * @param Player $player
     * @return int
     */
    public static function getDrawingPlayerBrush(Player $player) {
        return self::$drawingPlayers[strtolower($player->getName())][0];
    }

    /**
     * @param Player $player
     * @return int
     */
    public static function getDrawingPlayerMode(Player $player) {
        return self::$drawingPlayers[strtolower($player->getName())][1];
    }

    /**
     * @param Player $player
     * @return bool
     */
    public static function getDrawingPlayerFall(Player $player) {
        return self::$drawingPlayers[strtolower($player->getName())][2];
    }

    /**
     * @param Player $player
     * @return bool
     */
    public static function isDrawingPlayer(Player $player) {
        return (bool)isset(self::$drawingPlayers[strtolower($player->getName())]);
    }

    /**
     * @param Player $player
     * @param int $pos
     * @param Position $position
     */
    public static function addSelector(Player $player, int $pos, Position $position) {
        if($pos == 1) {
            self::$pos1[strtolower($player->getName())] = $position;
        }
        if($pos == 2) {
            self::$pos2[strtolower($player->getName())] = $position;
        }
    }

    /**
     * @param Player $player
     * @param int $pos
     * @return Position $position
     */
    public static function getPosition(Player $player, int $pos):Position {
        if($pos == 1) {
            return self::$pos1[strtolower($player->getName())];
        }
        if($pos == 2) {
            return self::$pos2[strtolower($player->getName())];
        }
        return null;
    }

    /**
     * @param int $pos
     * @param Player $player
     * @return bool
     */
    public static function isSelected(int $pos, Player $player):bool {
        if($pos == 1) {
            return (bool)isset(self::$pos1[strtolower($player->getName())]);
        }
        if($pos == 2) {
            return (bool)isset(self::$pos2[strtolower($player->getName())]);
        }
        return false;
    }

    /**
     * @param Player $player
     */
    public static function switchWandSelector(Player $player) {
        if(isset(self::$wandSelectors[strtolower($player->getName())])) {
            unset(self::$wandSelectors[strtolower($player->getName())]);
        }
        else {
            self::$wandSelectors[strtolower($player->getName())] = $player;
        }
    }

    /**
     * @param Player $player
     */
    public static function switchBlockInfoSelector(Player $player) {
        if(isset(self::$blockInfoPlayers[strtolower($player->getName())])) {
            unset(self::$blockInfoPlayers[strtolower($player->getName())]);
        }
        else {
            self::$blockInfoPlayers[strtolower($player->getName())] = $player;
        }
    }

    /**
     * @param Player $player
     * @return bool
     */
    public static function isWandSelector(Player $player):bool {
        return (bool)isset(self::$wandSelectors[strtolower($player->getName())]);
    }

    /**
     * @param Player $player
     * @return bool
     */
    public static function isBlockInfoPlayer(Player $player) {
        return (bool)isset(self::$blockInfoPlayers[strtolower($player->getName())]);
    }
}