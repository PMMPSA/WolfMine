<?php
/**
 **
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicHelp;
use aliuly\manyworlds\common\BasicPlugin;
use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\MPMU;
use pocketmine\command\Command;
use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;

class Main extends BasicPlugin implements CommandExecutor{

	public function onEnable(){
		// We don't really need this...
		//if (!is_dir($this->getDataFolder())) mkdir($this->getDataFolder());
		mc::plugin_init($this, $this->getFile());

		$this->modules = [];
		foreach([
			"MwTp",
			"MwLs",
			"MwCreate",
			"MwGenLst",
			"MwLoader",
			"MwLvDat",
			"MwDefault",
		] as $mod){
			$mod = __NAMESPACE__ . "\\" . $mod;
			$this->modules[] = new $mod($this);
		}
		$this->modules[] = new BasicHelp($this);
	}

	public function autoLoad(CommandSender $c, $world){
		if($this->getServer()->isLevelLoaded($world)){
			return true;
		}
		if($c !== null && !MPMU::access($c, "mw.cmd.world.load")){
			return false;
		}
		if(!$this->getServer()->isLevelGenerated($world)){
			if($c !== null){
				$c->sendMessage(mc::_("[MW] No world with the name %1% exists!", $world));
			}

			return false;
		}
		$this->getServer()->loadLevel($world);

		return $this->getServer()->isLevelLoaded($world);
	}

	//////////////////////////////////////////////////////////////////////
	//
	// Command dispatcher
	//
	//////////////////////////////////////////////////////////////////////
	public function onCommand(CommandSender $sender, Command $cmd, string $label, array $args) : bool{
		if($cmd->getName() !== "manyworlds"){
			return false;
		}

		return $this->dispatchSCmd($sender, $cmd, $args);
	}
}
<?php

namespace aliuly\manyworlds\common;
//= api-features
//: - Config shortcuts and multi-module|feature management

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\Config;

/**
 * Simple extension to the PocketMine PluginBase class
 */
abstract class BasicPlugin extends PluginBase{
	protected $modules = [];
	/** @var SubCommandMap|null */
	protected $scmdMap = null;
	/** @var Session|null */
	protected $session;

	/**
	 * Given some defaults, this will load optional features
	 *
	 * @param string $ns - namespace used to search for classes to load
	 * @param array  $mods - optional module definition
	 * @param array  $defaults - default options to use for config.yml
	 * @param string $xhlp - optional help format.
	 *
	 * @return array
	 */
	protected function modConfig($ns, $mods, $defaults, $xhlp = ""){
		if(!isset($defaults["features"])){
			$defaults["features"] = [];
		}
		foreach($mods as $i => $j){
			$defaults["features"][$i] = $j[1];
		}
		$cfg = (new Config($this->getDataFolder() . "config.yml",
						   Config::YAML, $defaults))->getAll();
		$this->modules = [];
		foreach($cfg["features"] as $i => $j){
			if(!isset($mods[$i])){
				$this->getLogger()->info(mc::_("Unknown feature \"%1%\" ignored.", $i));
				continue;
			}
			if(!$j){
				continue;
			}
			$class = $mods[$i][0];
			if(is_array($class)){
				while(count($class) > 1){
					// All classes before the last one are dependencies...
					$classname = $dep = array_shift($class);
					if(strpos($classname, "\\") === false){
						$classname = $ns . "\\" . $classname;
					}
					if(isset($this->modules[$dep])){
						continue;
					} // Dependancy already loaded
					if(isset($cfg[strtolower($dep)])){
						$this->modules[$dep] = new $classname($this, $cfg[strtolower($dep)]);
					}else{
						$this->modules[$dep] = new $classname($this);
					}
				}
				// The last class in the array implements the actual feature
				$class = array_shift($class);
			}
			if(strpos($class, "\\") === false){
				$class = $ns . "\\" . $class;
			}
			if(isset($cfg[$i])){
				$this->modules[$i] = new $class($this, $cfg[$i]);
			}else{
				$this->modules[$i] = new $class($this);
			}
		}
		$c = count($this->modules);
		if($c == 0){
			$this->getLogger()->info(mc::_("NO features enabled"));

			return [];
		}
		$this->session = null;
		$this->getLogger()->info(mc::n(mc::_("Enabled one feature"),
									   mc::_("Enabled %1% features", $c),
									   $c));
		if($this->scmdMap !== null && $this->scmdMap->getCommandCount() > 0){
			$this->modules[] = new BasicHelp($this, $xhlp);
		}

		return $cfg;
	}

	/**
	 * Get module
	 *
	 * @param string $module - module to retrieve
	 *
	 * @return mixed|null
	 */
	public function getModule($module){
		if(isset($this->modules[$module])){
			return $this->modules[$module];
		}

		return null;
	}

	/**
	 * Get Modules array
	 * @return array
	 */
	public function getModules(){
		return $this->modules;
	}

	/**
	 * Save a config section to the plugins' config.yml
	 *
	 * @param string $key - section to save
	 * @param mixed  $settings - settings to save
	 */
	public function cfgSave($key, $settings){
		$cfg = new Config($this->getDataFolder() . "config.yml", Config::YAML);
		$dat = $cfg->getAll();
		$dat[$key] = $settings;
		$cfg->setAll($dat);
		$cfg->save();
	}

	/**
	 * Dispatch commands using sub command table
	 *
	 * @param CommandSender $sender
	 * @param Command       $cmd
	 * @param string[]      $args
	 * @param array|null    $data
	 *
	 * @return bool
	 */
	protected function dispatchSCmd(CommandSender $sender, Command $cmd, array $args, $data = null){
		if($this->scmdMap === null){
			$sender->sendMessage(mc::_("No sub-commands available"));

			return false;
		}

		return $this->scmdMap->dispatchSCmd($sender, $cmd, $args, $data);
	}

	/** Look-up sub command map
	 * @returns SubCommandMap
	 */
	public function getSCmdMap(){
		return $this->scmdMap;
	}

	/**
	 * Register a sub command
	 *
	 * @param string   $cmd - sub command
	 * @param callable $callable - callable to execute
	 * @param array    $opts - additional options
	 */
	public function registerSCmd($cmd, $callable, $opts){
		if($this->scmdMap === null){
			$this->scmdMap = new SubCommandMap();
		}
		$this->scmdMap->registerSCmd($cmd, $callable, $opts);
	}

	/**
	 * Get a player state for the desired module/$label.
	 *
	 * @param string        $label - state variable to get
	 * @param Player|string $player - Player instance or name
	 * @param mixed         $default - default value to return is no state found
	 *
	 * @return mixed
	 */
	public function getState($label, $player, $default){
		if($this->session === null){
			return $default;
		}

		return $this->session->getState($label, $player, $default);
	}

	/**
	 * Set a player related state
	 *
	 * @param string        $label - state variable to set
	 * @param Player|string $player - player instance or their name
	 * @param mixed         $val - value to set
	 *
	 * @return mixed
	 */
	public function setState($label, $player, $val){
		if($this->session === null){
			$this->session = new Session($this);
		}

		return $this->session->setState($label, $player, $val);
	}

	/**
	 * Clears a player related state
	 *
	 * @param string        $label - state variable to clear
	 * @param Player|string $player - intance of Player or their name
	 */
	public function unsetState($label, $player){
		if($this->session === null){
			return;
		}
		$this->session->unsetState($label, $player);
	}

	/**
	 * Gets the contents of an embedded resource on the plugin file.
	 *
	 * @param string $filename
	 *
	 * @return string|null
	 */
	public function getResourceContents($filename){
		$fp = $this->getResource($filename);
		if($fp === null){
			return null;
		}
		$contents = stream_get_contents($fp);
		fclose($fp);

		return $contents;
	}
}
<?php
//= api-features
//: - Translations

namespace aliuly\manyworlds\common;

use pocketmine\plugin\Plugin;

/**
 * Simple translation class in the style of **gettext**.
 *
 * You can actually use **gettext** tools to process these files.
 * For example, to create/update a message catalogue use:
 *
 * `xgettext --no-wrap [-j] [-o file]`
 *
 * Where -j is used to join an existing catalague.
 * -o file is the output file.
 *
 * Basic usage:
 *
 * * mc::load("messages.po|messages.ini");
 * * mc::plugin_init($plugin,$plugin->getFile());
 * * mc::_("string to translate\n")
 * * mc::_("string to translate %1% %2%\n",$arg1,$arg2)
 * * mc::n(mc::\_("singular form"),mc::\_("Plural form"),$count)
 */
abstract class mc{
	/** @var string[] $txt Message translations */
	public static $txt = [];

	/** Main translation function
	 *
	 * This translates strings.  The naming of "_" is to make it compatible
	 * with gettext utilities.  The string can contain "%1%", "%2%, etc...
	 * These are inserted from the following arguments.  Use "%%" to insert
	 * a single "%".
	 *
	 * @param string[] $args - messages
	 *
	 * @return string translated string
	 */
	public static function _(...$args){
		$fmt = array_shift($args);
		if(isset(self::$txt[$fmt])){
			$fmt = self::$txt[$fmt];
		}
		if(count($args)){
			$vars = ["%%" => "%"];
			$i = 1;
			foreach($args as $j){
				$vars["%$i%"] = $j;
				++$i;
			}
			$fmt = strtr($fmt, $vars);
		}

		return $fmt;
	}

	/**
	 * Plural and singular forms.
	 *
	 * @param string $a - Singular form
	 * @param string $b - Plural form
	 * @param int    $c - the number to test to select between $a or $b
	 *
	 * @return string - Either plural or singular forms depending on the value of $c
	 */
	public static function n($a, $b, $c){
		return $c == 1 ? $a : $b;
	}

	/**
	 * Load a message file for a PocketMine plugin.  Only uses .ini files.
	 *
	 * @param Plugin $plugin - owning plugin
	 * @param string $path - output of $plugin->getFile()
	 *
	 * @return int|false - false on error or the number of messages loaded
	 */
	public static function plugin_init($plugin, $path){
		if(file_exists($plugin->getDataFolder() . "messages.ini")){
			return self::load($plugin->getDataFolder() . "messages.ini");
		}
		$msgs = $path . "resources/messages/" .
			$plugin->getServer()->getProperty("settings.language") .
			".ini";
		if(!file_exists($msgs)){
			return false;
		}

		return self::load($msgs);
	}

	/**
	 * Load the specified message catalogue.
	 * Can read .ini or .po files.
	 *
	 * @param string $f - Filename to load
	 *
	 * @return int|false - returns the number of strings loaded or false on error
	 */
	public static function load($f){
		$potxt = "\n" . file_get_contents($f) . "\n";
		if(preg_match('/\nmsgid\s/', $potxt)){
			$potxt = preg_replace('/\\\\n"\n"/', "\\n",
								  preg_replace('/\s+""\s*\n\s*"/', " \"",
											   $potxt));
		}
		foreach(['/\nmsgid "(.+)"\nmsgstr "(.+)"\n/',
					'/^\s*"(.+)"\s*=\s*"(.+)"\s*$/m'] as $re){
			$c = preg_match_all($re, $potxt, $mm);
			if($c){
				for($i = 0; $i < $c; ++$i){
					if($mm[2][$i] == ""){
						continue;
					}
					eval('$a = "' . $mm[1][$i] . '";');
					eval('$b = "' . $mm[2][$i] . '";');
					self::$txt[$a] = $b;
				}

				return $c;
			}
		}

		return false;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * tp : Teleport to another world
 **   usage: /mw **tp** _[player]_ _<world>_
 **
 **   Teleports you to another world.  If _player_ is specified, that
 **   player will be teleported.
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicCli;
use aliuly\manyworlds\common\mc;
use aliuly\manyworlds\common\MPMU;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class MwTp extends BasicCli{
	public function __construct($owner){
		parent::__construct($owner);
		$this->enableSCmd("tp", ["usage" => mc::_("[player] <world>"),
			"help" => mc::_("Teleport across worlds"),
			"permission" => "mw.cmd.tp",
			"aliases" => ["teleport"]]);
	}

	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		if(count($args) === 0){
			return false;
		}
		$player = $c;
		if(count($args) > 1){
			$player = $this->owner->getServer()->getPlayer($args[0]);
			if($player !== null){
				if(!MPMU::access($c, "mw.cmd.tp.others")){
					return true;
				}
				array_shift($args);
			}else{
				// Compatibility with old versions...
				$player = $this->owner->getServer()->getPlayer($args[count($args) - 1]);
				if($player !== null){
					if(!MPMU::access($c, "mw.cmd.tp.others")){
						return true;
					}
					array_pop($args);
				}else{
					$player = $c;
				}
			}
		}
		if(!MPMU::inGame($player)){
			return true;
		}
		$wname = implode(" ", $args);
		if($player->getLevel() === $this->owner->getServer()->getLevelByName($wname)){
			$c->sendMessage($c === $player ? mc::_("You are already in %1%", $wname) : mc::_("%1% is already in %2%", $player->getName(), $wname));

			return true;
		}
		if(!$this->owner->autoLoad($c, $wname)){
			$c->sendMessage(TextFormat::RED . mc::_("Teleport failed"));

			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($wname);
		if($level === null){
			$c->sendMessage(TextFormat::RED . mc::_("Error GetLevelByName %1%"));

			return true;
		}
		if($c !== $player){
			$player->sendMessage(TextFormat::YELLOW . mc::_("Teleporting you to %1% by %2%", $wname, $c->getName()));
		}else{
			$c->sendMessage(TextFormat::GREEN . mc::_("Teleporting to %1%", $wname));
		}
		$player->teleport($level->getSafeSpawn());

		return true;
	}
}
<?php
//= api-features
//: - Paginated output
//: - Command and sub command dispatchers

namespace aliuly\manyworlds\common;

use pocketmine\command\CommandSender;
use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\PluginCommand;
use pocketmine\utils\TextFormat;

/**
 * Implements Basic CLI common functionality.  It is useful for plugins
 * that implement multiple commands or sub-commands
 */
abstract class BasicCli{
	protected $owner;

	/**
	 * @param BasicPlugin $owner - Plugin that owns this module
	 */
	public function __construct($owner){
		$this->owner = $owner;
	}

	/**
	 * Register this class as a sub-command.  See BasicPlugin for details.
	 *
	 * @param string  $cmd - sub-command to register
	 * @param mixed[] $opts - additional options for registering sub-command
	 */
	public function enableSCmd($cmd, $opts){
		$this->owner->registerSCmd($cmd, [$this, "onSCommand"], $opts);
	}

	/**
	 * Register this class as a command.
	 *
	 * @param string  $cmd - command to register
	 * @param mixed[] $yaml - options for command
	 */
	public function enableCmd($cmd, $yaml){
		$newCmd = new PluginCommand($cmd, $this->owner);
		if(isset($yaml["description"])){
			$newCmd->setDescription($yaml["description"]);
		}
		if(isset($yaml["usage"])){
			$newCmd->setUsage($yaml["usage"]);
		}
		if(isset($yaml["aliases"]) and is_array($yaml["aliases"])){
			$aliasList = [];
			foreach($yaml["aliases"] as $alias){
				if(strpos($alias, ":") !== false){
					$this->owner->getLogger()->info("Unable to load alias $alias");
					continue;
				}
				$aliasList[] = $alias;
			}
			$newCmd->setAliases($aliasList);
		}
		if(isset($yaml["permission"])){
			$newCmd->setPermission($yaml["permission"]);
		}
		if(isset($yaml["permission-message"])){
			$newCmd->setPermissionMessage($yaml["permission-message"]);
		}
		$newCmd->setExecutor($this);
		$cmdMap = $this->owner->getServer()->getCommandMap();
		$cmdMap->register($this->owner->getDescription()->getName(), $newCmd);
	}

	/**
	 * Use for paginaged output implementation.
	 * This gets the player specified page number that we want to Display
	 *
	 * @param string[] $args - Passed arguments
	 *
	 * @return int page number
	 */
	protected function getPageNumber(array &$args){
		$pageNumber = 1;
		if(count($args) && is_numeric($args[count($args) - 1])){
			$pageNumber = (int) array_pop($args);
			if($pageNumber <= 0){
				$pageNumber = 1;
			}
		}

		return $pageNumber;
	}

	/**
	 * Use for paginaged output implementation.
	 * Shows a bunch of line in paginated output.
	 *
	 * @param CommandSender $sender - entity that we need to display text to
	 * @param int           $pageNumber - page that we need to display
	 * @param string[]      $txt - Array containing one element per output line
	 *
	 * @return bool true
	 */
	protected function paginateText(CommandSender $sender, $pageNumber, array $txt){
		$hdr = array_shift($txt);
		if($sender instanceof ConsoleCommandSender){
			$sender->sendMessage(TextFormat::GREEN . $hdr . TextFormat::RESET);
			foreach($txt as $ln){
				$sender->sendMessage($ln);
			}

			return true;
		}
		$pageHeight = 5;
		$lineCount = count($txt);
		$pageCount = ((int) ($lineCount / $pageHeight)) + ($lineCount % $pageHeight ? 1 : 0);
		$hdr = TextFormat::GREEN . $hdr . TextFormat::RESET;
		if($pageNumber > $pageCount){
			$sender->sendMessage($hdr);
			$sender->sendMessage("Only $pageCount pages available");

			return true;
		}
		$hdr .= TextFormat::RED . " ($pageNumber of $pageCount)";
		$sender->sendMessage($hdr);
		for($ln = ($pageNumber - 1) * $pageHeight; $ln < $lineCount && $pageHeight--; ++$ln){
			$sender->sendMessage($txt[$ln]);
		}

		return true;
	}

	/**
	 * Use for paginaged output implementation.
	 * Formats and paginates a table
	 *
	 * @param CommandSender $sender - entity that we need to display text to
	 * @param int           $pageNumber - page that we need to display
	 * @param string[][]    $tab - Array containing one element per cell
	 *
	 * @return bool true
	 */
	protected function paginateTable(CommandSender $sender, $pageNumber, array $tab){
		$cols = [];

		foreach($tab[0] as $i => $item){
			$cols[$i] = strlen($item);
		}

		/** @var string[] $row */
		foreach($tab as $row){
			foreach($row as $i => $str){
				if(($l = strlen($str)) > $cols[$i]){
					$cols[$i] = $l;
				}
			}
		}
		$txt = [];
		$fmt = "";
		foreach($cols as $c){
			if(strlen($fmt) > 0){
				$fmt .= " ";
			}
			$fmt .= "%-" . $c . "s";
		}
		foreach($tab as $row){
			$txt[] = sprintf($fmt, ...$row);
		}

		return $this->paginateText($sender, $pageNumber, $txt);
	}

	//////////////////////////////////////////////////////////////////////

	/**
	 * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * Retrieves the state.
	 *
	 * @param CommandSender $player - entity that we need state from
	 * @param mixed         $default - Default value to return if no state found
	 *
	 * @return mixed $state
	 */
	public function getState(CommandSender $player, $default){
		return $this->owner->getState(get_class($this), $player, $default);
	}

	/**
	 * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * Sets the state.
	 *
	 * @param CommandSender $player - entity that we need to set state
	 * @param mixed         $val - Value to use for the state
	 */
	public function setState(CommandSender $player, $val){
		$this->owner->setState(get_class($this), $player, $val);
	}

	/**
	 * Entry point for BasicPlugin state functionality.  This makes it module
	 * specific.
	 * UnSets the state.
	 *
	 * @param CommandSender $player - entity that we need to unset state
	 */
	public function unsetState(CommandSender $player){
		$this->owner->unsetState(get_class($this), $player);
	}
}
<?php

namespace aliuly\manyworlds\common;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;

/**
 * Sub Command dispatcher
 */
class SubCommandMap{

	/** @var callable[] */
	private $executors = [];
	/** @var string[] */
	private $help = [];
	/** @var string[] */
	private $usage = [];
	/** @var string[] */
	private $aliases = [];
	/** @var string[] */
	private $permission = [];

	/**
	 * Returns the number of commands configured
	 */
	public function getCommandCount(){
		return count($this->executors);
	}

	/**
	 * Dispatch commands using sub command table
	 *
	 * @param CommandSender $sender
	 * @param Command       $cmd
	 * @param string[]      $args
	 * @param array|null    $data
	 *
	 * @return bool
	 */
	public function dispatchSCmd(CommandSender $sender, Command $cmd, array $args, $data = null){
		if(count($args) == 0){
			$sender->sendMessage(mc::_("No sub-command specified"));

			return false;
		}
		$scmd = strtolower(array_shift($args));
		if(isset($this->aliases[$scmd])){
			$scmd = $this->aliases[$scmd];
		}
		if(!isset($this->executors[$scmd])){
			$sender->sendMessage(mc::_("Unknown sub-command %2% (try /%1% help)", $cmd->getName(), $scmd));

			return false;
		}
		if(isset($this->permission[$scmd])){
			if(!$sender->hasPermission($this->permission[$scmd])){
				$sender->sendMessage(mc::_("You are not allowed to do this"));

				return true;
			}
		}
		$callback = $this->executors[$scmd];
		if($callback($sender, $cmd, $scmd, $data, $args)){
			return true;
		}
		if(isset($this->executors["help"])){
			$callback = $this->executors["help"];

			return $callback($sender, $cmd, $scmd, $data, ["usage"]);
		}

		return false;
	}

	/**
	 * Register a sub command
	 *
	 * @param string   $cmd - sub command
	 * @param callable $callable - callable to execute
	 * @param array    $opts - additional options
	 */
	public function registerSCmd($cmd, $callable, $opts){
		$cmd = strtolower($cmd);
		$this->executors[$cmd] = $callable;

		if(isset($opts["help"])){
			$this->help[$cmd] = $opts["help"];
			ksort($this->help);
		}
		if(isset($opts["usage"])){
			$this->usage[$cmd] = $opts["usage"];
		}
		if(isset($opts["permission"])){
			$this->permission[$cmd] = $opts["permission"];
		}
		if(isset($opts["aliases"])){
			foreach($opts["aliases"] as $alias){
				$this->aliases[$alias] = $cmd;
			}
		}
	}

	public function getUsage($scmd){
		return $this->usage[$scmd] ?? null;
	}

	public function getAlias($scmd){
		return $this->aliases[$scmd] ?? null;
	}

	public function getHelpMsg($scmd){
		return $this->help[$scmd] ?? null;
	}

	public function getHelp(){
		return $this->help;
	}

	public function getAliases(){
		return $this->aliases;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * ls : Provide world information
 **   usage: /mw **ls** _[world]_
 **
 **   If _world_ is not specified, it will list available worlds.
 **   Otherwise, details for _world_ will be provided.
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicCli;
use aliuly\manyworlds\common\mc;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class MwLs extends BasicCli{
	public function __construct($owner){
		parent::__construct($owner);
		$this->enableSCmd("ls", ["usage" => mc::_("[world]"),
			"help" => mc::_("List world information"),
			"permission" => "mw.cmd.ls",
			"aliases" => ["list", "info"]]);
	}

	private function mwWorldList(CommandSender $sender){
		$dir = $this->owner->getServer()->getDataPath() . "worlds";
		if(!is_dir($dir)){
			$sender->sendMessage(mc::_("[MW] Missing path %1%", $dir));

			return null;
		}
		$txt = ["HDR"];

		$auto = $this->owner->getServer()->getProperty("worlds", []);
		$default = $this->owner->getServer()->getDefaultLevel();
		if($default){
			$default = $default->getName();
		}

		$count = 0;
		$dh = opendir($dir);
		if(!$dh){
			return null;
		}
		while(($file = readdir($dh)) !== false){
			if($file === '.' || $file === '..'){
				continue;
			}
			if(!$this->owner->getServer()->isLevelGenerated($file)){
				continue;
			}
			$attrs = [];
			++$count;
			if(isset($auto[$file])){
				$attrs[] = mc::_("auto");
			}
			if($default == $file){
				$attrs[] = mc::_("default");
			}
			if($this->owner->getServer()->isLevelLoaded($file)){
				$attrs[] = mc::_("loaded");
				$np = count($this->owner->getServer()->getLevelByName($file)->getPlayers());
				if($np){
					$attrs[] = mc::_("players:%1%", $np);
				}
			}
			$ln = "- $file";
			if(count($attrs)){
				$ln .= TextFormat::AQUA . " (" . implode(",", $attrs) . ")";
			}
			$txt[] = $ln;
		}
		closedir($dh);
		$txt[0] = mc::_("Worlds: %1%", $count);

		return $txt;
	}

	private function mwWorldDetails(CommandSender $sender, $world){
		$txt = [];
		if($this->owner->getServer()->isLevelLoaded($world)){
			$unload = false;
		}else{
			if(!$this->owner->autoLoad($sender, $world)){
				$sender->sendMessage(TextFormat::RED . mc::_("Error getting %1%", $world));

				return null;
			}
			$unload = true;
		}
		$level = $this->owner->getServer()->getLevelByName($world);

		//==== provider
		$provider = $level->getProvider();
		$txt[] = mc::_("Info for %1%", $world);
		$txt[] = TextFormat::AQUA . mc::_("Provider: ") . TextFormat::WHITE . $provider::getProviderName();
		$txt[] = TextFormat::AQUA . mc::_("Path: ") . TextFormat::WHITE . $provider->getPath();
		$txt[] = TextFormat::AQUA . mc::_("Name: ") . TextFormat::WHITE . $provider->getName();
		$txt[] = TextFormat::AQUA . mc::_("Seed: ") . TextFormat::WHITE . $provider->getSeed();
		$txt[] = TextFormat::AQUA . mc::_("Generator: ") . TextFormat::WHITE . $provider->getGenerator();
		$gopts = $provider->getGeneratorOptions();
		if($gopts["preset"] != ""){
			$txt[] = TextFormat::AQUA . mc::_("Generator Presets: ") . TextFormat::WHITE .
				$gopts["preset"];
		}
		$spawn = $provider->getSpawn();
		$txt[] = TextFormat::AQUA . mc::_("Spawn: ") . TextFormat::WHITE . $spawn->getX() . "," . $spawn->getY() . "," . $spawn->getZ();
		$plst = $level->getPlayers();
		$lst = "";
		if(count($plst)){
			foreach($plst as $p){
				$lst .= ($lst !== "" ? ", " : "") . $p->getName();
			}
		}
		$txt[] = TextFormat::AQUA . mc::_("Players(%1%):", count($plst)) .
			TextFormat::WHITE . $lst;

		// Check for warnings...
		if($provider->getName() !== $world){
			$txt[] = TextFormat::RED . mc::_("Folder Name and Level.Dat names do NOT match");
			$txt[] = TextFormat::RED . mc::_("This can cause intermitent problems");
			if($sender->hasPermission("mw.cmd.lvdat")){
				$txt[] = TextFormat::RED . mc::_("Use: ");
				$txt[] = TextFormat::GREEN . mc::_("> /mw fixname %1%", $world);
				$txt[] = TextFormat::RED . mc::_("to fix this issue");
			}
		}

		if($unload){
			$this->owner->getServer()->unloadLevel($level);
		}

		return $txt;
	}

	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		$pageNumber = $this->getPageNumber($args);
		if(count($args) === 0){
			$txt = $this->mwWorldList($c);
		}else{
			$wname = implode(" ", $args);
			$txt = $this->mwWorldDetails($c, $wname);
		}
		if($txt == null){
			return true;
		}

		return $this->paginateText($c, $pageNumber, $txt);
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * create : Creates a new world
 **   usage: /mw **create** _<world>_ _[seed]_ _[generator]_ _[preset]_
 **
 **  Creates a world named _world_.  You can optionally specify a _seed_
 **  as number, the generator (_flat_ or _normal_) and a _preset_ string.
 **
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicCli;
use aliuly\manyworlds\common\mc;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\level\generator\GeneratorManager;
use pocketmine\utils\TextFormat;

class MwCreate extends BasicCli{
	public function __construct($owner){
		parent::__construct($owner);
		$this->enableSCmd("create", ["usage" => mc::_("<world> [seed] [generator] [preset]"),
			"help" => mc::_("Creates a new world"),
			"permission" => "mw.cmd.world.create",
			"aliases" => ["new"]]);
	}

	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		if(count($args) < 1 || count($args) > 4){
			return false;
		}
		$world = array_shift($args);
		if($this->owner->getServer()->isLevelGenerated($world)){
			$c->sendMessage(TextFormat::RED . mc::_("[MW] A world named %1% already exists", $world));

			return true;
		}
		$seed = null;
		$generator = null;
		$opts = [];
		if(isset($args[0])){
			$seed = (int) $args[0];
		}
		if(isset($args[1])){
			$generator = GeneratorManager::getGenerator($args[1]);
			if(strtolower($args[1]) != GeneratorManager::getGeneratorName($generator)){
				$c->sendMessage(TextFormat::RED . mc::_("[MW] Unknown generator %1%", $args[1]));

				return true;
			}
			$c->sendMessage(TextFormat::GREEN . mc::_("[MW] Using %1%", GeneratorManager::getGeneratorName($generator)));
		}
		if(isset($args[2])){
			$opts = ["preset" => $args[2]];
		}
		$this->owner->getServer()->broadcastMessage(mc::_("[MW] Creating level %1%... (Expect Lag)", $world));
		$this->owner->getServer()->generateLevel($world, $seed, $generator, $opts);
		$this->owner->getServer()->loadLevel($world);

		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * generators : List available world generators
 **   usage: /mw **generators**
 **
 **   List registered world generators.
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicCli;
use aliuly\manyworlds\common\mc;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\level\generator\GeneratorManager;

class MwGenLst extends BasicCli{
	public function __construct($owner){
		parent::__construct($owner);
		$this->enableSCmd("generators", ["usage" => "",
			"help" => mc::_("List world generators"),
			"permission" => "mw.cmd.world.create",
			"aliases" => ["gen", "genlst"]]);
	}

	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		if(count($args) != 0){
			return false;
		}

		$c->sendMessage(implode(", ", GeneratorManager::getGeneratorList()));
		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * load : Loads a world
 **   usage: /mw **load** _<world>_
 **
 **   Loads _world_ directly.  Use _--all_ to load **all** worlds.
 **
 ** * unload : Unloads world
 **   usage: /mw **unload** _[-f]_  _<world>_
 **
 **   Unloads _world_.  Use _-f_ to force unloads.
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicCli;
use aliuly\manyworlds\common\mc;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class MwLoader extends BasicCli{
	public function __construct($owner){
		parent::__construct($owner);
		$this->enableSCmd("load", ["usage" => mc::_("<world|--all>"),
			"help" => mc::_("Load worlds"),
			"permission" => "mw.cmd.world.load",
			"aliases" => ["ld"]]);
		$this->enableSCmd("unload", ["usage" => mc::_("[-f] <world>"),
			"help" => mc::_("Attempt to unload worlds"),
			"permission" => "mw.cmd.world.load"]);
	}

	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		if(count($args) == 0){
			return false;
		}
		switch($scmd){
			case "load":
				return $this->mwWorldLoadCmd($c, implode(" ", $args));
			case "unload":
				$force = false;
				if($args[0] === "-f"){
					$force = true;
					array_shift($args);
					if(count($args) == 0){
						return false;
					}
				}

				return $this->mwWorldUnloadCmd($c, implode(" ", $args), $force);
		}

		return false;
	}

	private function mwWorldLoadCmd(CommandSender $sender, $wname){
		if($wname === "--all"){
			$wlst = [];
			foreach(glob($this->owner->getServer()->getDataPath() . "worlds/*") as $f){
				$world = basename($f);
				if($this->owner->getServer()->isLevelLoaded($world)){
					continue;
				}
				if(!$this->owner->getServer()->isLevelGenerated($world)){
					continue;
				}
				$wlst[] = $world;
			}
			if(count($wlst) == 0){
				$sender->sendMessage(TextFormat::RED . mc::_("[MW] No levels to load"));

				return true;
			}
			$sender->sendMessage(
				TextFormat::AQUA .
				mc::n(mc::_("[MW] Loading one level"), mc::_("[MW] Loading ALL %1% levels", count($wlst)), count($wlst)));
		}else{
			if($this->owner->getServer()->isLevelLoaded($wname)){
				$sender->sendMessage(TextFormat::RED . mc::_("[MW] %1% already loaded", $wname));

				return true;
			}
			if(!$this->owner->getServer()->isLevelGenerated($wname)){
				$sender->sendMessage(TextFormat::RED . mc::_("[MW] %1% does not exists", $wname));

				return true;
			}
			$wlst = [$wname];
		}
		foreach($wlst as $world){
			if(!$this->owner->autoLoad($sender, $world)){
				$sender->sendMessage(TextFormat::RED . mc::_("[MW] Unable to load %1%", $world));
			}
		}

		return true;
	}

	private function mwWorldUnloadCmd(CommandSender $sender, $wname, $force){
		// Actual implementation
		if(!$this->owner->getServer()->isLevelLoaded($wname)){
			$sender->sendMessage(TextFormat::RED . mc::_("[MW] %1% is not loaded.", $wname));

			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($wname);
		if($level === null){
			$sender->sendMessage(TextFormat::RED . mc::_("[MW] Unable to get %1%", $wname));

			return true;
		}
		if(!$this->owner->getServer()->unloadLevel($level, $force)){
			if($force){
				$sender->sendMessage(TextFormat::RED . mc::_("[MW] Unable to unload %1%", $wname));
			}else{
				$sender->sendMessage(TextFormat::RED . mc::_("[MW] Unable to unload %1%.  Try -f", $wname));
			}
		}else{
			$sender->sendMessage(TextFormat::GREEN . mc::_("[MW] %1% unloaded.", $wname));
		}

		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * lvdat : Show/Modify level.dat variables
 **   usage: /mw **lvdat** _<world>_ _[attr=value]_
 **
 **   Change directly some **level.dat** values/attributes.  Supported
 **   attributes:
 **   - spawn=x,y,z : Sets spawn point
 **   - seed=randomseed : seed used for terrain generation
 **   - name=string : Level name
 **   - generator=flat|normal : Terrain generator
 **   - preset=string : Presets string.
 **
 ** * fixname : fixes name mismatches
 **   usage: /mw **fixname** _<world>_
 **
 **   Fixes a world's **level.dat** file so that the name matches the
 **   folder name.
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicCli;
use aliuly\manyworlds\common\mc;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\level\format\io\BaseLevelProvider;
use pocketmine\math\Vector3;
use pocketmine\utils\TextFormat;

class MwLvDat extends BasicCli{
	public function __construct($owner){
		parent::__construct($owner);
		$this->enableSCmd("lvdat", ["usage" => mc::_("<world> [attr=value]"),
			"help" => mc::_("Change level.dat values"),
			"permission" => "mw.cmd.lvdat",
			"aliases" => ["lv"]]);
		$this->enableSCmd("fixname", ["usage" => mc::_("<world>"),
			"help" => mc::_("Fixes world name"),
			"permission" => "mw.cmd.lvdat",
			"aliases" => ["fix"]]);
	}

	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		if(count($args) === 0){
			return false;
		}
		if($scmd === "fixname"){
			$world = implode(" ", $args);
			$c->sendMessage(TextFormat::AQUA . mc::_("Running /mw lvdat %1% name=%1%", $world));
			$args = [$world, "name=$world"];
		}
		$world = array_shift($args);
		if(!$this->owner->autoLoad($c, $world)){
			$c->sendMessage(TextFormat::RED . mc::_("[MW] %1% is not loaded!", $world));

			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($world);
		if(!$level){
			$c->sendMessage(TextFormat::RED . mc::_("[MW] Unexpected error"));

			return true;
		}
		//==== provider
		$provider = $level->getProvider();
		assert($provider instanceof BaseLevelProvider);
		$changed = false;
		$unload = false;
		foreach($args as $kv){
			$kv = explode("=", $kv, 2);
			if(count($kv) !== 2){
				$c->sendMessage(mc::_("Invalid element: %1%, ignored", $kv[0]));
				continue;
			}
			list($k, $v) = $kv;
			switch(strtolower($k)){
				case "spawn":
					$pos = explode(",", $v);
					if(count($pos) !== 3){
						$c->sendMessage(mc::_("Invalid spawn location: %1%", implode(",", $pos)));
						continue;
					}
					list($x, $y, $z) = $pos;
					$cpos = $provider->getSpawn();
					if(($x = (int) $x) == $cpos->getX() &&
						($y = (int) $y) == $cpos->getY() &&
						($z = (int) $z) == $cpos->getZ()){
						$c->sendMessage(mc::_("Spawn location is unchanged"));
						continue;
					}
					$changed = true;
					$provider->setSpawn(new Vector3($x, $y, $z));
					break;
				case "seed":
					$v = (int) $v;
					if($provider->getSeed() === $v){
						$c->sendMessage(mc::_("Seed unchanged"));
						continue;
					}
					$changed = true;
					$unload = true;
					$provider->setSeed($v);
					break;
				case "name": // LevelName String
					if($provider->getName() === $v){
						$c->sendMessage(mc::_("Name unchanged"));
						continue;
					}
					$changed = true;
					$unload = true;
					$provider->getLevelData()->setString("LevelName", $v);
					break;
				case "generator":
					if($provider->getLevelData()->getString("generatorName") === $v){
						$c->sendMessage(mc::_("Generator unchanged"));
						continue;
					}
					$changed = true;
					$unload = true;
					$provider->getLevelData()->setString("generatorName", $v);
					break;
				case "preset":    // StringTag("generatorOptions");
					if($provider->getLevelData()->getString("generatorOptions", "") === $v){
						$c->sendMessage(mc::_("Preset unchanged"));
						continue;
					}
					$changed = true;
					$unload = true;
					$provider->getLevelData()->setString("generatorOptions", $v);
					break;
				default:
					$c->sendMessage(mc::_("Unknown key %1%, ignored", $k));
					continue;
			}
		}
		if($changed){
			$c->sendMessage(mc::_("Updating level.dat for %1%", $world));
			$provider->saveLevelData();
			if($unload){
				$c->sendMessage(TextFormat::RED .
								mc::_("CHANGES WILL NOT TAKE EFFECT UNTIL UNLOAD"));
			}
		}else{
			$c->sendMessage(mc::_("Nothing happens"));
		}

		return true;
	}
}
<?php
/**
 ** OVERVIEW:Basic Usage
 **
 ** COMMANDS
 **
 ** * default : Sets the default world
 **   usage: /mw **default** _<world>_
 **
 **   Teleports you to another world.  If _player_ is specified, that
 **   player will be teleported.
 **/

namespace aliuly\manyworlds;

use aliuly\manyworlds\common\BasicCli;
use aliuly\manyworlds\common\mc;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class MwDefault extends BasicCli{
	public function __construct($owner){
		parent::__construct($owner);
		$this->enableSCmd("default", ["usage" => mc::_("<world>"),
			"help" => mc::_("Changes default world"),
			"permission" => "mw.cmd.default"]);
	}

	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		if(count($args) === 0){
			return false;
		}
		$wname = implode(" ", $args);
		$old = $this->owner->getServer()->getConfigString("level-name");
		if($old === $wname){
			$c->sendMessage(TextFormat::RED . mc::_("No change"));

			return true;
		}
		if(!$this->owner->autoLoad($c, $wname)){
			$c->sendMessage(TextFormat::RED . mc::_("[MW] Unable to load %1%", $wname));
			$c->sendMessage(TextFormat::RED . mc::_("Change failed!"));

			return true;
		}
		$level = $this->owner->getServer()->getLevelByName($wname);
		if($level === null){
			$c->sendMessage(TextFormat::RED . mc::_("Error GetLevelByName %1%"));

			return true;
		}
		$this->owner->getServer()->setConfigString("level-name", $wname);
		$this->owner->getServer()->setDefaultLevel($level);
		$c->sendMessage(TextFormat::BLUE . mc::_("Default world changed to %1%", $wname));

		return true;
	}
}
<?php

namespace aliuly\manyworlds\common;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\TextFormat;

/**
 * Implements simple help functionality for sub-commands
 */
class BasicHelp extends BasicCli{
	protected $fmt;

	/**
	 * @param PluginBase $owner - plugin that owns this command
	 * @param string     $fmt
	 */
	public function __construct($owner, $fmt = "/%s %s %s"){
		parent::__construct($owner);
		$this->enableSCmd("help", ["aliases" => ["?"]]);
		$this->fmt = $fmt;
	}

	/**
	 * Entry point for sub-commands.  Will show the help or usage messages
	 *
	 * @param CommandSender $c - Entity issuing the command
	 * @param Command       $cc - actual command that was issued
	 * @param string        $scmd - sub-command being executed
	 * @param mixed         $data - Additional data passed to sub-command (global options)
	 * @param string[]      $args - arguments for sub-command
	 *
	 * @return bool
	 */
	public function onSCommand(CommandSender $c, Command $cc, $scmd, $data, array $args){
		$cm = $this->owner->getSCmdMap();
		$pageNumber = $this->getPageNumber($args);

		if(count($args)){
			if($args[0] === "usage"){
				if($cm->getUsage($scmd) === null){
					return false;
				}
				$c->sendMessage(TextFormat::RED . mc::_("Usage: ") .
								sprintf($this->fmt,
										$cc->getName(),
										$scmd, $cm->getUsage($scmd)));

				return true;
			}
			$txt = ["Help for " . $cc->getName()];

			foreach($args as $i){
				if($cm->getAlias($i) !== null){
					$i = $cm->getAlias($i);
				}
				if($cm->getHelpMsg($i) === null && $cm->getUsage($i) === null){
					$txt[] = TextFormat::RED . mc::_("No help for %1%", $i);
					continue;
				}

				$txt[] = TextFormat::YELLOW . mc::_("Help: ") . TextFormat::WHITE .
					"/" . $cc->getName() . " $i";
				if($cm->getHelpMsg($i) !== null){
					$txt[] = TextFormat::YELLOW . mc::_("Description: ") .
						TextFormat::WHITE . $cm->getHelpMsg($i);
				}
				if($cm->getUsage($i) !== null){
					$txt[] = TextFormat::YELLOW . mc::_("Usage: ") .
						TextFormat::WHITE .
						sprintf($this->fmt, $cc->getName(), $i, $cm->getUsage($i));
				}
			}

			return $this->paginateText($c, $pageNumber, $txt);
		}

		$txt = [mc::_("Available sub-commands for %1%", $cc->getName())];
		foreach($cm->getHelp() as $cn => $desc){
			$ln = TextFormat::GREEN . $cn;
			foreach($cm->getAliases() as $i => $j){
				if($j == $cn){
					$ln .= "|$i";
				}
			}
			$ln .= ": " . TextFormat::WHITE . $desc;
			$txt[] = $ln;
		}

		return $this->paginateText($c, $pageNumber, $txt);
	}
}
<?php
//= api-features
//: - API version checking
//: - Misc shorcuts and pre-canned routines

namespace aliuly\manyworlds\common;

use pocketmine\command\CommandExecutor;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\plugin\Plugin;
use pocketmine\Server;

/**
 * My PocketMine Utils class
 */
abstract class MPMU{
	/** @var string[] $items Nice names for items */
	static protected $items = [];
	/** @const string VERSION plugin version string */
	const VERSION = "1.92.0";

	/**
	 * libcommon library version.  If a version is provided it will check
	 * the version using apiCheck.
	 *
	 * @param string $version Version to check
	 *
	 * @return string|bool
	 */
	public static function version($version = ""){
		if($version == ""){
			return self::VERSION;
		}

		return self::apiCheck(self::VERSION, $version);
	}

	/**
	 * Used to check the PocketMine API version
	 *
	 * @param string $version Version to check
	 *
	 * @return string|bool
	 */
	public static function apiVersion($version = ""){
		if($version == ""){
			return \pocketmine\BASE_VERSION;
		}

		return self::apiCheck(\pocketmine\BASE_VERSION, $version);
	}

	/**
	 * Checks API compatibility from $api against $version.  $version is a
	 * string containing the version.  It can contain the following operators:
	 *
	 * >=, <=, <> or !=, =, !|~, <, >
	 *
	 * @param string $api Installed API version
	 * @param string $version API version to compare against
	 *
	 * @return bool
	 */
	public static function apiCheck($api, $version){
		switch(substr($version, 0, 2)){
			case ">=":
				return version_compare($api, trim(substr($version, 2))) >= 0;
			case "<=":
				return version_compare($api, trim(substr($version, 2))) <= 0;
			case "<>":
			case "!=":
				return version_compare($api, trim(substr($version, 2))) != 0;
		}
		switch(substr($version, 0, 1)){
			case "=":
				return version_compare($api, trim(substr($version, 1))) == 0;
			case "!":
			case "~":
				return version_compare($api, trim(substr($version, 1))) != 0;
			case "<":
				return version_compare($api, trim(substr($version, 1))) < 0;
			case ">":
				return version_compare($api, trim(substr($version, 1))) > 0;
		}
		if((int) $api !== (int) $version){
			return 0;
		}

		return version_compare($api, $version) >= 0;
	}

	/**
	 * Returns a localized string for the gamemode
	 *
	 * @param int $mode
	 *
	 * @return string
	 */
	public static function gamemodeStr($mode){
		if(class_exists(__NAMESPACE__ . "\\mc", false)){
			switch($mode){
				case 0:
					return mc::_("Survival");
				case 1:
					return mc::_("Creative");
				case 2:
					return mc::_("Adventure");
				case 3:
					return mc::_("Spectator");
			}

			return mc::_("%1%-mode", $mode);
		}
		switch($mode){
			case 0:
				return "Survival";
			case 1:
				return "Creative";
			case 2:
				return "Adventure";
			case 3:
				return "Spectator";
		}

		return "$mode-mode";
	}

	/**
	 * Check's player or sender's permissions and shows a message if appropriate
	 *
	 * @param CommandSender $sender
	 * @param string        $permission
	 * @param bool          $msg If false, no message is shown
	 *
	 * @return bool
	 */
	public static function access(CommandSender $sender, $permission, $msg = true){
		if($sender->hasPermission($permission)){
			return true;
		}
		if($msg){
			$sender->sendMessage(mc::_("You do not have permission to do that."));
		}

		return false;
	}

	/**
	 * Check's if $sender is a player in game
	 *
	 * @param CommandSender $sender
	 * @param bool          $msg If false, no message is shown
	 *
	 * @return bool
	 */
	public static function inGame(CommandSender $sender, $msg = true){
		if(!($sender instanceof Player)){
			if($msg){
				$sender->sendMessage(mc::_("You can only do this in-game"));
			}

			return false;
		}

		return true;
	}

	/**
	 * Takes a player and creates a string suitable for indexing
	 *
	 * @param Player|string $player - Player to index
	 *
	 * @return string
	 */
	public static function iName($player){
		if($player instanceof CommandSender){
			$player = strtolower($player->getName());
		}

		return $player;
	}

	/**
	 * Lile file_get_contents but for a Plugin resource
	 *
	 * @param Plugin $plugin
	 * @param string $filename
	 *
	 * @return string|null
	 */
	public static function getResourceContents($plugin, $filename){
		$fp = $plugin->getResource($filename);
		if($fp === null){
			return null;
		}
		$contents = stream_get_contents($fp);
		fclose($fp);

		return $contents;
	}

	/**
	 * Call a plugin's function.
	 *
	 * If the $plug parameter is given a string, it will simply look for that
	 * plugin.  If an array is provided, it is assumed to be of the form:
	 *
	 *   [ "plugin", "version" ]
	 *
	 * So then it will check that the plugin exists, and the version number
	 * matches according to the rules from **apiCheck**.
	 *
	 * Also, if plugin contains an **api** property, it will use that as
	 * the class for method calling instead.
	 *
	 * @param Server       $server - pocketmine server instance
	 * @param string|array $plug - plugin to call
	 * @param string       $method - method to call
	 * @param array        $args
	 * @param mixed        $default - If the plugin does not exist or it is not enable, this value is returned
	 *
	 * @return mixed
	 */
	public static function callPlugin($server, $plug, $method, $args, $default = null){
		$v = null;
		if(is_array($plug)){
			list($plug, $v) = $plug;
		}
		if(($plugin = $server->getPluginManager()->getPlugin($plug)) === null
			|| !$plugin->isEnabled()){
			return $default;
		}

		if($v !== null && !self::apiCheck($plugin->getDescription()->getVersion(), $v)){
			return $default;
		}
		if(property_exists($plugin, "api")){
			$fn = [$plugin->api, $method];
		}else{
			$fn = [$plugin, $method];
		}
		if(!is_callable($fn)){
			return $default;
		}

		return $fn(...$args);
	}

	/**
	 * Register a command
	 *
	 * @param Plugin          $plugin - plugin that "owns" the command
	 * @param CommandExecutor $executor - object that will be called onCommand
	 * @param string          $cmd - Command name
	 * @param array           $yaml - Additional settings for this command.
	 *
	 * @deprecated Moved to Cmd class
	 */
	public static function addCommand($plugin, $executor, $cmd, $yaml){
		$newCmd = new \pocketmine\command\PluginCommand($cmd, $plugin);
		if(isset($yaml["description"])){
			$newCmd->setDescription($yaml["description"]);
		}
		if(isset($yaml["usage"])){
			$newCmd->setUsage($yaml["usage"]);
		}
		if(isset($yaml["aliases"]) and is_array($yaml["aliases"])){
			$aliasList = [];
			foreach($yaml["aliases"] as $alias){
				if(strpos($alias, ":") !== false){
					$plugin->getLogger()->info("Unable to load alias $alias");
					continue;
				}
				$aliasList[] = $alias;
			}
			$newCmd->setAliases($aliasList);
		}
		if(isset($yaml["permission"])){
			$newCmd->setPermission($yaml["permission"]);
		}
		if(isset($yaml["permission-message"])){
			$newCmd->setPermissionMessage($yaml["permission-message"]);
		}
		$newCmd->setExecutor($executor);
		$cmdMap = $plugin->getServer()->getCommandMap();
		$cmdMap->register($plugin->getDescription()->getName(), $newCmd);
	}

	/**
	 * Unregisters a command
	 *
	 * @param Server|Plugin $srv - Access path to server instance
	 * @param string        $cmd - Command name to remove
	 *
	 * @return bool
	 *
	 * @deprecated Moved to Cmd class
	 */
	public static function rmCommand($srv, $cmd){
		$cmdMap = $srv->getCommandMap();
		$oldCmd = $cmdMap->getCommand($cmd);
		if($oldCmd === null){
			return false;
		}
		$oldCmd->setLabel($cmd . "_disabled");
		$oldCmd->unregister($cmdMap);

		return true;
	}

	/**
	 * Send a PopUp, but takes care of checking if there are some
	 * plugins that might cause issues.
	 *
	 * Currently only supports SimpleAuth and BasicHUD.
	 *
	 * @param Player $player
	 * @param string $msg
	 */
	public static function sendPopup($player, $msg){
		$pm = $player->getServer()->getPluginManager();
		if(($sa = $pm->getPlugin("SimpleAuth")) !== null){
			// SimpleAuth also has a HUD when not logged in...
			/** @noinspection PhpUndefinedMethodInspection */
			if($sa->isEnabled() && !$sa->isPlayerAuthenticated($player)){
				return;
			}
		}
		if(($hud = $pm->getPlugin("BasicHUD")) !== null){
			// Send pop-ups through BasicHUD
			/** @noinspection PhpUndefinedMethodInspection */
			$hud->sendPopup($player, $msg);

			return;
		}
		$player->sendPopup($msg);
	}

	/**
	 * Check prefixes
	 *
	 * @param string $txt - input text
	 * @param string $tok - keyword to test
	 *
	 * @return string|null
	 */
	public static function startsWith($txt, $tok){
		$ln = strlen($tok);
		if(strtolower(substr($txt, 0, $ln)) != $tok){
			return null;
		}

		return trim(substr($txt, $ln));
	}

	/**
	 * Look-up player
	 *
	 * @param CommandSender $c
	 * @param string        $n
	 *
	 * @return Player|null
	 */
	public static function getPlayer(CommandSender $c, $n){
		$pl = $c->getServer()->getPlayer($n);
		if($pl === null){
			$c->sendMessage(mc::_("%1% not found", $n));
		}

		return $pl;
	}

}
