<?php
declare(strict_types=1);
namespace MyPlot;

use EssentialsPE\Loader;
use MyPlot\events\MyPlotClearEvent;
use MyPlot\events\MyPlotDisposeEvent;
use MyPlot\events\MyPlotGenerationEvent;
use MyPlot\events\MyPlotResetEvent;
use MyPlot\events\MyPlotSettingEvent;
use MyPlot\events\MyPlotTeleportEvent;
use MyPlot\provider\DataProvider;
use MyPlot\provider\EconomyProvider;
use MyPlot\provider\EconomySProvider;
use MyPlot\provider\EssentialsPEProvider;
use MyPlot\provider\JSONDataProvider;
use MyPlot\provider\MySQLProvider;
use MyPlot\provider\PocketMoneyProvider;
use MyPlot\provider\SQLiteDataProvider;
use MyPlot\provider\YAMLDataProvider;
use MyPlot\task\ClearPlotTask;
use onebone\economyapi\EconomyAPI;
use pocketmine\event\level\LevelLoadEvent;
use pocketmine\lang\BaseLang;
use pocketmine\level\biome\Biome;
use pocketmine\level\format\Chunk;
use pocketmine\level\generator\GeneratorManager;
use pocketmine\level\Level;
use pocketmine\level\Position;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\permission\Permission;
use pocketmine\permission\PermissionManager;
use pocketmine\Player;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\Config;
use pocketmine\utils\TextFormat as TF;
use PocketMoney\PocketMoney;
use MyPlot\libs\spoondetector\SpoonDetector;

class MyPlot extends PluginBase
{
	/** @var MyPlot $instance */
	private static $instance;
	/** @var PlotLevelSettings[] $levels */
	private $levels = [];
	/** @var DataProvider $dataProvider */
	private $dataProvider = null;
	/** @var EconomyProvider $economyProvider */
	private $economyProvider = null;
	/** @var BaseLang $baseLang */
	private $baseLang = null;

	/**
	 * @return MyPlot
	 */
	public static function getInstance() : self {
		return self::$instance;
	}

	/**
	 * Returns the Multi-lang management class
	 *
	 * @api
	 *
	 * @return BaseLang
	 */
	public function getLanguage() : BaseLang {
		return $this->baseLang;
	}

	/**
	 * Returns the DataProvider that is being used
	 *
	 * @api
	 *
	 * @return DataProvider
	 */
	public function getProvider() : DataProvider {
		return $this->dataProvider;
	}

	/**
	 * Returns the EconomyProvider that is being used
	 *
	 * @api
	 *
	 * @return EconomyProvider|null
	 */
	public function getEconomyProvider() : ?EconomyProvider {
		return $this->economyProvider;
	}

	/**
	 * Allows setting the economy provider to a custom provider or to null to disable economy mode
	 *
	 * @api
	 *
	 * @param EconomyProvider|null $provider
	 */
	public function setEconomyProvider(?EconomyProvider $provider) : void {
		if($provider === null) {
			$this->getConfig()->set("UseEconomy", false);
			$this->getLogger()->info("Economy mode disabled!");
		}else{
			$this->getLogger()->info("A custom economy provider has been registered. Economy mode now enabled!");
			$this->getConfig()->set("UseEconomy", true);
			$this->economyProvider = $provider;
		}
	}

	/**
	 * Returns a PlotLevelSettings object which contains all the settings of a level
	 *
	 * @api
	 *
	 * @param string $levelName
	 *
	 * @return PlotLevelSettings|null
	 */
	public function getLevelSettings(string $levelName) : ?PlotLevelSettings {
		return $this->levels[$levelName] ?? null;
	}

	/**
	 * Checks if a plot level is loaded
	 *
	 * @api
	 *
	 * @param string $levelName
	 *
	 * @return bool
	 */
	public function isLevelLoaded(string $levelName) : bool {
		return isset($this->levels[$levelName]);
	}

	/**
	 * Generate a new plot level with optional settings
	 *
	 * @api
	 *
	 * @param string $levelName
	 * @param string $generator
	 * @param array $settings
	 *
	 * @return bool
	 */
	public function generateLevel(string $levelName, string $generator = "myplot", array $settings = []) : bool {
		$ev = new MyPlotGenerationEvent($levelName, $generator, $settings);
		$ev->call();
		if($ev->isCancelled() or $this->getServer()->isLevelGenerated($levelName)) {
			return false;
		}
		$generator = GeneratorManager::getGenerator($generator);
		if(empty($settings)) {
			$this->getConfig()->reload();
			$settings = $this->getConfig()->get("DefaultWorld", []);
		}
		$default = array_filter($this->getConfig()->get("DefaultWorld", []), function($key){
			return !in_array($key, ["PlotSize", "GroundHeight", "RoadWidth", "RoadBlock", "WallBlock", "PlotFloorBlock", "PlotFillBlock", "BottomBlock"]);
		}, ARRAY_FILTER_USE_KEY);
		new Config($this->getDataFolder()."worlds".DIRECTORY_SEPARATOR.$levelName.".yml", Config::YAML, $default);
		$settings = ["preset" => json_encode($settings)];
		return $this->getServer()->generateLevel($levelName, null, $generator, $settings);
	}

	/**
	 * Saves provided plot if changed
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		return $this->dataProvider->savePlot($plot);
	}

	/**
	 * Get all the plots a player owns (in a certain level if $levelName is provided)
	 *
	 * @api
	 *
	 * @param string $username
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public function getPlotsOfPlayer(string $username, string $levelName) : array {
		return $this->dataProvider->getPlotsByOwner($username, $levelName);
	}

	/**
	 * Get the next free plot in a level
	 *
	 * @api
	 *
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		return $this->dataProvider->getNextFreePlot($levelName, $limitXZ);
	}

	/**
	 * Finds the plot at a certain position or null if there is no plot at that position
	 *
	 * @api
	 *
	 * @param Position $position
	 *
	 * @return Plot|null
	 */
	public function getPlotByPosition(Position $position) : ?Plot {
		$x = $position->x;
		$z = $position->z;
		$levelName = $position->level->getFolderName();

		$plotLevel = $this->getLevelSettings($levelName);
		if($plotLevel === null)
			return null;
		$plotSize = $plotLevel->plotSize;
		$roadWidth = $plotLevel->roadWidth;
		$totalSize = $plotSize + $roadWidth;
		if($x >= 0) {
			$X = (int) floor($x / $totalSize);
			$difX = $x % $totalSize;
		}else{
			$X = (int) ceil(($x - $plotSize + 1) / $totalSize);
			$difX = abs(($x - $plotSize + 1) % $totalSize);
		}
		if($z >= 0) {
			$Z = (int) floor($z / $totalSize);
			$difZ = $z % $totalSize;
		}else{
			$Z = (int) ceil(($z - $plotSize + 1) / $totalSize);
			$difZ = abs(($z - $plotSize + 1) % $totalSize);
		}
		if(($difX > $plotSize - 1) or ($difZ > $plotSize - 1)) {
			return null;
		}
		return $this->dataProvider->getPlot($levelName, $X, $Z);
	}

	/**
	 * Get the begin position of a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return Position|null
	 */
	public function getPlotPosition(Plot $plot) : ?Position {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null)
			return null;
		$plotSize = $plotLevel->plotSize;
		$roadWidth = $plotLevel->roadWidth;
		$totalSize = $plotSize + $roadWidth;
		$x = $totalSize * $plot->X;
		$z = $totalSize * $plot->Z;
		$level = $this->getServer()->getLevelByName($plot->levelName);
		return new Position($x, $plotLevel->groundHeight, $z, $level);
	}

	/**
	 * Returns the AABB of the plot area
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return AxisAlignedBB|null
	 */
	public function getPlotBB(Plot $plot) : ?AxisAlignedBB {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null)
			return null;
		$plotSize = $plotLevel->plotSize;
		$roadWidth = $plotLevel->roadWidth;
		$totalSize = $plotSize + $roadWidth;
		$directionalX = $totalSize * $plot->X; // x closest to 0
		$directionalZ = $totalSize * $plot->Z; // z closest to 0

		$x = $directionalX + $totalSize - 1; // -1 should put us within plot area
		$z = $directionalZ + $totalSize - 1; // -1 should put us within plot area
		if($x >= 0) {
			$difX = $x % $totalSize;
		}else{
			$difX = abs(($x - $plotSize + 1) % $totalSize);
		}
		if($z >= 0) {
			$difZ = $z % $totalSize;
		}else{
			$difZ = abs(($z - $plotSize + 1) % $totalSize);
		}
		if($difX > $plotSize - 1) {
			$minX = $directionalX;
			$maxX = $directionalX + $totalSize;
		}else{
			$minX = $directionalX - $totalSize;
			$maxX = $directionalX;
		}
		if($difZ > $plotSize - 1) {
			$minZ = $directionalZ;
			$maxZ = $directionalZ + $totalSize;
		}else{
			$minZ = $directionalZ - $totalSize;
			$maxZ = $directionalZ;
		}

		return new AxisAlignedBB($minX, 0, $minZ, $maxX, Level::Y_MAX, $maxZ);
	}

	/**
	 * Teleport a player to a plot
	 *
	 * @api
	 *
	 * @param Player $player
	 * @param Plot $plot
	 * @param bool $center
	 *
	 * @return bool
	 */
	public function teleportPlayerToPlot(Player $player, Plot $plot, bool $center = false) : bool {
		$ev = new MyPlotTeleportEvent($plot, $player, $center);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		if($center)
			return $this->teleportMiddle($player, $plot);
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null)
			return false;
		$pos = $this->getPlotPosition($plot);
		$pos->x += floor($plotLevel->plotSize / 2);
		$pos->y += 1.5;
		$pos->z -= 1;
		return $player->teleport($pos);
	}

	/**
	 * Claims a plot in a players name
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param string $claimer
	 * @param string $plotName
	 *
	 * @return bool
	 */
	public function claimPlot(Plot $plot, string $claimer, string $plotName = "") : bool {
		$newPlot = clone $plot;
		$newPlot->owner = $claimer;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		$plot = $ev->getPlot();
		if(!empty($plotName)) {
			$this->renamePlot($plot, $plotName);
		}
		return $this->savePlot($plot);
	}

	/**
	 * @param Plot $plot
	 * @param string $newName
	 *
	 * @return bool
	 */
	public function renamePlot(Plot $plot, string $newName = "") : bool {
		$newPlot = clone $plot;
		$newPlot->name = $newName;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * Reset all the blocks inside a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 *
	 * @return bool
	 */
	public function clearPlot(Plot $plot, int $maxBlocksPerTick = 256) : bool {
		$ev = new MyPlotClearEvent($plot, $maxBlocksPerTick);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		$plot = $ev->getPlot();
		$maxBlocksPerTick = $ev->getMaxBlocksPerTick();
		if(!$this->isLevelLoaded($plot->levelName)) {
			return false;
		}
		foreach($this->getServer()->getLevelByName($plot->levelName)->getEntities() as $entity) {
			$plotB = $this->getPlotByPosition($entity);
			if($plotB != null) {
				if($plotB === $plot) {
					if(!$entity instanceof Player) {
						$entity->close();
					}
				}
			}
		}
		$this->getScheduler()->scheduleTask(new ClearPlotTask($this, $plot, $maxBlocksPerTick));
		return true;
	}

	/**
	 * Delete the plot data
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function disposePlot(Plot $plot) : bool {
		$ev = new MyPlotDisposeEvent($plot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->dataProvider->deletePlot($plot);
	}

	/**
	 * Clear and dispose a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 *
	 * @return bool
	 */
	public function resetPlot(Plot $plot, int $maxBlocksPerTick = 256) : bool {
		$ev = new MyPlotResetEvent($plot);
		$ev->call();
		if($ev->isCancelled())
			return false;
		if($this->disposePlot($plot)) {
			return $this->clearPlot($plot, $maxBlocksPerTick);
		}
		return false;
	}

	/**
	 * Changes the biome of a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param Biome $biome
	 *
	 * @return bool
	 */
	public function setPlotBiome(Plot $plot, Biome $biome) : bool {
		$newPlot = clone $plot;
		$newPlot->biome = strtoupper($biome->getName());
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		$plot = $ev->getPlot();
		$biome = Biome::getBiome(constant(Biome::class . "::" . $plot->biome) ?? Biome::PLAINS);
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null) {
			return false;
		}
		$level = $this->getServer()->getLevelByName($plot->levelName);
		$pos = $this->getPlotPosition($plot);
		$plotSize = $plotLevel->plotSize;
		$xMax = $pos->x + $plotSize;
		$zMax = $pos->z + $plotSize;
		$chunkIndexes = [];
		for($x = $pos->x; $x < $xMax; $x++) {
			for($z = $pos->z; $z < $zMax; $z++) {
				$index = Level::chunkHash($x >> 4, $z >> 4);
				if(!in_array($index, $chunkIndexes)) {
					$chunkIndexes[] = $index;
				}
				Level::getXZ($index, $plot->X, $plot->Z);
				$chunk = $level->getChunk($plot->X, $plot->Z, true);
				$chunk->setBiomeId($x, $z, $biome->getId());
			}
		}
		foreach($chunkIndexes as $index) {
			Level::getXZ($index, $plot->X, $plot->Z);
			$chunk = $level->getChunk($plot->X, $plot->Z, true);
			foreach($level->getViewersForPosition(new Vector3($plot->X, 0, $plot->Z)) as $player) {
				$player->onChunkChanged($chunk);
			}
		}
		$this->savePlot($plot);
		return true;
	}

	/**
	 * @param Plot $plot
	 * @param bool $pvp
	 *
	 * @return bool
	 */
	public function setPlotPvp(Plot $plot, bool $pvp) : bool {
		$newPlot = clone $plot;
		$newPlot->pvp = $pvp;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function addPlotHelper(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->addHelper($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function removePlotHelper(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->removeHelper($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function addPlotDenied(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->denyPlayer($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function removePlotDenied(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->unDenyPlayer($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * Returns the PlotLevelSettings of all the loaded levels
	 *
	 * @api
	 *
	 * @return PlotLevelSettings[]
	 */
	public function getPlotLevels() : array {
		return $this->levels;
	}

	/**
	 * Returns the Chunks contained in a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return Chunk[]
	 */
	public function getPlotChunks(Plot $plot) : array {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		$level = $this->getServer()->getLevelByName($plot->levelName);
		$pos = $this->getPlotPosition($plot);
		$plotSize = $plotLevel->plotSize;
		$xMax = ($pos->x + $plotSize) >> 4;
		$zMax = ($pos->z + $plotSize) >> 4;
		$chunks = [];
		for($x = $pos->x >> 4; $x < $xMax; $x++) {
			for($z = $pos->z >> 4; $z < $zMax; $z++) {
				$chunks[] = $level->getChunk($x, $z, true);
			}
		}
		return $chunks;
	}

	/**
	 * Get the maximum number of plots a player can claim
	 *
	 * @api
	 *
	 * @param Player $player
	 *
	 * @return int
	 */
	public function getMaxPlotsOfPlayer(Player $player) : int {
		if($player->hasPermission("myplot.claimplots.unlimited"))
			return PHP_INT_MAX;
		/** @var Permission[] $perms */
		$perms = array_merge(PermissionManager::getInstance()->getDefaultPermissions($player->isOp()), $player->getEffectivePermissions());
		$perms = array_filter($perms, function($name) {
			return (substr($name, 0, 18) === "myplot.claimplots.");
		}, ARRAY_FILTER_USE_KEY);
		if(count($perms) === 0)
			return 0;
		krsort($perms, SORT_FLAG_CASE | SORT_NATURAL);
		foreach($perms as $name => $perm) {
			$maxPlots = substr($name, 18);
			if(is_numeric($maxPlots)) {
				return (int) $maxPlots;
			}
		}
		return 0;
	}

	/**
	 * Finds the exact center of the plot at ground level
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return Position|null
	 */
	public function getPlotMid(Plot $plot) : ?Position {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null) {
			return null;
		}
		$plotSize = $plotLevel->plotSize;
		$pos = $this->getPlotPosition($plot);
		$pos = new Position($pos->x + ($plotSize / 2), $pos->y + 1, $pos->z + ($plotSize / 2));
		return $pos;
	}

	/**
	 * Teleports the player to the exact center of the plot at nearest open space to the ground level
	 *
	 * @internal
	 *
	 * @param Plot $plot
	 * @param Player $player
	 *
	 * @return bool
	 */
	private function teleportMiddle(Player $player, Plot $plot) : bool {
		$mid = $this->getPlotMid($plot);
		if($mid === null) {
			return false;
		}
		return $player->teleport($mid);
	}

	/* -------------------------- Non-API part -------------------------- */
	public function onLoad() : void {
		$this->getLogger()->debug(TF::BOLD."Loading...");
		self::$instance = $this;
		$this->getLogger()->debug(TF::BOLD . "Loading Config");
		$this->saveDefaultConfig();
		$this->reloadConfig();
		@mkdir($this->getDataFolder() . "worlds");
		$this->getLogger()->debug(TF::BOLD . "Loading MyPlot Generator");
		GeneratorManager::addGenerator(MyPlotGenerator::class, "myplot", true);
		$this->getLogger()->debug(TF::BOLD . "Loading Languages");
		// Loading Languages
		/** @var string $lang */
		$lang = $this->getConfig()->get("language", BaseLang::FALLBACK_LANGUAGE);
		$this->baseLang = new BaseLang($lang, $this->getFile() . "resources/");
		$this->getLogger()->debug(TF::BOLD . "Loading Data Provider settings");
		// Initialize DataProvider
		/** @var int $cacheSize */
		$cacheSize = $this->getConfig()->get("PlotCacheSize", 256);
		switch(strtolower($this->getConfig()->get("DataProvider", "sqlite3"))) {
			case "mysql":
				if(extension_loaded("mysqli")) {
					$settings = $this->getConfig()->get("MySQLSettings");
					$this->dataProvider = new MySQLProvider($this, $cacheSize, $settings);
				}else {
					$this->getLogger()->info("MySQLi is not installed in your php build! SQLite3 will be used instead.");
					$this->dataProvider = new SQLiteDataProvider($this, $cacheSize);
				}
			break;
			case "yaml":
				$this->dataProvider = new YAMLDataProvider($this, $cacheSize);
			break;
			case "json":
				$this->dataProvider = new JSONDataProvider($this, $cacheSize);
			break;
			case "sqlite3":
			case "sqlite":
			default:
				$this->dataProvider = new SQLiteDataProvider($this, $cacheSize);
			break;
		}
		$this->getLogger()->debug(TF::BOLD . "Loading MyPlot Commands");
		// Register command
		$this->getServer()->getCommandMap()->register("myplot", new Commands($this));
	}

	public function onEnable() : void {
		SpoonDetector::printSpoon($this, "spoon.txt");
		if($this->isDisabled()) {
			return;
		}
		$this->getLogger()->debug(TF::BOLD . "Loading economy settings");
		// Initialize EconomyProvider
		if($this->getConfig()->get("UseEconomy", false) === true) {
			if(($plugin = $this->getServer()->getPluginManager()->getPlugin("EconomyAPI")) !== null) {
				if($plugin instanceof EconomyAPI) {
					$this->economyProvider = new EconomySProvider($plugin);
					$this->getLogger()->debug("Eco set to EconomySProvider");
				}
				$this->getLogger()->debug("Eco not instance of EconomyAPI");
			}
			elseif(($plugin = $this->getServer()->getPluginManager()->getPlugin("EssentialsPE")) !== null) {
				if($plugin instanceof Loader) {
					$this->economyProvider = new EssentialsPEProvider($plugin);
					$this->getLogger()->debug("Eco set to EssentialsPE");
				}
				$this->getLogger()->debug("Eco not instance of EssentialsPE");
			}
			elseif(($plugin = $this->getServer()->getPluginManager()->getPlugin("PocketMoney")) !== null) {
				if($plugin instanceof PocketMoney) {
					$this->economyProvider = new PocketMoneyProvider($plugin);
					$this->getLogger()->debug("Eco set to PocketMoney");
				}
				$this->getLogger()->debug("Eco not instance of PocketMoney");
			}
			if(!isset($this->economyProvider)) {
				$this->getLogger()->info("No supported economy plugin found!");
				$this->getConfig()->set("UseEconomy", false);
				//$this->getConfig()->save();
			}
		}
		$this->getLogger()->debug(TF::BOLD . "Loading Events");
		$eventListener = new EventListener($this);
		$this->getServer()->getPluginManager()->registerEvents($eventListener, $this);
		$this->getLogger()->debug(TF::BOLD . "Registering Loaded Levels");
		foreach($this->getServer()->getLevels() as $level) {
			$eventListener->onLevelLoad(new LevelLoadEvent($level));
		}
		$this->getLogger()->debug(TF::BOLD.TF::GREEN."Enabled!");
	}

	/**
	 * @param string $levelName
	 * @param PlotLevelSettings $settings
	 *
	 * @return bool
	 */
	public function addLevelSettings(string $levelName, PlotLevelSettings $settings) : bool {
		$this->levels[$levelName] = $settings;
		return true;
	}

	/**
	 * @param string $levelName
	 *
	 * @return bool
	 */
	public function unloadLevelSettings(string $levelName) : bool {
		if(isset($this->levels[$levelName])) {
			unset($this->levels[$levelName]);
			$this->getLogger()->debug("Level " . $levelName . " settings unloaded!");
			return true;
		}
		return false;
	}

	public function onDisable() : void {
		if($this->dataProvider !== null)
			$this->dataProvider->close();
	}
}
<?php
declare(strict_types=1);
namespace MyPlot;

use pocketmine\block\Block;
use pocketmine\level\biome\Biome;
use pocketmine\level\ChunkManager;
use pocketmine\level\generator\Generator;
use pocketmine\math\Vector3;
use pocketmine\utils\Random;

class MyPlotGenerator extends Generator {
	/** @var ChunkManager $level */
	protected $level;
	/** @var string[] $settings */
	private $settings;
	/** @var Block */
	public $roadBlock, $wallBlock, $plotFloorBlock, $plotFillBlock, $bottomBlock;
	/** @var int */
	public $roadWidth = 7, $plotSize = 32, $groundHeight = 64;
	const PLOT = 0;
	const ROAD = 1;
	const WALL = 2;

	/**
	 * MyPlotGenerator constructor.
	 *
	 * @param array $settings
	 */
	public function __construct(array $settings = []) {
		if(isset($settings["preset"])) {
			$settings = json_decode($settings["preset"], true);
			if($settings === false or is_null($settings)) {
				$settings = [];
			}
		}else{
			$settings = [];
		}
		$this->roadBlock = PlotLevelSettings::parseBlock($settings, "RoadBlock", Block::get(Block::PLANKS));
		$this->wallBlock = PlotLevelSettings::parseBlock($settings, "WallBlock", Block::get(Block::STONE_SLAB));
		$this->plotFloorBlock = PlotLevelSettings::parseBlock($settings, "PlotFloorBlock", Block::get(Block::GRASS));
		$this->plotFillBlock = PlotLevelSettings::parseBlock($settings, "PlotFillBlock", Block::get(Block::DIRT));
		$this->bottomBlock = PlotLevelSettings::parseBlock($settings, "BottomBlock", Block::get(Block::BEDROCK));
		$this->roadWidth = PlotLevelSettings::parseNumber($settings, "RoadWidth", 7);
		$this->plotSize = PlotLevelSettings::parseNumber($settings, "PlotSize", 32);
		$this->groundHeight = PlotLevelSettings::parseNumber($settings, "GroundHeight", 64);
		$this->settings = [];
		$this->settings["preset"] = json_encode(["RoadBlock" => $this->roadBlock->getId() . (($meta = $this->roadBlock->getDamage()) === 0 ? '' : ':' . $meta), "WallBlock" => $this->wallBlock->getId() . (($meta = $this->wallBlock->getDamage()) === 0 ? '' : ':' . $meta), "PlotFloorBlock" => $this->plotFloorBlock->getId() . (($meta = $this->plotFloorBlock->getDamage()) === 0 ? '' : ':' . $meta), "PlotFillBlock" => $this->plotFillBlock->getId() . (($meta = $this->plotFillBlock->getDamage()) === 0 ? '' : ':' . $meta), "BottomBlock" => $this->bottomBlock->getId() . (($meta = $this->bottomBlock->getDamage()) === 0 ? '' : ':' . $meta), "RoadWidth" => $this->roadWidth, "PlotSize" => $this->plotSize, "GroundHeight" => $this->groundHeight]);
	}

	/**
	 * @return string
	 */
	public function getName() : string {
		return "myplot";
	}

	/**
	 * @return string[]
	 */
	public function getSettings() : array {
		return $this->settings;
	}

	/**
	 * @param ChunkManager $level
	 * @param Random $random
	 */
	public function init(ChunkManager $level, Random $random) : void {
		$this->level = $level;
	}

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 */
	public function generateChunk(int $chunkX, int $chunkZ) : void {
		$shape = $this->getShape($chunkX << 4, $chunkZ << 4);
		$chunk = $this->level->getChunk($chunkX, $chunkZ);
		$bottomBlockId = $this->bottomBlock->getId();
		$bottomBlockMeta = $this->bottomBlock->getDamage();
		$plotFillBlockId = $this->plotFillBlock->getId();
		$plotFillBlockMeta = $this->plotFillBlock->getDamage();
		$plotFloorBlockId = $this->plotFloorBlock->getId();
		$plotFloorBlockMeta = $this->plotFloorBlock->getDamage();
		$roadBlockId = $this->roadBlock->getId();
		$roadBlockMeta = $this->roadBlock->getDamage();
		$wallBlockId = $this->wallBlock->getId();
		$wallBlockMeta = $this->wallBlock->getDamage();
		$groundHeight = $this->groundHeight;
		for($Z = 0; $Z < 16; ++$Z) {
			for($X = 0; $X < 16; ++$X) {
				$chunk->setBiomeId($X, $Z, Biome::PLAINS);
				$chunk->setBlock($X, 0, $Z, $bottomBlockId, $bottomBlockMeta);
				for($y = 1; $y < $groundHeight; ++$y) {
					$chunk->setBlock($X, $y, $Z, $plotFillBlockId, $plotFillBlockMeta);
				}
				$type = $shape[($Z << 4) | $X];
				if($type === self::PLOT) {
					$chunk->setBlock($X, $groundHeight, $Z, $plotFloorBlockId, $plotFloorBlockMeta);
				}elseif($type === self::ROAD) {
					$chunk->setBlock($X, $groundHeight, $Z, $roadBlockId, $roadBlockMeta);
				}else{
					$chunk->setBlock($X, $groundHeight, $Z, $roadBlockId, $roadBlockMeta);
					$chunk->setBlock($X, $groundHeight + 1, $Z, $wallBlockId, $wallBlockMeta);
				}
			}
		}
		$chunk->setX($chunkX);
		$chunk->setZ($chunkZ);
		$chunk->setGenerated();
		$this->level->setChunk($chunkX, $chunkZ, $chunk);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return \SplFixedArray
	 */
	public function getShape(int $x, int $z) {
		$totalSize = $this->plotSize + $this->roadWidth;
		if($x >= 0) {
			$X = $x % $totalSize;
		}else{
			$X = $totalSize - abs($x % $totalSize);
		}
		if($z >= 0) {
			$Z = $z % $totalSize;
		}else{
			$Z = $totalSize - abs($z % $totalSize);
		}
		$startX = $X;
		$shape = new \SplFixedArray(256);
		for($z = 0; $z < 16; $z++, $Z++) {
			if($Z === $totalSize) {
				$Z = 0;
			}
			if($Z < $this->plotSize) {
				$typeZ = self::PLOT;
			}elseif($Z === $this->plotSize or $Z === ($totalSize - 1)) {
				$typeZ = self::WALL;
			}else{
				$typeZ = self::ROAD;
			}
			for($x = 0, $X = $startX; $x < 16; $x++, $X++) {
				if($X === $totalSize) {
					$X = 0;
				}
				if($X < $this->plotSize) {
					$typeX = self::PLOT;
				}elseif($X === $this->plotSize or $X === ($totalSize - 1)) {
					$typeX = self::WALL;
				}else{
					$typeX = self::ROAD;
				}
				if($typeX === $typeZ) {
					$type = $typeX;
				}elseif($typeX === self::PLOT) {
					$type = $typeZ;
				}elseif($typeZ === self::PLOT) {
					$type = $typeX;
				}else{
					$type = self::ROAD;
				}
				$shape[($z << 4) | $x] = $type;
			}
		}
		return $shape;
	}

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 */
	public function populateChunk(int $chunkX, int $chunkZ) : void {
	}

	/**
	 * @return Vector3
	 */
	public function getSpawn() : Vector3 {
		return new Vector3(0, $this->groundHeight + 1, 0);
	}
}; English language pack for MyPlot
; Created by Wiez, Exxarion, and jasonwynn10
; Updated time : 2/17/2019

; Popup when entering a plot
popup=You entered plot {%0}
popup.owner=Owned by {%0}
popup.available=This plot is open. Use /p claim to claim the plot.
popup.denied=You are denied access to this plot

; /p info
command.name=plot
command.alias=p
command.desc=Claim and manage your plots
command.usage=/p [help]
command.unknown=Unknown command. Try /p help for a list of commands

subcommand.usage=Usage: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Whoops! Something went wrong
notinplot=You are not standing inside a plot
notowner=You do not own this plot
plugin.disabled=This plugin is disabled

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Shows the help menu
help.usage=/p help [page: int]
help.header=--- Showing MyPlot help page {%0} of {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Add a helper to your plot
addhelper.usage=/p addhelper <player: string>
addhelper.alreadyone={%0} is already a helper of this plot
addhelper.success={%0} is now a helper of this plot

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Remove a helper from your plot
removehelper.usage=/p removehelper <player: string>
removehelper.notone={%0} is not a helper
removehelper.success={%0} has been removed from plot helpers

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Deny a player from accessing your plot
denyplayer.usage=/p deny <player: string>
denyplayer.helper={%0} is a helper
denyplayer.alreadyone={%0} has already been denied from this plot
denyplayer.notaplayer=That player is not online right now
denyplayer.cannotdeny={%0} cannot be denied
denyplayer.attempteddeny={%0} attempted to deny you from their plot
denyplayer.success1={%0} is now denied access to the plot
denyplayer.success2="You were denied access to plot {%0};{%1} by {%2}"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Undeny a player from accessing your plot
undenyplayer.usage=/p undeny <player: string>
undenyplayer.notone={%0} is allowed already
undenyplayer.success1={%0} has been allowed into the plot
undenyplayer.success2="You were allowed access to plot {%0};{%1} by {%2}"
undenyplayer.failure={%0} is still denied

; The /p claim Subcommand
claim.name=claim
claim.desc=Claim the current plot you are standing on
claim.usage=/p claim [name: string]
claim.yourplot=You have already claimed this plot
claim.alreadyclaimed=This plot is already claimed by {%0}
claim.maxplots=You reached the limit of {%0} plots per player
claim.nomoney=You do not have enough money to claim this plot
claim.success=You have successfully claimed the plot

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleports to the next free plot
auto.usage=/p auto [claim: bool] [name: string]
auto.notplotworld=You are not in a plot world
auto.success="Teleported to free plot ({%0};{%1})"
auto.noplots=Could not find any available plots

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Disposes your plot
dispose.usage=/p dispose
dispose.confirm=Are you sure you want to dispose plot {%0}? If so, use /p dispose confirm
dispose.nomoney=You do not have enough money to dispose this plot
dispose.success=Plot disposed

; The /p reset Subcommand
reset.name=reset
reset.desc=Disposes and clears your plot
reset.usage=/p reset
reset.confirm=Are you sure you want to reset plot {%0}? If so, use /p reset confirm
reset.nomoney=You do not have enough money to reset this plot
reset.success=Plot reset

; The /p clear Subcommand
clear.name=clear
clear.desc=Clears your plot
clear.usage=/p clear
clear.confirm=Are you sure you want to clear plot {%0}? If so, use /p clear confirm
clear.nomoney=You do not have enough money to clear this plot
clear.success=Plot cleared

; The /p biome Subcommand
biome.name=biome
biome.desc=Changes your plot biome
biome.usage=/p biome [biome: string]
biome.success=Plot biome changed to {%0}
biome.invalid=That biome does not exist
biome.possible=Possible biomes are: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; The /p name Subcommand
name.name=name
name.desc=Sets or changes your plot name
name.usage=/p name <name: string>
name.success=Plot successfully renamed

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Travel to your plot
home.usage=/p home [number: int] [world: string]
home.noplots=You do not own any plots in this world
home.notexist=You do not own a plot with id {%0} in this world
home.success=Teleported to plot {%0} in world {%1}
home.error=Could not travel to plot

; The /p homes Subcommand
homes.name=homes
homes.desc=Shows your claimed plots
homes.usage=/p homes [world: string]
homes.noplots=You do not own any plots
homes.header=Plots you own:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Shows information about a plot
info.usage=/p info [player: string] [number: int]
info.about=Info about plot {%0}
info.plotname=Name: {%0}
info.owner=Owner: {%0}
info.helpers=Helpers: {%0}
info.denied=Denied: {%0}
info.biome=Biome: {%0}
info.notfound=That plot could not be found

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Generate a new plot world
generate.usage=/p generate <name: string> [generator name: string] [teleport: bool]
generate.exists=World with name {%0} already exists
generate.gexists=Generator {%0} does not exist
generate.success=Successfully generated plot world {%0}
generate.error=World could not be generated

; The /p give Subcommand
give.name=give
give.desc=Give your plot to someone else
give.usage=/p give [player: string]
give.notonline=That player is not online
give.maxedout=That player has reached the maximum number of plots
give.toself=You cannot give a plot to yourself
give.confirm=Are you sure you want to give plot {%0} to player {%1}? If so, use /p give {%1} confirm
give.success=You have given the plot to {%0}
give.received={%0} gave you their plot, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleport to a plot
warp.usage=/p warp <id: int> [world: string]
warp.wrongid="The plot id should be in the format X;Z"
warp.notinplotworld=You are not in a plot world
warp.unclaimed=You cannot warp to an unclaimed plot
warp.success=You are teleported to plot {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleports the player to exact center of plot at ground level
middle.usage=/p mid
middle.success=Teleporting complete

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Sets the new owner of the plot without charging anything
setowner.usage=/p setowner <player: string>
setowner.maxplots=That player reached their plots limit of {%0}
setowner.success={%0} is now the owner of this plot

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Shows all plots a player has
list.usage=/p list [player: string]
list.found="Plot {%0} at ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.disabled=Pvp is disabled here
pvp.success=Pvp is now {%0} for the plot<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;

class SQLiteDataProvider extends DataProvider
{
	/** @var \SQLite3 $db */
	private $db;
	/** @var \SQLite3Stmt */
	private $sqlGetPlot, $sqlSavePlot, $sqlSavePlotById, $sqlRemovePlot, $sqlRemovePlotById, $sqlGetPlotsByOwner, $sqlGetPlotsByOwnerAndLevel, $sqlGetExistingXZ;

	/**
	 * SQLiteDataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		parent::__construct($plugin, $cacheSize);
		$this->db = new \SQLite3($this->plugin->getDataFolder() . "plots.db");
		$this->db->exec("CREATE TABLE IF NOT EXISTS plots
			(id INTEGER PRIMARY KEY AUTOINCREMENT, level TEXT, X INTEGER, Z INTEGER, name TEXT,
			 owner TEXT, helpers TEXT, denied TEXT, biome TEXT, pvp INTEGER);");
		try{
			$this->db->exec("ALTER TABLE plots ADD pvp INTEGER;");
		}catch(\Exception $e) {
			// nothing :P
		}
		$this->sqlGetPlot = $this->db->prepare("SELECT id, name, owner, helpers, denied, biome, pvp FROM plots WHERE level = :level AND X = :X AND Z = :Z;");
		$this->sqlSavePlot = $this->db->prepare("INSERT OR REPLACE INTO plots (id, level, X, Z, name, owner, helpers, denied, biome, pvp) VALUES
			((SELECT id FROM plots WHERE level = :level AND X = :X AND Z = :Z),
			 :level, :X, :Z, :name, :owner, :helpers, :denied, :biome, :pvp);");
		$this->sqlSavePlotById = $this->db->prepare("UPDATE plots SET name = :name, owner = :owner, helpers = :helpers, denied = :denied, biome = :biome, pvp = :pvp WHERE id = :id;");
		$this->sqlRemovePlot = $this->db->prepare("DELETE FROM plots WHERE level = :level AND X = :X AND Z = :Z;");
		$this->sqlRemovePlotById = $this->db->prepare("DELETE FROM plots WHERE id = :id;");
		$this->sqlGetPlotsByOwner = $this->db->prepare("SELECT * FROM plots WHERE owner = :owner;");
		$this->sqlGetPlotsByOwnerAndLevel = $this->db->prepare("SELECT * FROM plots WHERE owner = :owner AND level = :level;");
		$this->sqlGetExistingXZ = $this->db->prepare("SELECT X, Z FROM plots WHERE (
				level = :level
				AND (
					(abs(X) = :number AND abs(Z) <= :number) OR
					(abs(Z) = :number AND abs(X) <= :number)
				)
			);");
		$this->plugin->getLogger()->debug("SQLite data provider registered");
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$helpers = implode(",", $plot->helpers);
		$denied = implode(",", $plot->denied);
		if($plot->id >= 0) {
			$stmt = $this->sqlSavePlotById;
			$stmt->bindValue(":id", $plot->id, SQLITE3_INTEGER);
		}else{
			$stmt = $this->sqlSavePlot;
			$stmt->bindValue(":level", $plot->levelName, SQLITE3_TEXT);
			$stmt->bindValue(":X", $plot->X, SQLITE3_INTEGER);
			$stmt->bindValue(":Z", $plot->Z, SQLITE3_INTEGER);
		}
		$stmt->bindValue(":name", $plot->name, SQLITE3_TEXT);
		$stmt->bindValue(":owner", $plot->owner, SQLITE3_TEXT);
		$stmt->bindValue(":helpers", $helpers, SQLITE3_TEXT);
		$stmt->bindValue(":denied", $denied, SQLITE3_TEXT);
		$stmt->bindValue(":biome", $plot->biome, SQLITE3_TEXT);
		$stmt->bindValue(":pvp", $plot->pvp, SQLITE3_INTEGER);
		$stmt->reset();
		$result = $stmt->execute();
		if($result === false) {
			return false;
		}
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		if($plot->id >= 0) {
			$stmt = $this->sqlRemovePlotById;
			$stmt->bindValue(":id", $plot->id, SQLITE3_INTEGER);
		}else{
			$stmt = $this->sqlRemovePlot;
			$stmt->bindValue(":level", $plot->levelName, SQLITE3_TEXT);
			$stmt->bindValue(":X", $plot->X, SQLITE3_INTEGER);
			$stmt->bindValue(":Z", $plot->Z, SQLITE3_INTEGER);
		}
		$stmt->reset();
		$result = $stmt->execute();
		if($result === false) {
			return false;
		}
		$plot = new Plot($plot->levelName, $plot->X, $plot->Z);
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) !== null) {
			return $plot;
		}
		$this->sqlGetPlot->bindValue(":level", $levelName, SQLITE3_TEXT);
		$this->sqlGetPlot->bindValue(":X", $X, SQLITE3_INTEGER);
		$this->sqlGetPlot->bindValue(":Z", $Z, SQLITE3_INTEGER);
		$this->sqlGetPlot->reset();
		$result = $this->sqlGetPlot->execute();
		if($val = $result->fetchArray(SQLITE3_ASSOC)) {
			if($val["helpers"] === null or $val["helpers"] === "") {
				$helpers = [];
			}else{
				$helpers = explode(",", (string) $val["helpers"]);
			}
			if($val["denied"] === null or $val["denied"] === "") {
				$denied = [];
			}else{
				$denied = explode(",", (string) $val["denied"]);
			}
			$plot = new Plot($levelName, $X, $Z, (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}else{
			$plot = new Plot($levelName, $X, $Z);
		}
		$this->cachePlot($plot);
		return $plot;
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return array
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		if($levelName === "") {
			$stmt = $this->sqlGetPlotsByOwner;
		}else{
			$stmt = $this->sqlGetPlotsByOwnerAndLevel;
			$stmt->bindValue(":level", $levelName, SQLITE3_TEXT);
		}
		$stmt->bindValue(":owner", $owner, SQLITE3_TEXT);
		$plots = [];
		$stmt->reset();
		$result = $stmt->execute();
		while($val = $result->fetchArray(SQLITE3_ASSOC)) {
			$helpers = explode(",", (string) $val["helpers"]);
			$denied = explode(",", (string) $val["denied"]);
			$plots[] = new Plot((string) $val["level"], (int) $val["X"], (int) $val["Z"], (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}
		// Remove unloaded plots
		$plots = array_filter($plots, function($plot) {
			return $this->plugin->isLevelLoaded($plot->levelName);
		});
		// Sort plots by level
		usort($plots, function($plot1, $plot2) {
			return strcmp($plot1->levelName, $plot2->levelName);
		});
		return $plots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		$this->sqlGetExistingXZ->bindValue(":level", $levelName, SQLITE3_TEXT);
		$i = 0;
		$this->sqlGetExistingXZ->bindParam(":number", $i, SQLITE3_INTEGER);
		for(; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$this->sqlGetExistingXZ->reset();
			$result = $this->sqlGetExistingXZ->execute();
			$plots = [];
			while($val = $result->fetchArray(SQLITE3_NUM)) {
				$plots[$val[0]][$val[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		$this->db->close();
		$this->plugin->getLogger()->debug("SQLite database closed!");
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;

abstract class DataProvider
{
	/** @var Plot[] $cache */
	private $cache = [];
	/** @var int $cacheSize */
	private $cacheSize;
	/** @var MyPlot $plugin */
	protected $plugin;

	/**
	 * DataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		$this->plugin = $plugin;
		$this->cacheSize = $cacheSize;
	}

	/**
	 * @param Plot $plot
	 */
	protected final function cachePlot(Plot $plot) : void {
		if($this->cacheSize > 0) {
			$key = $plot->levelName . ';' . $plot->X . ';' . $plot->Z;
			if(isset($this->cache[$key])) {
				unset($this->cache[$key]);
			}
			elseif($this->cacheSize <= count($this->cache)) {
				array_shift($this->cache);
			}
			$this->cache = array_merge([$key => clone $plot], $this->cache);
			$this->plugin->getLogger()->debug("Plot {$plot->X};{$plot->Z} has been cached");
		}
	}

	/**
	 * @param $levelName
	 * @param $X
	 * @param $Z
	 *
	 * @return Plot|null
	 */
	protected final function getPlotFromCache(string $levelName, int $X, int $Z) : ?Plot {
		if($this->cacheSize > 0) {
			$key = $levelName . ';' . $X . ';' . $Z;
			if(isset($this->cache[$key])) {
				#$this->plugin->getLogger()->debug("Plot {$X};{$Z} was loaded from the cache");
				return $this->cache[$key];
			}
		}
		return null;
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public abstract function savePlot(Plot $plot) : bool;

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public abstract function deletePlot(Plot $plot) : bool;

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public abstract function getPlot(string $levelName, int $X, int $Z) : Plot;

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public abstract function getPlotsByOwner(string $owner, string $levelName = "") : array;

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public abstract function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot;

	public abstract function close() : void;

	/**
	 * @param int $a
	 * @param int $b
	 * @param array[] $plots
	 *
	 * @return array|null
	 */
	protected static function findEmptyPlotSquared(int $a, int $b, array $plots) : ?array {
		if(!isset($plots[$a][$b]))
			return [$a, $b];
		if(!isset($plots[$b][$a]))
			return [$b, $a];
		if($a !== 0) {
			if(!isset($plots[-$a][$b]))
				return [-$a, $b];
			if(!isset($plots[$b][-$a]))
				return [$b, -$a];
		}
		if($b !== 0) {
			if(!isset($plots[-$b][$a]))
				return [-$b, $a];
			if(!isset($plots[$a][-$b]))
				return [$a, -$b];
		}
		if($a | $b === 0) {
			if(!isset($plots[-$a][-$b]))
				return [-$a, -$b];
			if(!isset($plots[-$b][-$a]))
				return [-$b, -$a];
		}
		return null;
	}
}<?php
declare(strict_types=1);
namespace MyPlot;

use MyPlot\subcommand\AddHelperSubCommand;
use MyPlot\subcommand\AutoSubCommand;
use MyPlot\subcommand\BiomeSubCommand;
use MyPlot\subcommand\ClaimSubCommand;
use MyPlot\subcommand\ClearSubCommand;
use MyPlot\subcommand\DenyPlayerSubCommand;
use MyPlot\subcommand\DisposeSubCommand;
use MyPlot\subcommand\GenerateSubCommand;
use MyPlot\subcommand\GiveSubCommand;
use MyPlot\subcommand\HelpSubCommand;
use MyPlot\subcommand\HomesSubCommand;
use MyPlot\subcommand\HomeSubCommand;
use MyPlot\subcommand\InfoSubCommand;
use MyPlot\subcommand\ListSubCommand;
use MyPlot\subcommand\MiddleSubCommand;
use MyPlot\subcommand\NameSubCommand;
use MyPlot\subcommand\PvpSubCommand;
use MyPlot\subcommand\RemoveHelperSubCommand;
use MyPlot\subcommand\ResetSubCommand;
use MyPlot\subcommand\SetOwnerSubCommand;
use MyPlot\subcommand\SubCommand;
use MyPlot\subcommand\UnDenySubCommand;
use MyPlot\subcommand\WarpSubCommand;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginCommand;
use pocketmine\utils\TextFormat;

class Commands extends PluginCommand
{
	/** @var SubCommand[] $subCommands */
	private $subCommands = [];
	/** @var SubCommand[] $aliasSubCommands */
	private $aliasSubCommands = [];

	/**
	 * Commands constructor.
	 *
	 * @param MyPlot $plugin
	 */
	public function __construct(MyPlot $plugin) {
		parent::__construct($plugin->getLanguage()->get("command.name"), $plugin);
		$this->setPermission("myplot.command");
		$this->setAliases([$plugin->getLanguage()->get("command.alias")]);
		$this->setDescription($plugin->getLanguage()->get("command.desc"));
		$this->setUsage($plugin->getLanguage()->get("command.usage"));
		$this->loadSubCommand(new HelpSubCommand($plugin, "help", $this));
		$this->loadSubCommand(new ClaimSubCommand($plugin, "claim"));
		$this->loadSubCommand(new GenerateSubCommand($plugin, "generate"));
		$this->loadSubCommand(new InfoSubCommand($plugin, "info"));
		$this->loadSubCommand(new AddHelperSubCommand($plugin, "addhelper"));
		$this->loadSubCommand(new RemoveHelperSubCommand($plugin, "removehelper"));
		$this->loadSubCommand(new AutoSubCommand($plugin, "auto"));
		$this->loadSubCommand(new ClearSubCommand($plugin, "clear"));
		$this->loadSubCommand(new DisposeSubCommand($plugin, "dispose"));
		$this->loadSubCommand(new ResetSubCommand($plugin, "reset"));
		$this->loadSubCommand(new BiomeSubCommand($plugin, "biome"));
		$this->loadSubCommand(new HomeSubCommand($plugin, "home"));
		$this->loadSubCommand(new HomesSubCommand($plugin, "homes"));
		$this->loadSubCommand(new NameSubCommand($plugin, "name"));
		$this->loadSubCommand(new GiveSubCommand($plugin, "give"));
		$this->loadSubCommand(new WarpSubCommand($plugin, "warp"));
		$this->loadSubCommand(new MiddleSubCommand($plugin, "middle"));
		$this->loadSubCommand(new DenyPlayerSubCommand($plugin, "denyplayer"));
		$this->loadSubCommand(new UnDenySubCommand($plugin, "undenyplayer"));
		$this->loadSubCommand(new SetOwnerSubCommand($plugin, "setowner"));
		$this->loadSubCommand(new ListSubCommand($plugin, "list"));
		$this->loadSubCommand(new PvpSubCommand($plugin, "pvp"));
		$plugin->getLogger()->debug("Commands Registered to MyPlot");
	}

	/**
	 * @return SubCommand[]
	 */
	public function getCommands() : array {
		return $this->subCommands;
	}

	/**
	 * @param SubCommand $command
	 */
	public function loadSubCommand(SubCommand $command) : void {
		$this->subCommands[$command->getName()] = $command;
		if($command->getAlias() != "") {
			$this->aliasSubCommands[$command->getAlias()] = $command;
		}
	}

	/**
	 * @param string $name
	 */
	public function unloadSubCommand(string $name) : void {
		$subcommand = $this->subCommands[$name] ?? $this->aliasSubCommands[$name] ?? null;
		if($subcommand !== null) {
			unset($this->subCommands[$subcommand->getName()]);
			unset($this->aliasSubCommands[$subcommand->getAlias()]);
		}
	}

	/**
	 * @param CommandSender $sender
	 * @param string $alias
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, string $alias, array $args) : bool {
		if($this->getPlugin()->isDisabled()) {
			/** @noinspection PhpUndefinedMethodInspection */
			$sender->sendMessage($this->getPlugin()->getLanguage()->get("plugin.disabled"));
			return true;
		}
		if(!isset($args[0])) {
			$args[0] = "help";
		}
		$subCommand = strtolower(array_shift($args));
		if(isset($this->subCommands[$subCommand])) {
			$command = $this->subCommands[$subCommand];
		}elseif(isset($this->aliasSubCommands[$subCommand])) {
			$command = $this->aliasSubCommands[$subCommand];
		}else{
			/** @noinspection PhpUndefinedMethodInspection */
			$sender->sendMessage(TextFormat::RED . $this->getPlugin()->getLanguage()->get("command.unknown"));
			return true;
		}
		if($command->canUse($sender)) {
			if(!$command->execute($sender, $args)) {
				/** @noinspection PhpUndefinedMethodInspection */
				$usage = $this->getPlugin()->getLanguage()->translateString("subcommand.usage", [$command->getUsage()]);
				$sender->sendMessage($usage);
			}
		}else{
			/** @noinspection PhpUndefinedMethodInspection */
			$sender->sendMessage(TextFormat::RED . $this->getPlugin()->getLanguage()->get("command.unknown"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Commands;
use MyPlot\MyPlot;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class HelpSubCommand extends SubCommand
{
	/** @var Commands $cmds */
	private $cmds;

	/**
	 * HelpSubCommand constructor.
	 *
	 * @param MyPlot $plugin
	 * @param string $name
	 * @param Commands $cmds
	 */
	public function __construct(MyPlot $plugin, string $name, Commands $cmds) {
		parent::__construct($plugin, $name);
		$this->cmds = $cmds;
	}

	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return $sender->hasPermission("myplot.command.help");
	}

	/**
	 * @param CommandSender $sender
	 * @param string[] $args
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			$pageNumber = 1;
		}elseif(is_numeric($args[0])) {
			$pageNumber = (int) array_shift($args);
			if ($pageNumber <= 0) {
				$pageNumber = 1;
			}
		}else{
			return false;
		}

		$commands = [];
		foreach($this->cmds->getCommands() as $command) {
			if ($command->canUse($sender)) {
				$commands[$command->getName()] = $command;
			}
		}
		ksort($commands, SORT_NATURAL | SORT_FLAG_CASE);
		$commands = array_chunk($commands, $sender->getScreenLineHeight());
		/** @var SubCommand[][] $commands */
		$pageNumber = (int) min(count($commands), $pageNumber);

		$sender->sendMessage($this->translateString("help.header", [$pageNumber, count($commands)]));
		foreach($commands[$pageNumber - 1] as $command) {
			$sender->sendMessage(TextFormat::DARK_GREEN . $command->getName() . ": " . TextFormat::WHITE . $command->getDescription());
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\MyPlot;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\plugin\Plugin;

abstract class SubCommand implements PluginIdentifiableCommand
{
	/** @var MyPlot $plugin */
    private $plugin;
	/** @var string $name */
    private $name;

    /**
     * @param MyPlot $plugin
     * @param string $name
     */
	public function __construct(MyPlot $plugin, string $name) {
        $this->plugin = $plugin;
        $this->name = $name;
    }

    /**
     * @return MyPlot
     */
	public final function getPlugin() : Plugin {
        return $this->plugin;
    }

    /**
     * @param string $str
     * @param string[] $params
     *
     * @param string $onlyPrefix
     * @return string
     */
	protected function translateString(string $str, array $params = [], string $onlyPrefix = null) : string {
        return $this->plugin->getLanguage()->translateString($str, $params, $onlyPrefix);
    }

    /**
     * @param CommandSender $sender
     * @return bool
     */
	public abstract function canUse(CommandSender $sender) : bool;

    /**
     * @return string
     */
	public final function getUsage() : string {
        $usage = $this->getPlugin()->getLanguage()->get($this->name . ".usage");
        return ($usage == $this->name . ".usage") ? "" : $usage;
    }

    /**
     * @return string
     */
	public final function getName() : string {
        $name = $this->getPlugin()->getLanguage()->get($this->name . ".name");
        return ($name == $this->name . ".name") ? "" : $name;
    }

    /**
     * @return string
     */
	public final function getDescription() : string {
        $desc = $this->getPlugin()->getLanguage()->get($this->name . ".desc");
        return ($desc == $this->name . ".desc") ? "" : $desc;
    }

    /**
     * @return string
     */
	public final function getAlias() : string {
        $alias = $this->getPlugin()->getLanguage()->get($this->name . ".alias");
        return ($alias == $this->name . ".alias") ? "" : $alias;
    }

	/**
	 * @param CommandSender $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public abstract function execute(CommandSender $sender, array $args) : bool;
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ClaimSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.claim");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$name = "";
		if(isset($args[0])) {
			$name = $args[0];
		}
		$player = $sender->getServer()->getPlayer($sender->getName());
		$plot = $this->getPlugin()->getPlotByPosition($player);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner != "") {
			if($plot->owner === $sender->getName()) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("claim.yourplot"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("claim.alreadyclaimed", [$plot->owner]));
			}
			return true;
		}
		$maxPlots = $this->getPlugin()->getMaxPlotsOfPlayer($player);
		$plotsOfPlayer = 0;
		foreach($this->getPlugin()->getPlotLevels() as $level => $settings) {
			$level = $this->getPlugin()->getServer()->getLevelByName((string)$level);
			if(!$level->isClosed()) {
				$plotsOfPlayer += count($this->getPlugin()->getPlotsOfPlayer($player->getName(), $level->getFolderName()));
			}
		}
		if($plotsOfPlayer >= $maxPlots) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("claim.maxplots", [$maxPlots]));
			return true;
		}
		$plotLevel = $this->getPlugin()->getLevelSettings($plot->levelName);
		$economy = $this->getPlugin()->getEconomyProvider();
		if($economy !== null and !$economy->reduceMoney($player, $plotLevel->claimPrice)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("claim.nomoney"));
			return true;
		}
		if($this->getPlugin()->claimPlot($plot, $sender->getName(), $name)) {
			$sender->sendMessage($this->translateString("claim.success"));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Plot;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class GenerateSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return $sender->hasPermission("myplot.command.generate");
	}

	/**
	 * @param CommandSender $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$levelName = $args[0];
		if($sender->getServer()->isLevelGenerated($levelName)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("generate.exists", [$levelName]));
			return true;
		}
		if($this->getPlugin()->generateLevel($levelName, $args[1] ?? "myplot")) {
			if(isset($args[2]) and $args[2] == true and $sender instanceof Player) {
				$this->getPlugin()->teleportPlayerToPlot($sender, new Plot($levelName, 0, 0));
			}
			$sender->sendMessage($this->translateString("generate.success", [$levelName]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("generate.error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Plot;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class InfoSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.info");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(isset($args[0])) {
			if(isset($args[1]) and is_numeric($args[1])) {
				$key = ((int) $args[1] - 1) < 1 ? 1 : ((int) $args[1] - 1);
				/** @var Plot[] $plots */
				$plots = [];
				foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
					$plots = array_merge($plots, $this->getPlugin()->getPlotsOfPlayer($args[0], $levelName));
				}
				if(isset($plots[$key])) {
					$plot = $plots[$key];
					$sender->sendMessage($this->translateString("info.about", [TextFormat::GREEN . $plot]));
					$sender->sendMessage($this->translateString("info.owner", [TextFormat::GREEN . $plot->owner]));
					$sender->sendMessage($this->translateString("info.plotname", [TextFormat::GREEN . $plot->name]));
					$helpers = implode(", ", $plot->helpers);
					$sender->sendMessage($this->translateString("info.helpers", [TextFormat::GREEN . $helpers]));
					$denied = implode(", ", $plot->denied);
					$sender->sendMessage($this->translateString("info.denied", [TextFormat::GREEN . $denied]));
					$sender->sendMessage($this->translateString("info.biome", [TextFormat::GREEN . $plot->biome]));
				}else{
					$sender->sendMessage(TextFormat::RED . $this->translateString("info.notfound"));
				}
			}else{
				return false;
			}
		}else{
			$plot = $this->getPlugin()->getPlotByPosition($sender);
			if($plot === null) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
				return true;
			}
			$sender->sendMessage($this->translateString("info.about", [TextFormat::GREEN . $plot]));
			$sender->sendMessage($this->translateString("info.owner", [TextFormat::GREEN . $plot->owner]));
			$sender->sendMessage($this->translateString("info.plotname", [TextFormat::GREEN . $plot->name]));
			$helpers = implode(", ", $plot->helpers);
			$sender->sendMessage($this->translateString("info.helpers", [TextFormat::GREEN . $helpers]));
			$denied = implode(", ", $plot->denied);
			$sender->sendMessage($this->translateString("info.denied", [TextFormat::GREEN . $denied]));
			$sender->sendMessage($this->translateString("info.biome", [TextFormat::GREEN . $plot->biome]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class AddHelperSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.addhelper");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$helper = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.addhelper")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$helper = $this->getPlugin()->getServer()->getPlayer($helper) ?? $this->getPlugin()->getServer()->getOfflinePlayer($helper);
		if($this->getPlugin()->addPlotHelper($plot, $helper->getName())) {
			$sender->sendMessage($this->translateString("addhelper.success", [$helper->getName()]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class RemoveHelperSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.removehelper");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$helper = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.removehelper")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$helper = $this->getPlugin()->getServer()->getPlayer($helper) ?? $this->getPlugin()->getServer()->getOfflinePlayer($helper);
		if($this->getPlugin()->removePlotHelper($plot, $helper->getName())) {
			$sender->sendMessage($this->translateString("removehelper.success", [$helper->getName()]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class AutoSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.auto");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$levelName = $sender->getLevel()->getFolderName();
		if(!$this->getPlugin()->isLevelLoaded($levelName)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("auto.notplotworld"));
			return true;
		}
		if(($plot = $this->getPlugin()->getNextFreePlot($levelName)) !== null) {
			if($this->getPlugin()->teleportPlayerToPlot($sender, $plot, true)) {
				$sender->sendMessage($this->translateString("auto.success", [$plot->X, $plot->Z]));
				$cmd = new ClaimSubCommand($this->getPlugin(), "claim");
				if(isset($args[0]) and strtolower($args[0]) == "true" and $cmd->canUse($sender)) {
					$cmd->execute($sender, [$args[1]]);
				}
			}else {
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("auto.noplots"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ClearSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.clear");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.clear")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(isset($args[0]) and $args[0] == $this->translateString("confirm")) {
			$economy = $this->getPlugin()->getEconomyProvider();
			$price = $this->getPlugin()->getLevelSettings($plot->levelName)->clearPrice;
			if($economy !== null and !$economy->reduceMoney($sender, $price)) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("clear.nomoney"));
				return true;
			}
			/** @var int $maxBlocksPerTick */
			$maxBlocksPerTick = (int) $this->getPlugin()->getConfig()->get("ClearBlocksPerTick", 256);
			if($this->getPlugin()->clearPlot($plot, $maxBlocksPerTick)) {
				$sender->sendMessage($this->translateString("clear.success"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("clear.confirm", [$plotId]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class DisposeSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.dispose");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.dispose")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(isset($args[0]) and $args[0] == $this->translateString("confirm")) {
			$economy = $this->getPlugin()->getEconomyProvider();
			$price = $this->getPlugin()->getLevelSettings($plot->levelName)->disposePrice;
			if($economy !== null and !$economy->reduceMoney($sender, $price)) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("dispose.nomoney"));
				return true;
			}
			if($this->getPlugin()->disposePlot($plot)) {
				$sender->sendMessage($this->translateString("dispose.success"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("dispose.confirm", [$plotId]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ResetSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.reset");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.reset")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(isset($args[0]) and $args[0] == $this->translateString("confirm")) {
			$economy = $this->getPlugin()->getEconomyProvider();
			$price = $this->getPlugin()->getLevelSettings($plot->levelName)->resetPrice;
			if($economy !== null and !$economy->reduceMoney($sender, $price)) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("reset.nomoney"));
				return true;
			}
			/** @var int $maxBlocksPerTick */
			$maxBlocksPerTick = $this->getPlugin()->getConfig()->get("ClearBlocksPerTick", 256);
			if($this->getPlugin()->resetPlot($plot, $maxBlocksPerTick)) {
				$sender->sendMessage($this->translateString("reset.success"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("reset.confirm", [$plotId]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\level\biome\Biome;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class BiomeSubCommand extends SubCommand
{
	/** @var int[] $biomes */
	private $biomes = ["PLAINS" => Biome::PLAINS, "DESERT" => Biome::DESERT, "MOUNTAINS" => Biome::MOUNTAINS, "FOREST" => Biome::FOREST, "TAIGA" => Biome::TAIGA, "SWAMP" => Biome::SWAMP, "NETHER" => Biome::HELL, "HELL" => Biome::HELL, "ICE" => Biome::ICE_PLAINS];

	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.biome");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			$biomes = TextFormat::WHITE . implode(", ", array_keys($this->biomes));
			$sender->sendMessage($this->translateString("biome.possible", [$biomes]));
			return true;
		}
		$player = $sender->getServer()->getPlayer($sender->getName());
		$biome = strtoupper($args[0]);
		$plot = $this->getPlugin()->getPlotByPosition($player);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.biome")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(is_numeric($biome)) {
			$biome = (int) $biome;
			if($biome > 27 or $biome < 0) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.invalid"));
				$biomes = implode(", ", array_keys($this->biomes));
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.possible", [$biomes]));
				return true;
			}
			$biome = Biome::getBiome($biome);
		}else{
			if(constant(Biome::class."::".$biome) === null) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.invalid"));
				$biomes = implode(", ", array_keys($this->biomes));
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.possible", [$biomes]));
				return true;
			}
			$biome = Biome::getBiome(constant(Biome::class."::".$biome));
		}
		if($this->getPlugin()->setPlotBiome($plot, $biome)) {
			$sender->sendMessage($this->translateString("biome.success", [$biome->getName()]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Plot;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class HomeSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.home");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			$plotNumber = 1;
		}elseif(is_numeric($args[0])) {
			$plotNumber = (int) $args[0];
		}else{
			return false;
		}
		$levelName = $args[1] ?? $sender->getLevel()->getFolderName();
		$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
		if(empty($plots)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("home.noplots"));
			return true;
		}
		if(!isset($plots[$plotNumber - 1])) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("home.notexist", [$plotNumber]));
			return true;
		}
		usort($plots, function(Plot $plot1, Plot $plot2) {
			if($plot1->levelName == $plot2->levelName) {
				return 0;
			}
			return ($plot1->levelName < $plot2->levelName) ? -1 : 1;
		});
		$plot = $plots[$plotNumber - 1];
		if($this->getPlugin()->teleportPlayerToPlot($sender, $plot)) {
			$sender->sendMessage($this->translateString("home.success", [$plot, $plot->levelName]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("home.error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class HomesSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.homes");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$levelName = $args[0] ?? $sender->getLevel()->getFolderName();
		$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
		if(empty($plots)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("homes.noplots"));
			return true;
		}
		$sender->sendMessage(TextFormat::DARK_GREEN . $this->translateString("homes.header"));
		for($i = 0; $i < count($plots); $i++) {
			$plot = $plots[$i];
			$message = TextFormat::DARK_GREEN . ($i + 1) . ") ";
			$message .= TextFormat::WHITE . $plot->levelName . " " . $plot;
			if($plot->name !== "") {
				$message .= " = " . $plot->name;
			}
			$sender->sendMessage($message);
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class NameSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.name");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.name")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if($this->getPlugin()->renamePlot($plot, $args[0])) {
			$sender->sendMessage($this->translateString("name.success"));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class GiveSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.give");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$newOwner = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName()) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$newOwner = $this->getPlugin()->getServer()->getPlayer($newOwner);
		if(!$newOwner instanceof Player) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("give.notonline"));
			return true;
		}elseif($newOwner->getName() === $sender->getName()) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("give.toself"));
			return true;
		}
		$maxPlots = $this->getPlugin()->getMaxPlotsOfPlayer($newOwner);
		$plotsOfPlayer = count($this->getPlugin()->getPlotsOfPlayer($newOwner->getName(), $newOwner->getLevel()->getFolderName()));
		if($plotsOfPlayer >= $maxPlots) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("give.maxedout", [$maxPlots]));
			return true;
		}
		if(count($args) == 2 and $args[1] == $this->translateString("confirm")) {
			if($this->getPlugin()->claimPlot($plot, $newOwner->getName())) {
				$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
				$oldOwnerName = TextFormat::GREEN . $sender->getName() . TextFormat::WHITE;
				$newOwnerName = TextFormat::GREEN . $newOwner->getName() . TextFormat::WHITE;
				$sender->sendMessage($this->translateString("give.success", [$newOwnerName]));
				$newOwner->sendMessage($this->translateString("give.received", [$oldOwnerName, $plotId]));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$newOwnerName = TextFormat::GREEN . $newOwner->getName() . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("give.confirm", [$plotId, $newOwnerName]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class WarpSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.warp");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$levelName = $args[1] ?? $sender->getLevel()->getFolderName();
		if(!$this->getPlugin()->isLevelLoaded($levelName)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("warp.notinplotworld"));
			return true;
		}
		/** @var string[] $plotIdArray */
		$plotIdArray = explode(";", $args[0]);
		if(count($plotIdArray) != 2 or !is_numeric($plotIdArray[0]) or !is_numeric($plotIdArray[1])) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("warp.wrongid"));
			return true;
		}
		$plot = $this->getPlugin()->getProvider()->getPlot($levelName, (int) $plotIdArray[0], (int) $plotIdArray[1]);
		if($plot->owner == "" and !$sender->hasPermission("myplot.admin.warp")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("warp.unclaimed"));
			return true;
		}
		if($this->getPlugin()->teleportPlayerToPlot($sender, $plot)) {
			$plot = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("warp.success", [$plot]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("generate.error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class MiddleSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and ($sender->hasPermission("myplot.command.middle"));
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(count($args) != 0) {
			return false;
		}
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.middle")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if($this->getPlugin()->teleportPlayerToPlot($sender, $plot, true)) {
			$sender->sendMessage(TextFormat::GREEN . $this->translateString("middle.success"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class DenyPlayerSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.denyplayer");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$dplayer = strtolower($args[0]);
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.denyplayer")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$dplayer = $this->getPlugin()->getServer()->getPlayer($dplayer) ?? $this->getPlugin()->getServer()->getOfflinePlayer($dplayer);
		if(!$dplayer instanceof Player) {
			$sender->sendMessage($this->translateString("denyplayer.notaplayer"));
			return true;
		}
		if($dplayer->hasPermission("myplot.admin.denyplayer.bypass") or $dplayer->getName() === $plot->owner) {
			$sender->sendMessage($this->translateString("denyplayer.cannotdeny", [$dplayer->getName()]));
			if($dplayer instanceof Player)
				$dplayer->sendMessage($this->translateString("denyplayer.attempteddeny", [$sender->getName()]));
			return true;
		}
		if($this->getPlugin()->addPlotDenied($plot, $dplayer->getName())) {
			$sender->sendMessage($this->translateString("denyplayer.success1", [$dplayer->getName()]));
			if($dplayer instanceof Player) {
				$dplayer->sendMessage($this->translateString("denyplayer.success2", [$plot->X, $plot->Z, $sender->getName()]));
			}
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class UnDenySubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.undenyplayer");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$dplayer = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.undenyplayer")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(!$plot->unDenyPlayer($dplayer)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("undenyplayer.failure", [$dplayer]));
			return true;
		}
		$dplayer = $this->getPlugin()->getServer()->getPlayer($dplayer) ?? $this->getPlugin()->getServer()->getOfflinePlayer($dplayer);
		if($this->getPlugin()->removePlotDenied($plot, $dplayer->getName())) {
			$sender->sendMessage($this->translateString("undenyplayer.success1", [$dplayer->getName()]));
			if($dplayer instanceof Player) {
				$dplayer->sendMessage($this->translateString("undenyplayer.success2", [$plot->X, $plot->Z, $sender->getName()]));
			}
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SetOwnerSubCommand extends SubCommand {
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.admin.setowner");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		$maxPlots = $this->getPlugin()->getMaxPlotsOfPlayer($sender);
		$plotsOfPlayer = 0;
		foreach($this->getPlugin()->getPlotLevels() as $level => $settings) {
			$level = $this->getPlugin()->getServer()->getLevelByName($level);
			if(!$level->isClosed()) {
				$plotsOfPlayer += count($this->getPlugin()->getPlotsOfPlayer($sender->getName(), $level->getFolderName()));
			}
		}
		if($plotsOfPlayer >= $maxPlots) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("setowner.maxplots", [$maxPlots]));
			return true;
		}
		if($this->getPlugin()->claimPlot($plot, $args[0])) {
			$sender->sendMessage($this->translateString("setowner.success", [$plot->owner]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat as TF;

class ListSubCommand extends SubCommand {
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.list");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if($sender->hasPermission("myplot.admin.list")) {
			if(!empty($args)) {
				foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
					$plots = $this->getPlugin()->getPlotsOfPlayer($args[0], $levelName);
					foreach($plots as $plot) {
						$name = $plot->name;
						$x = $plot->X;
						$z = $plot->Z;
						$sender->sendMessage(TF::YELLOW . $this->translateString("list.found", [$name, $x, $z]));
					}
				}
			}else{
				foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
					$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
					foreach($plots as $plot) {
						$name = $plot->name;
						$x = $plot->X;
						$z = $plot->Z;
						$sender->sendMessage(TF::YELLOW . $this->translateString("list.found", [$name, $x, $z]));
					}
					return true;
				}
			}
		}elseif($sender->hasPermission("myplot.command.list")) {
			foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
				$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
				foreach($plots as $plot) {
					$name = $plot->name;
					$x = $plot->X;
					$z = $plot->Z;
					$sender->sendMessage(TF::YELLOW . $this->translateString("list.found", [$name, $x, $z]));
				}
			}
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class PvpSubCommand extends SubCommand {

	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.pvp");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED.$this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.pvp")) {
			$sender->sendMessage(TextFormat::RED.$this->translateString("notowner"));
			return true;
		}
		$levelSettings = $this->getPlugin()->getLevelSettings($sender->level->getFolderName());
		if($levelSettings->restrictPVP) {
			$sender->sendMessage(TextFormat::RED.$this->translateString("pvp.world"));
			return true;
		}
		if($this->getPlugin()->setPlotPvp($plot, !$plot->pvp)) {
			$sender->sendMessage($this->translateString("pvp.success", [$plot->pvp ? "enabled" : "disabled"]));
		}else {
			$sender->sendMessage(TextFormat::RED.$this->translateString("error"));
		}
		return true;
	}
}<?php
namespace MyPlot\libs\spoondetector;

use pocketmine\plugin\PluginBase;
use pocketmine\Server;

/**
 * This class is deliberately meant to be silly
 * Class SpoonDetector
 * @package falkirks\simplewarp\utils
 */
class SpoonDetector{

    private static $subtleAsciiSpoon = "   
         ___ _ __   ___   ___  _ __  
        / __| '_ \\ / _ \\ / _ \\| '_ \\ 
        \\__ \\ |_) | (_) | (_) | | | |
        |___/ .__/ \\___/ \\___/|_| |_|
            | |                      
            |_|                      
    ";

    private static $spoonTxtContent = "
    The author of this plugin does not provide support for third-party builds of 
    PocketMine-MP (spoons). Spoons detract from the overall quality of the MCPE plugin environment, which is already 
    lacking in quality. They force plugin developers to waste time trying to support conflicting APIs.
    
    In order to begin using this plugin you must understand that you will be offered no support. 
    
    Furthermore, the GitHub issue tracker for this project is targeted at vanilla PocketMine only. Any bugs you create which don't affect vanilla PocketMine, will be deleted.
    
    Have you read and understood the above (type 'yes' after the question mark)?";

    private static $thingsThatAreNotSpoons = [
        'PocketMine-MP'
    ];

    public static function isThisSpoon() : bool {
        return !in_array(Server::getInstance()->getName(), self::$thingsThatAreNotSpoons);
    }

    private static function contentValid(string $content): bool {
        return (strpos($content, self::$spoonTxtContent) !== false) && (strrpos($content, "yes") > strrpos($content, "?"));
    }

    public static function printSpoon(PluginBase $pluginBase, $fileToCheck){
        if(self::isThisSpoon()){
            if(!file_exists($pluginBase->getDataFolder() . $fileToCheck)){
                file_put_contents($pluginBase->getDataFolder() . $fileToCheck, self::$spoonTxtContent);
            }
            if(!self::contentValid(file_get_contents($pluginBase->getDataFolder() . $fileToCheck))) {
                $pluginBase->getLogger()->info(self::$subtleAsciiSpoon);
                $pluginBase->getLogger()->warning("You are attempting to run " . $pluginBase->getDescription()->getName() . " on a SPOON!");
                $pluginBase->getLogger()->warning("Before using the plugin you will need to open /plugins/" . $pluginBase->getDescription()->getName() . "/" . $fileToCheck . " in a text editor and agree to the terms.");
                $pluginBase->getServer()->getPluginManager()->disablePlugin($pluginBase);
            }
        }
    }

}
<?php
declare(strict_types=1);
namespace MyPlot\provider;

use onebone\economyapi\EconomyAPI;
use pocketmine\Player;

class EconomySProvider implements EconomyProvider
{
	/** @var EconomyAPI $plugin */
	private $plugin;

	/**
	 * EconomySProvider constructor.
	 *
	 * @param EconomyAPI $plugin
	 */
	public function __construct(EconomyAPI $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool {
		if($amount === 0) {
			return true;
		}elseif($amount < 0) {
			$amount = -$amount;
		}
		$ret = $this->plugin->reduceMoney($player, $amount, true, "MyPlot");
		if($ret === EconomyAPI::RET_SUCCESS) {
			$this->plugin->getLogger()->debug("MyPlot Reduced money of " . $player->getName());
			return true;
		}
		$this->plugin->getLogger()->debug("MyPlot failed to reduce money of ".$player->getName());
		return false;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use pocketmine\Player;

interface EconomyProvider {
	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool;
}<?php
declare(strict_types=1);
namespace MyPlot;

use MyPlot\events\MyPlotBlockEvent;
use MyPlot\events\MyPlotPlayerEnterPlotEvent;
use MyPlot\events\MyPlotPlayerLeavePlotEvent;
use MyPlot\events\MyPlotPvpEvent;
use pocketmine\block\Sapling;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\block\BlockSpreadEvent;
use pocketmine\event\block\SignChangeEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityExplodeEvent;
use pocketmine\event\entity\EntityMotionEvent;
use pocketmine\event\level\LevelLoadEvent;
use pocketmine\event\level\LevelUnloadEvent;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\Player;
use pocketmine\utils\Config;
use pocketmine\utils\TextFormat;

class EventListener implements Listener
{
	/** @var MyPlot $plugin */
	private $plugin;

	/**
	 * EventListener constructor.
	 *
	 * @param MyPlot $plugin
	 */
	public function __construct(MyPlot $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param LevelLoadEvent $event
	 */
	public function onLevelLoad(LevelLoadEvent $event) : void {
		if(file_exists($this->plugin->getDataFolder()."worlds".DIRECTORY_SEPARATOR.$event->getLevel()->getFolderName().".yml")) {
			$this->plugin->getLogger()->debug("MyPlot level " . $event->getLevel()->getFolderName() . " loaded!");
			$settings = $event->getLevel()->getProvider()->getGeneratorOptions();
			if(!isset($settings["preset"]) or empty($settings["preset"])) {
				return;
			}
			$settings = json_decode($settings["preset"], true);
			if($settings === false) {
				return;
			}
			$levelName = $event->getLevel()->getFolderName();
			$default = $this->plugin->getConfig()->get("DefaultWorld", []);
			$config = new Config($this->plugin->getDataFolder()."worlds".DIRECTORY_SEPARATOR.$levelName.".yml", Config::YAML, $default);
			foreach(array_keys($default) as $key) {
				$settings[$key] = $config->get($key);
			}
			$this->plugin->addLevelSettings($levelName, new PlotLevelSettings($levelName, $settings));
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority MONITOR
	 *
	 * @param LevelUnloadEvent $event
	 */
	public function onLevelUnload(LevelUnloadEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getLevel()->getFolderName();
		if($this->plugin->unloadLevelSettings($levelName)) {
			$this->plugin->getLogger()->debug("Level " . $event->getLevel()->getFolderName() . " unloaded!");
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param BlockPlaceEvent $event
	 */
	public function onBlockPlace(BlockPlaceEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param BlockBreakEvent $event
	 */
	public function onBlockBreak(BlockBreakEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param PlayerInteractEvent $event
	 */
	public function onPlayerInteract(PlayerInteractEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param SignChangeEvent $event
	 */
	public function onSignChange(SignChangeEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @param BlockPlaceEvent|BlockBreakEvent|PlayerInteractEvent|SignChangeEvent $event
	 */
	private function onEventOnBlock($event) : void {
		$levelName = $event->getBlock()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName)) {
			return;
		}
		$plot = $this->plugin->getPlotByPosition($event->getBlock());
		if($plot !== null) {
			$ev = new MyPlotBlockEvent($plot, $event->getBlock(), $event->getPlayer(), $event);
			if($event->isCancelled()) {
				$ev->setCancelled($event->setCancelled());
			}
			$ev->call();
			$event->setCancelled($ev->isCancelled());
			$username = $event->getPlayer()->getName();
			if($plot->owner == $username or $plot->isHelper($username) or $plot->isHelper("*") or $event->getPlayer()->hasPermission("myplot.admin.build.plot")) {
				if(!($event instanceof PlayerInteractEvent and $event->getBlock() instanceof Sapling))
					return;
				/*
				 * Prevent growing a tree near the edge of a plot
				 * so the leaves won't go outside the plot
				 */
				$block = $event->getBlock();
				$maxLengthLeaves = (($block->getDamage() & 0x07) == Sapling::SPRUCE) ? 3 : 2;
				$beginPos = $this->plugin->getPlotPosition($plot);
				$endPos = clone $beginPos;
				$beginPos->x += $maxLengthLeaves;
				$beginPos->z += $maxLengthLeaves;
				$plotSize = $this->plugin->getLevelSettings($levelName)->plotSize;
				$endPos->x += $plotSize - $maxLengthLeaves;
				$endPos->z += $plotSize - $maxLengthLeaves;
				if($block->x >= $beginPos->x and $block->z >= $beginPos->z and $block->x < $endPos->x and $block->z < $endPos->z) {
					return;
				}
			}
		}elseif($event->getPlayer()->hasPermission("myplot.admin.build.road"))
			return;
		$event->setCancelled();
		$this->plugin->getLogger()->debug("Block placement cancelled");
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param EntityExplodeEvent $event
	 */
	public function onExplosion(EntityExplodeEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getEntity()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$plot = $this->plugin->getPlotByPosition($event->getPosition());
		if($plot === null) {
			$event->setCancelled();
			return;
		}
		$beginPos = $this->plugin->getPlotPosition($plot);
		$endPos = clone $beginPos;
		$plotSize = $this->plugin->getLevelSettings($levelName)->plotSize;
		$endPos->x += $plotSize;
		$endPos->z += $plotSize;
		$blocks = array_filter($event->getBlockList(), function($block) use ($beginPos, $endPos) {
			if($block->x >= $beginPos->x and $block->z >= $beginPos->z and $block->x < $endPos->x and $block->z < $endPos->z) {
				return true;
			}
			return false;
		});
		$event->setBlockList($blocks);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param EntityMotionEvent $event
	 */
	public function onEntityMotion(EntityMotionEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getEntity()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$settings = $this->plugin->getLevelSettings($levelName);
		if($settings->restrictEntityMovement and !($event->getEntity() instanceof Player)) {
			$event->setCancelled();
			$this->plugin->getLogger()->debug("Cancelled entity motion on " . $levelName);
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param BlockSpreadEvent $event
	 */
	public function onBlockSpread(BlockSpreadEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getBlock()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$settings = $this->plugin->getLevelSettings($levelName);
		if(!$settings->updatePlotLiquids) {
			$event->setCancelled();
			$this->plugin->getLogger()->debug("Cancelled block spread on " . $levelName);
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param PlayerMoveEvent $event
	 */
	public function onPlayerMove(PlayerMoveEvent $event) : void {
		if(!$this->plugin->getConfig()->get("ShowPlotPopup", true))
			return;
		$levelName = $event->getPlayer()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$plot = $this->plugin->getPlotByPosition($event->getTo());
		if($plot !== null and $plot !== $this->plugin->getPlotByPosition($event->getFrom())) {
			$ev = new MyPlotPlayerEnterPlotEvent($plot, $event->getPlayer());
			$ev->setCancelled($event->isCancelled());
			if($plot->isDenied($event->getPlayer()->getName())) {
				$ev->setCancelled();
				return;
			}
			if(strpos((string) $plot, "-0")) {
				return;
			}
			$ev->call();
			$event->setCancelled($ev->isCancelled());
			if($event->isCancelled()) {
				return;
			}
			$popup = $this->plugin->getLanguage()->translateString("popup", [TextFormat::GREEN . $plot]);
			if($plot->owner !== "") {
				$owner = TextFormat::GREEN . $plot->owner;
				$ownerPopup = $this->plugin->getLanguage()->translateString("popup.owner", [$owner]);
				$paddingSize = (int) floor((strlen($popup) - strlen($ownerPopup)) / 2);
				$paddingPopup = str_repeat(" ", max(0, -$paddingSize));
				$paddingOwnerPopup = str_repeat(" ", max(0, $paddingSize));
				$popup = TextFormat::WHITE . $paddingPopup . $popup . "\n" . TextFormat::WHITE . $paddingOwnerPopup . $ownerPopup;
			}else{
				$ownerPopup = $this->plugin->getLanguage()->translateString("popup.available");
				$paddingSize = (int) floor((strlen($popup) - strlen($ownerPopup)) / 2);
				$paddingPopup = str_repeat(" ", max(0, -$paddingSize));
				$paddingOwnerPopup = str_repeat(" ", max(0, $paddingSize));
				$popup = TextFormat::WHITE . $paddingPopup . $popup . "\n" . TextFormat::WHITE . $paddingOwnerPopup . $ownerPopup;
			}
			$event->getPlayer()->sendTip($popup);
		}elseif($plot === null and ($plot = $this->plugin->getPlotByPosition($event->getFrom())) !== null) {
			$ev = new MyPlotPlayerLeavePlotEvent($plot, $event->getPlayer());
			$ev->setCancelled($event->isCancelled());
			$ev->call();
			$event->setCancelled($ev->isCancelled());
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param EntityDamageByEntityEvent $event
	 */
	public function onEntityDamage(EntityDamageByEntityEvent $event) : void {
		if($event->getEntity() instanceof Player and $event->getDamager() instanceof Player) {
			$levelName = $event->getEntity()->getLevel()->getFolderName();
			if(!$this->plugin->isLevelLoaded($levelName)) {
				return;
			}
			$settings = $this->plugin->getLevelSettings($levelName);
			$plot = $this->plugin->getPlotByPosition($event->getEntity());
			if($plot !== null) {
				/** @noinspection PhpParamsInspection */
				$ev = new MyPlotPvpEvent($plot, $event->getDamager(), $event->getEntity(), $event);
				$ev->setCancelled($event->isCancelled());
				/** @noinspection PhpUndefinedMethodInspection */
				if(($settings->restrictPVP or !$plot->pvp) and !$event->getDamager()->hasPermission("myplot.admin.pvp.bypass")) {
					$ev->setCancelled();
					$this->plugin->getLogger()->debug("Cancelled pvp event in plot ".$plot->X.";".$plot->Z." on level '" . $levelName . "'");
				}
				$ev->call();
				$event->setCancelled($ev->isCancelled());
				if($event->isCancelled()) {
					$ev->getAttacker()->sendMessage(TextFormat::RED . $this->plugin->getLanguage()->translateString("pvp.disabled")); // generic message- we dont know if by config or plot
				}
				return;
			}
			/** @noinspection PhpUndefinedMethodInspection */
			if($event->isCancelled() or $event->getDamager()->hasPermission("myplot.admin.pvp.bypass")) {
				return;
			}
			if($settings->restrictPVP) {
				$event->setCancelled();
				/** @noinspection PhpUndefinedMethodInspection */
				$event->getDamager()->sendMessage(TextFormat::RED.$this->plugin->getLanguage()->translateString("pvp.world"));
				$this->plugin->getLogger()->debug("Cancelled pvp event on ".$levelName);
			}
		}
	}
}<?php
declare(strict_types=1);
namespace MyPlot;

use pocketmine\block\Block;

class PlotLevelSettings
{
	/** @var string $name */
	public $name;
	/** @var Block */
	public $roadBlock, $wallBlock, $plotFloorBlock, $plotFillBlock, $bottomBlock;
	/** @var int */
	public $roadWidth = 7, $plotSize = 32, $groundHeight = 64, $claimPrice = 0, $clearPrice = 0, $disposePrice = 0, $resetPrice = 0;
	/** @var bool */
	public $restrictEntityMovement = true, $restrictPVP = false, $updatePlotLiquids = false, $displayDoneNametags = false;

	/**
	 * PlotLevelSettings constructor.
	 *
	 * @param string $name
	 * @param array $settings
	 */
	public function __construct(string $name, array $settings = []) {
		$this->name = $name;
		if(!empty($settings)) {
			$this->roadBlock = self::parseBlock($settings, "RoadBlock", Block::get(Block::PLANKS));
			$this->wallBlock = self::parseBlock($settings, "WallBlock", Block::get(Block::STONE_SLAB));
			$this->plotFloorBlock = self::parseBlock($settings, "PlotFloorBlock", Block::get(Block::GRASS));
			$this->plotFillBlock = self::parseBlock($settings, "PlotFillBlock", Block::get(Block::DIRT));
			$this->bottomBlock = self::parseBlock($settings, "BottomBlock", Block::get(Block::BEDROCK));
			$this->roadWidth = self::parseNumber($settings, "RoadWidth", 7);
			$this->plotSize = self::parseNumber($settings, "PlotSize", 32);
			$this->groundHeight = self::parseNumber($settings, "GroundHeight", 64);
			$this->claimPrice = self::parseNumber($settings, "ClaimPrice", 0);
			$this->clearPrice = self::parseNumber($settings, "ClearPrice", 0);
			$this->disposePrice = self::parseNumber($settings, "DisposePrice", 0);
			$this->resetPrice = self::parseNumber($settings, "ResetPrice", 0);
			$this->restrictEntityMovement = self::parseBool($settings, "RestrictEntityMovement", true);
			$this->restrictPVP = self::parseBool($settings, "RestrictPVP", false);
			$this->updatePlotLiquids = self::parseBool($settings, "UpdatePlotLiquids", false);
		}
	}

	/**
	 * @param array $array
	 * @param string|int $key
	 * @param Block $default
	 *
	 * @return Block
	 */
	public static function parseBlock(array &$array, $key, Block $default) : Block {
		if(isset($array[$key])) {
			$id = $array[$key];
			if(is_numeric($id)) {
				$block = Block::get((int) $id);
			}else{
				$split = explode(":", $id);
				if(count($split) === 2 and is_numeric($split[0]) and is_numeric($split[1])) {
					$block = Block::get((int) $split[0], (int) $split[1]);
				}else{
					$block = $default;
				}
			}
		}else{
			$block = $default;
		}
		return $block;
	}

	/**
	 * @param array $array
	 * @param string|int $key
	 * @param int $default
	 *
	 * @return int
	 */
	public static function parseNumber(array &$array, $key, int $default) : int {
		if(isset($array[$key]) and is_numeric($array[$key])) {
			return (int) $array[$key];
		}else{
			return $default;
		}
	}

	/**
	 * @param array $array
	 * @param string|int $key
	 * @param bool $default
	 *
	 * @return bool
	 */
	public static function parseBool(array &$array, $key, bool $default) : bool {
		if(isset($array[$key]) and is_bool($array[$key])) {
			return (bool) $array[$key];
		}else{
			return $default;
		}
	}
}<?php
declare(strict_types=1);
namespace MyPlot;

class Plot
{

	public $levelName = "", $X = -0, $Z = -0, $name = "", $owner = "", $helpers = [], $denied = [], $biome = "PLAINS", $pvp = true, $id = -1;

	/**
	 * Plot constructor.
	 *
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 * @param string $name
	 * @param string $owner
	 * @param array $helpers
	 * @param array $denied
	 * @param string $biome
	 * @param bool $pvp
	 * @param int $id
	 */
	public function __construct(string $levelName, int $X, int $Z, string $name = "", string $owner = "", array $helpers = [], array $denied = [], string $biome = "PLAINS", $pvp = true, int $id = -1) {
		$this->levelName = $levelName;
		$this->X = $X;
		$this->Z = $Z;
		$this->name = $name;
		$this->owner = $owner;
		$this->helpers = $helpers;
		$this->denied = $denied;
		$this->biome = strtoupper($biome);
		$settings = MyPlot::getInstance()->getLevelSettings($levelName);
		if($settings !== null) {
			$this->pvp = !$settings->restrictPVP;
		}else{
			$this->pvp = $pvp;
		}
		$this->id = $id;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function isHelper(string $username) : bool {
		return in_array($username, $this->helpers);
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function addHelper(string $username) : bool {
		if(!$this->isHelper($username)) {
			$this->unDenyPlayer($username);
			$this->helpers[] = $username;
			return true;
		}
		return false;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function removeHelper(string $username) : bool {
		if(!$this->isHelper($username)) {
			return false;
		}
		$key = array_search($username, $this->helpers);
		if($key === false) {
			return false;
		}
		unset($this->helpers[$key]);
		return true;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function isDenied(string $username) : bool {
		return in_array($username, $this->denied);
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function denyPlayer(string $username) : bool {
		if(!$this->isDenied($username)) {
			$this->removeHelper($username);
			$this->denied[] = $username;
			return true;
		}
		return false;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function unDenyPlayer(string $username) : bool {
		if(!$this->isDenied($username)) {
			return false;
		}
		$key = array_search($username, $this->denied);
		if($key === false) {
			return false;
		}
		unset($this->denied[$key]);
		return true;
	}

	/**
	 * @return string
	 */
	public function __toString() : string {
		return "(" . $this->X . ";" . $this->Z . ")";
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class MyPlotPlayerEnterPlotEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;
	/** @var Player $player */
	private $player;

	/**
	 * MyPlotPlayerEnterPlotEvent constructor.
	 *
	 * @param Plot $plot
	 * @param Player $player
	 */
	public function __construct(Plot $plot, Player $player) {
		$this->player = $player;
		parent::__construct($plot);
	}

	/**
	 * @return Player
	 */
	public function getPlayer() : Player {
		return $this->player;
	}

	/**
	 * @param Player $player
	 */
	public function setPlayer(Player $player) {
		$this->player = $player;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Event;

class MyPlotPlotEvent extends Event {
	/** @var Plot $plot */
	protected $plot;

	public function __construct(Plot $plot) {
		$this->plot = $plot;
	}

	/**
	 * @return Plot
	 */
	public function getPlot() : Plot {
		return $this->plot;
	}

	/**
	 * @param Plot $plot
	 */
	public function setPlot(Plot $plot) : void {
		$this->plot = $plot;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\block\Block;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\block\SignChangeEvent;
use pocketmine\event\Cancellable;
use pocketmine\event\Event;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\Player;

class MyPlotBlockEvent extends MyPlotPlotEvent implements Cancellable {
	/** @var Block $block */
	private $block;
	/** @var Event $event */
	private $event;
	/** @var Player $player */
	private $player;

	public function __construct(Plot $plot, Block $block, Player $player, Event $event) {
		$this->block = $block;
		$this->player = $player;
		$this->event = $event;
		parent::__construct($plot);
	}

	/**
	 * @return Block
	 */
	public function getBlock() : Block {
		return $this->block;
	}

	/**
	 * @return BlockPlaceEvent|BlockBreakEvent|PlayerInteractEvent|SignChangeEvent
	 */
	public function getEvent() : Event {
		return $this->event;
	}

	/**
	 * @return Player
	 */
	public function getPlayer() : Player {
		return $this->player;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class MyPlotPlayerLeavePlotEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;
	/** @var Player $player */
	private $player;

	/**
	 * MyPlotPlayerLeavePlotEvent constructor.
	 *
	 * @param Plot $plot
	 * @param Player $player
	 */
	public function __construct(Plot $plot, Player $player) {
		$this->player = $player;
		parent::__construct($plot);
	}

	/**
	 * @return Player
	 */
	public function getPlayer() : Player {
		return $this->player;
	}

	/**
	 * @param Player $player
	 */
	public function setPlayer(Player $player) {
		$this->player = $player;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\Player;

class MyPlotTeleportEvent extends MyPlotPlayerEnterPlotEvent {
	/** @var bool $center */
	private $center = false;

	public function __construct(Plot $plot, Player $player, bool $center = false) {
		$this->center = $center;
		parent::__construct($plot, $player);
	}

	/**
	 * @return bool
	 */
	public function toCenter() : bool {
		return $this->center;
	}

	/**
	 * @param bool $center
	 */
	public function setToCenter(bool $center) : void {
		$this->center = $center;
	}
}; Chinese(PRC) language pack for MyPlot
; Created by jerryzooyoyo
; Updated time : 2/17/2019

; Popup when entering a plot
popup= {%0}
popup.owner= {%0}
popup.available=!  /p claim 
popup.denied=,!

; /p info
command.name=plot
command.alias=p
command.desc=
command.usage=/p <help|> []
command.unknown= /p help 

subcommand.usage=: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=
notinplot=
notowner=
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=
help.usage=/p help []
help.header=------  (/ p) {%0} / {%1} ------

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=( addh )
addhelper.usage=/p addhelper <>
addhelper.alreadyone={%0} !
addhelper.success={%0} 

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=( delh )
removehelper.usage=/p removehelper <>
removehelper.notone={%0} 
removehelper.success={%0} 

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper={%0} ,!
denyplayer.alreadyone={%0} !
denyplayer.notaplayer=
denyplayer.cannotdeny={%0} !
denyplayer.attempteddeny={%0} !
denyplayer.success1={%0} 
denyplayer.success2= {%2} !: {%0};{%1}

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone={%0} !
undenyplayer.success1={%0} 
undenyplayer.success2= {%2}  {%0};{%1} !
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=
claim.usage=/p claim []
claim.yourplot=
claim.alreadyclaimed=! {%0}
claim.maxplots=! {%0} 
claim.nomoney=,
claim.success=,!

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=,
auto.usage=/p auto ( a )
auto.notplotworld=,
auto.success= ({%0}, {%1})
auto.noplots=~

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=,
dispose.usage=/p dispose
dispose.confirm= {%0} ? , /p dispose confirm
dispose.nomoney=,
dispose.success=

; The /p reset Subcommand
reset.name=reset
reset.desc=
reset.usage=/p reset
reset.confirm= {%0} ? , /p reset confirm
reset.nomoney=,
reset.success=

; The /p clear Subcommand
clear.name=clear
clear.desc=,
clear.usage=/p clear
clear.confirm= {%0} ? , /p clear confirm
clear.nomoney=,
clear.success=

; The /p biome Subcommand
biome.name=biome
biome.desc=
biome.usage=/p biome []
biome.success= {%0}
biome.invalid=!
biome.possible=: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=
biomes.usage=/p biomes
biomes.possible=: {%0}

; The /p name Subcommand
name.name=name
name.desc=
name.usage=/p name <>
name.success= {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=( h )
home.usage=/p home []
home.noplots=
home.notexist= {%0} ! /p homes 
home.success= {%0}
home.error=

; The /p homes Subcommand
homes.name=homes
homes.desc=
homes.usage=/p homes
homes.noplots=
homes.header=:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=( i )
info.usage=/p info
info.about= {%0} 
info.plotname=: {%0}
info.owner=: {%0}
info.helpers=: {%0}
info.denied=
info.biome=: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=
generate.usage=/p g <>
generate.exists= {%0} 
generate.gexists=
generate.success= {%0}
generate.error=

; The /p give Subcommand
give.name=give
give.desc=
give.usage=/p give <>
give.notonline=
give.maxedout=
give.toself=
give.confirm= {%0}  {%1} ? , /p give {%1} confirm
give.success= {%0}
give.received={%0} , {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=
warp.usage=/p warp <>
warp.wrongid= X;Z 
warp.notinplotworld=
warp.unclaimed=
warp.success= {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=
middle.usage=/p mid
middle.success=

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=
setowner.usage=/p setowner <>
setowner.maxplots=!: {%0}
setowner.success={%0} 

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=
list.usage=/p list <>
list.found=" {%0}  ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=
pvp.world=
pvp.plot=
pvp.success=#########################################
# ___  ___       ______  _         _    #
# |  \/  |       | ___ \| |       | |   #
# | .  . | _   _ | |_/ /| |  ___  | |_  #
# | |\/| || | | ||  __/ | | / _ \ | __| #
# | |  | || |_| || |    | || (_) || |_  #
# \_|  |_/ \__, |\_|    |_| \___/  \__| #
#           __/ |                       #
#          |___/                        #
#########################################

# The language that should be used in MyPlot
# Available languages: eng, nld, vie, spa, chs, zho, deu, cze, tur, kor, fre
#
# English language pack by @jasonwynn10
# Dutch language pack by @Wies
# Vietnamese language pack by @daany123
# Spanish language pack by @thelucyclub
# Chinese ( ROC ) pack by @jerryzooyoyo
# Chinese ( PRC ) pack by @jerryzooyoyo
# German language pack by @morpheusTP and @SalmonGER
# Czech language pack by @GamakCZ
# Turkish language pack by @Eren5960
# Korean language pack by @Johnmacrocraft
# French language pack by @ad5001
language: eng

# The data provider where plot data is stored.
# Current providers are: sqlite, mysql, json, and yaml.
DataProvider: sqlite

# contains settings for mysql provider to use when selected
MySQLSettings:
  Host: 127.0.0.1
  Port: 3306
  Username: default
  Password: password
  DatabaseName: MyPlot
  ShutdownOnFailure: false

# Use an economy with MyPlot. This will allow for plot pricing such as claiming, clearing, etc.
# Currently supported economy plugins: Economy$, PocketMoney, EssentialsPE, EconomyPlus
# Be sure not to use more than 1 economy plugin!
UseEconomy: false

# Amount of plots to be cached.
# Increasing this number will improve performance, but also increase memory usage.
PlotCacheSize: 256

# When a player enters a plot, a popup with basic info will be shown
ShowPlotPopup: true

# Amount of blocks to reset per tick.
# Increasing this number will speed up '/p clear' and '/p reset' but also increases lag
ClearBlocksPerTick: 256

# These settings will be used when creating a new world with the default generator.
DefaultWorld:

  # Restrict entities (e.g. tnt) from moving except falling
  # This will prevent things like tnt cannons from ruining other plots
  RestrictEntityMovement: true

  # Restrict battles between players in plot worlds
  # This setting overrides the settings of individual plots on world generation
  RestrictPVP: false

  # Update liquids (e.g. Water) from updating and moving
  # This will allow things like water to lag the server in plot worlds
  UpdatePlotLiquids: false

  # How much it costs to claim a plot (Economy must be set to 'true')
  ClaimPrice: 0
  # How much it costs to clear a plot (Economy must be set to 'true')
  ClearPrice: 0
  # How much it costs to dispose a plot (Economy must be set to 'true')
  DisposePrice: 0
  # How much it costs to reset a plot (Economy must be set to 'true')
  ResetPrice: 0

  # The size of a plot
  PlotSize: 32
  # The height of a plot
  GroundHeight: 64
  # The width of the road
  RoadWidth: 7

  # The block that the road is made of (Default is Oak Planks)
  RoadBlock: '5:0'
  # The block that plot walls are made of (Default is Stone Slabs)
  WallBlock: '44:0'
  # The block used as the plot floor (Default is Grass)
  PlotFloorBlock: '2:0'
  # The block that fills the rest of the plot (Default is Dirt)
  PlotFillBlock: '3:0'
  # The block at the bottom (Default is Bedrock)
  BottomBlock: '7:0'; Czech language pack for MyPlot
; Created by GamakCZ and PikyCZ
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Vstoupil jsi na pozemek na mst {%0}
popup.owner=Tento pozemek vlastni {%0}
popup.available=Tento pozemek je volny! Muzes si ho zabrat pomoci /p claim
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=prikazy PlotMe
command.usage=Pouziti: /plot <help|prikaz> [nastaveni]
command.unknown=Neznamy prikaz. Prikazy najdes v /p help

subcommand.usage=Pouzij: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Neco se pokazilo!
notinplot=Nestojis na pozemku!
notowner=Tento pozemek ti nepatri!
plugin.disabled=

confirm=potvrdit

; The /p help Subcommand
help.name=help
help.desc=Zobrazi pomoc
help.usage=/p help [stranka]
help.header=--- Zobrazuji MyPlot pomocnou stranku {%0} z {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Prida Kamarada(ku) Na tvuj pozemek.
addhelper.usage=/p addhelper <kamarad>
addhelper.alreadyone={%0} tento(tato) kamarad(ka) ti jiz pomaha.
addhelper.success={%0} se stal(a) tvim pomocnikem.

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Odstrani kamarada(ku) z pozemku.
removehelper.usage=/p removehelper <hrac>
removehelper.notone={%0} nebyl(a) tvuj pomocnik na tvem pozemku!
removehelper.success={%0} byl(a) odstranen z tvych pomocniku!

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=odepre pristup hraci na tvem pozemku.
denyplayer.usage=/p deny <hrac>
denyplayer.helper={%0} je pomocnik!
denyplayer.alreadyone={%0} jiz byl odepren pristup.
denyplayer.notaplayer=Tento hrac neni online!
denyplayer.cannotdeny={%0} nelze odeprit prisup!
denyplayer.attempteddeny={%0} pokousel vam odeprit pristup!
denyplayer.success1={%0} Nyni je odepren pristup k pozemku.
denyplayer.success2=Byl ti odepren pristup k pozemku {%0};{%1} od {%2}

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=umozni hraci pristup na pozemek!
undenyplayer.usage=/p undeny <hrac>
undenyplayer.notone={%0} jiz je povolen!
undenyplayer.success1={%0} byl povolen na pozemek!
undenyplayer.success2=Mas pristup na pozemek {%0};{%1} od {%2}
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=Zabere pozemek, na kterem se nachazis
claim.usage=/p claim [jmeno]
claim.yourplot=Jiz jsi si zabral(a) tento pozemek.
claim.alreadyclaimed=Tento pozemek jiz vlastni hrac {%0}
claim.maxplots=Muzes mit maximalne {%0} pozemku!
claim.nomoney=Nemas penize pro zakoupeni tohoto pozemku!
claim.success=Uspesne jsi si zabral(a) tento pozemek.

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleportuje te na volny pozemek.
auto.usage=/p auto
auto.notplotworld=Aby tento prikaz fungoval, musis byt v Plot svete.
auto.success=Byl(a) jsi teleportovan(a) na pozemek ({%0}, {%1}).
auto.noplots=Nejsou tu zadne pozemky!

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Odebere ti pozemek
dispose.usage=/p dispose
dispose.confirm=Opravdu se chces zbacit pozemku {%0} ? pokud ano, napis /p dispose confirm
dispose.nomoney=Nemas dostatek penez na prodani pozemku!
dispose.success=Plot byl znicen.

; The /p reset Subcommand
reset.name=reset
reset.desc=resetuje pozemek
reset.usage=/p reset
reset.confirm=Opravdu chces resetovat pozemek {%0} ? pokud ano napis, /p reset confirm
reset.nomoney=Nemas penize na resetovani pozemku!
reset.success=Plot byl resetovan.

; The /p clear Subcommand
clear.name=clear
clear.desc=Vycisti pozemek
clear.usage=/p clear
clear.confirm=Opravdu chces vycistit pozemek {%0} ? pokud ano napis, /p clear confirm
clear.nomoney=Nemas penize na pozemek!
clear.success=Pozemek vycisten.

; The /p biome Subcommand
biome.name=biome
biome.desc=Zmeni biom tveho plotu
biome.usage=/p biome [biome]
biome.success=Pozemkovy biom je {%0}
biome.invalid=Tenot biom neexistuje!
biome.possible=Mozne biomy jsou: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List dostupnych biomu
biomes.usage=/p biomes
biomes.possible=Mozne biommy jsou: {%0}

; The /p name Subcommand
name.name=name
name.desc=Nastavi nebo zmeni nazev tveho pozemku
name.usage=/p name <nazev>
name.success=Nazev pozemku byl zmenen na {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Teleportuje te na pozemek
home.usage=/p home [cislo]
home.noplots=ty nemas zadne pozemky!
home.notexist=Pozemek si id {%0} nebyl nalezen!
home.success=Byl jsi teleportovan na pozemek {%0}
home.error=Nelze se teleportovat na tento pozemek!

; The /p homes Subcommand
homes.name=homes
homes.desc=Zobrazi tve pozemky.
homes.usage=/p homes
homes.noplots=Nemas zadne pozemky.
homes.header=Tve pozemky:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Zobrazi informace o pozemku
info.usage=/p info
info.about=Informace o plotu {%0}
info.plotname=Nazev pozemku: {%0}
info.owner=Majitel pozemku: {%0}
info.helpers=Pomocnici Majitele pozemku: {%0}
info.denied=
info.biome=Biom pozemku: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Vytvori novy MyPlot svet
generate.usage=/p generate <NazveSveta>
generate.exists=Svet s nazvem {%0} jiz existuje
generate.gexists=Generator {%0} neexistuje
generate.success=Byl vytvoren svet s nazvem {%0}
generate.error=Svet nemuze byt vytvoren

; The /p give Subcommand
give.name=give
give.desc=Preda pozemek danemu hraci
give.usage=/p give [name]
give.notonline=Hrac, kteremu chces pozemek predat musi byt pripojen.
give.maxedout=Tento hrac ma hodne plotu!
give.toself=Nemuzes rozdavat pozemky!
give.confirm=Opravdu chces dat pozemek {%0} hraci {%1}? Pokud ano napis /p give {%1} confirm
give.success=Predal(a) jsi pozemek hraci(ce) {%0}
give.received={%0} ti daroval pozemek, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleportuje te na pozemek
warp.usage=/p warp <id>
warp.wrongid=Plot ID musi byt ve formatu X;Z.
warp.notinplotworld=Musis byt v Plot svete.
warp.unclaimed=Nemuzes se warpovat na plot, ktery nikomu nepatri!
warp.success=Byl jsi teleportovan na pozemek {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleportuje te presne do prosted pozemku!
middle.usage=/p mid
middle.success=Teleportace byla uspesna!

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Nastavi noveho majitele pozemku!
setowner.usage=/p setowner <hrac>
setowner.maxplots=Tento hrac dosahl maximalniho poctu pozemku {%0}!
setowner.success={%0} je novy majitel pozemku!

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Zobrazi vsechny pozemky hrace
list.usage=/p list [hrac]
list.found="Pozemek {%0} na ({%1},{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.success=Pvp is now {%0} for the plot; German language pack for MyPlot
; Created by SalmonDE and morpheus132
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Du hast das Grundstck {%0} betreten.
popup.owner=Dieses Grundstck gehrt {%0}.
popup.available=Dieses Grundstck ist verfgbar! Benutze /p claim, um es zu beanspruchen.
popup.denied=Du darfst dieses Grundstck nicht betreten!

; /p info
command.name=plot
command.alias=p
command.desc=Verwalte Grundstcke.
command.usage=/plot <help|Unterbefehl> [Optionen]
command.unknown=Unbekannter Befehl! Benutze /p help, um eine Liste von Befehlen zu erhalten.

subcommand.usage=Syntax: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Ups! Irgendetwas ist falsch gelaufen!
notinplot=Du befindest dich nicht auf einem Grundstck.
notowner=Dieses Grundstck gehrt dir nicht!
plugin.disabled=Dieses Plugin ist deaktiviert

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Zeige das Hilfemen an.
help.usage=/p help [Seite]
help.header=--- Zeige MyPlot Hilfeseite {%0} von {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Fge einen Helfer zu einem Grundstck hinzu.
addhelper.usage=/p addhelper <Spieler>
addhelper.alreadyone={%0} ist bereits ein Helfer von diesem Grundstck!
addhelper.success={%0} wurde zu einem Helfer von diesem Grundstck ernannt.

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Entferne einen Helfer von einem Grundstck.
removehelper.usage=/p removehelper <Spieler>
removehelper.notone={%0} ist kein Helfer von diesem Grundstck!
removehelper.success={%0} ist kein Helfer mehr.

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Verbiete einem Spieler dein Grundstck zu betreten.
denyplayer.usage=/p deny <Spieler>
denyplayer.helper={%0} ist ein Helfer!
denyplayer.alreadyone={%0} ist es bereits verboten, dein Grundstck zu betreten!
denyplayer.notaplayer=Dieser Spieler ist momentan nicht online.
denyplayer.cannotdeny=Du kannst {%0} nicht verbieten, dein Grundstck zu betreten!
denyplayer.attempteddeny={%0} versucht, dich von einem Grundstck zu sperren!
denyplayer.success1={%0} darf dein Grundstck nun nicht mehr betreten.
denyplayer.success2="Du darfst nicht mehr das Grundstck {%0};{%1} von {%2} betreten!"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Entsperre einen Spieler von einem Grundstck.
undenyplayer.usage=/p undeny <player>
undenyplayer.notone={%0} ist bereits entsperrt!
undenyplayer.success1={%0} ist nun entsperrt!
undenyplayer.success2="Du darfst das Grundstck {%0};{%1} von {%2} nun wieder betreten!"
undenyplayer.failure={%0} ist immer noch gesperrt.

; The /p claim Subcommand
claim.name=claim
claim.desc=Beanspruche das Grundstck, auf dem du dich befindest.
claim.usage=/p claim [Name]
claim.yourplot=Dir gehrt dieses Grundstck bereits!
claim.alreadyclaimed=Dieses Grundstck gehrt bereits {%0}.
claim.maxplots=Du darfst das Limit von {%0} Grundstcken pro Spieler nicht berschreiten!
claim.nomoney=Du besitzt nicht genug Geld, um dieses Grundstck zu kaufen!
claim.success=Du hast dieses Grundstck erfolgreich fr dich beansprucht.

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleportiere dich zum nchsten, freien Grundstck.
auto.usage=/p auto
auto.notplotworld=Du bist nicht in einer Grundstckswelt!
auto.success="Du wurdest erfolgreich zu dem Grundstck ({%0};{%1}) teleportiert."
auto.noplots=Es wurde kein verfgbares Grundstck gefunden.

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Gebe dein Grundstck frei.
dispose.usage=/p dispose
dispose.confirm=Bist du sicher, dass du das Grundstck {%0} freigeben mchtest? Wenn ja, benutze /p dispose confirm.
dispose.nomoney=Du besitzt nicht genug Geld, um dieses Grundstck freizugeben.
dispose.success=Das Grundstck wurde freigegeben.

; The /p reset Subcommand
reset.name=reset
reset.desc=Setze ein Grundstck zurck.
reset.usage=/p reset
reset.confirm=Bist du sicher, dass du das Grundstck {%0} zurcksetzen mchtest? Wenn ja, benutze /p reset confirm.
reset.nomoney=Du besitzt nicht genug Geld, um dieses Grundstck zurckzusetzen.
reset.success=Grundstck zurckgesetzt.

; The /p clear Subcommand
clear.name=clear
clear.desc=Leere dein Grundstck
clear.usage=/p clear
clear.confirm=Bist du sicher, dass du das Grundstck {%0} leeren mchtest? Wenn ja, benutze /p clear confirm.
clear.nomoney=Du besitzt nicht genug Geld, um dieses Grundstck zurckzusetzen.
clear.success=Grundstck geleert.

; The /p biome Subcommand
biome.name=biome
biome.desc=ndere das Biom von einem Grundstck.
biome.usage=/p biome [Biom]
biome.success=Das Grundstcksbiom wurde zu {%0} gendert.
biome.invalid=Dieses Biom existiert nicht!
biome.possible=Verfgbare Biome: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=Liste alle verfgbaren Biome auf.
biomes.usage=/p biomes
biomes.possible=Verfgbare Biome: {%0}

; The /p name Subcommand
name.name=name
name.desc=Benenne ein Grundstck um.
name.usage=/p name <Name>
name.success=Der Name dieses Grundstcks ist nun {%0}.

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Teleportiere dich zu deinem Grundstck
home.usage=/p home [Nummer] [Welt]
home.noplots=Du besitzt keine Grundstcke in dieser Welt.
home.notexist=Du besitzt kein Grundstck mit der ID {%0} in dieser Welt.
home.success=Du wurdest erfolgreich zu dem Grundstck {%0} in der Welt {%1} teleportiert.
home.error=Du konntest nicht zu deinem Grundstck teleportiert werden.

; The /p homes Subcommand
homes.name=homes
homes.desc=Zeige deine beanspruchten Grundstcke an.
homes.usage=/p homes
homes.noplots=Du beanspruchst keine Grundstcke.
homes.header=Grundstcke, die du beanspruchst:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Zeige Informationen ber ein Grundstck an.
info.usage=/p info
info.about=Informationen ber Grundstck: {%0}
info.plotname=Name: {%0}
info.owner=Besitzer: {%0}
info.helpers=Helfer: {%0}
info.denied=Gesperrt: {%0}
info.biome=Biom: {%0}
info.notfound=Das Grundstck wurde nicht gefunden.

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Generiere eine neue Grundstckswelt.
generate.usage=/p generate <Name> [Generator]
generate.exists=Die Welt {%0} existiert bereits!
generate.gexists=Der Generator {%0} existiert nicht!
generate.success=Die Grundstckswelt {%0} wurde erfolgreich erstellt.
generate.error=Die Welt konnte nicht erstellt werden!

; The /p give Subcommand
give.name=give
give.desc=Gebe dein Grundstck jemand anderen.
give.usage=/p give [Name]
give.notonline=Dieser Spieler ist nicht online.
give.maxedout=Dieser Spieler hat die maximale Anzahl seiner Grundstcke erreicht.
give.toself=Du kannst dir dein Grundstck nicht selbst geben.
give.confirm=Bist du sicher, dass du das Grundstck {%0} dem Spieler {%1} geben mchtest? Wenn ja, benutze /p give {%1} confirm.
give.success=Du hast das Grundstck an {%0} gegeben.
give.received={%0} gab dir das Grundstck: {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleportiere dich zu einem bestimmten Grundstck.
warp.usage=/p warp <ID>
warp.wrongid="Die Grundstck ID sollte in diesem Format sein: X;Z"
warp.notinplotworld=Du bist nicht in einer Grundstckswelt!
warp.unclaimed=Du kannst dich nicht zu einem Grundstck teleportieren, das niemanden gehrt.
warp.success=Du wurdest zu dem Grundstck {%0} teleportiert!

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleportiere dich zu dem Mittelpunkt eines Grundstcks
middle.usage=/p mid
middle.success=Du wurdest in die Mitte des Grundstcks teleportiert.

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Setzt einen neuen Besitzer eines Grundstcks.
setowner.usage=/p setowner <Name>
setowner.maxplots=Dieser Spieler hat die maximale Anzahl an Grundstcke von {%0} erreicht.
setowner.success={%0} ist nun der Besitzer von diesem Grundstck.

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Liste alle Grundstcke auf, die ein Spieler beansprucht.
list.usage=/p list [Spieler]
list.found="Grundstck {%0} bei ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Schaltet den PvP-Modus um fr das Grundstck
pvp.usage=/p pvp
pvp.world=PvP ist in dieser Grundstckswelt deaktiviert.
pvp.plot=PvP ist auf diesem Grundstck deaktiviert.
pvp.success=PvP-Modus ist nun "{%0}" fr das Grundstck
; French language pack for MyPlot
; Created by @Ad5001 and updated by @LeoBdt
; Updated time : 2/17/2019

; Popup lors d'une entre dans le plot
popup=Vous tes sur le plot {%0}
popup.owner=Cr par {%0}
popup.available=Ce plot est disponible! Fait /p claim pour te l'approprier
popup.denied=Tu as refus ce plot.

; /p info
command.name=plot
command.alias=p
command.desc=Donne des informations  propos du plot o vous tes actuellement
command.usage=/p [help]
command.unknown=Commande inconnue, fait /p help

subcommand.usage=Usage: {%0}

; Les erreurs affiches lorsque le plugin bugue.
error=oops ! quelque chose ne va pas.
notinplot="Vous n'tes pas sur un plot"
notowner=Ce plot ne vous appartient pas
plugin.disabled=Ce plugin est dsactiv

confirm=confirm

; La commande /p help
help.name=help
help.desc=Affiche la liste des commandes relatives  MyPlot
help.usage=/p help [page: int]
help.header=--- Pages d'aide de MyPlot {%0} sur {%1} ---

; La commande /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Ajouter un joueur  votre plot (ce joueur sera en mesures de casser ou poser des blocs.)
addhelper.usage=/p addhelper <player: string>
addhelper.alreadyone={%0} est dj avec vous sur ce plot.
addhelper.success={%0} est dsormais admis sur votre plot.

; La commande /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Supprimer un joueur de votre plot
removehelper.usage=/p removehelper <player: string>
removehelper.notone="{%0} n'est pas admis sur votre plot."
removehelper.success="{%0} n'est dsormais plus admis sur votre plot et il ne pourra plus poser n'y casser de blocs."

; La commande /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Banni un joueur de votre plot
denyplayer.usage=/p deny <player: string>
denyplayer.helper={%0} fait partie de votre plot, merci de retirer son rang de helper.
denyplayer.alreadyone={%0} est dj banni de votre plot
denyplayer.notaplayer=Ce joueur est hors-ligne.
denyplayer.cannotdeny={%0} ne peut tre banni de votre plot
denyplayer.attempteddeny={0} a essay de vous bannir de son plot.
denyplayer.success1={%0} est dsormais banni de votre plot.
denyplayer.success2=Vous avez t banni du plot {%0};{%1} de {%2}

; La commande /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Retire le bannissement d'un joueur sur votre plot
undenyplayer.usage=/p undeny <player: string>
undenyplayer.notone="{%0} n'est pas banni."
undenyplayer.success1="{%0} n'est plus banni"
undenyplayer.success2="Vous n'tes plus banni du plot {%0};{%1} de {%2}"
undenyplayer.failure=Impossible de retirer le ban de {%0}

; La commande /p claim Subcommand
claim.name=claim
claim.desc=Prendre/acheter le plot sur lequel vous tes
claim.usage=/p claim [nom du plot]
claim.yourplot=Vous possdez dj ce plot
claim.alreadyclaimed=Ce plot appartient dj  {%0}
claim.maxplots=Vous avez atteint la limite de plot autoriss {%0}
claim.nomoney="Vous n'avez pas assez d'argent pour acheter ce plot"
claim.success=Flicitations, ce plot vous appartient dsormais.

; La commande /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Tlporte au plot libre le plus proche
auto.usage=/p auto [claim: bool] [name: string]
auto.notplotworld="Vous n'tes pas sur un monde avec des plot"
auto.success="Tlportation au plot ({%0};{%1})"
auto.noplots="Il n'y a plus de plots disponibles."

; La commande /p dispose Subcommand
dispose.name=dispose
dispose.desc="Mettre  disposition votre plot, ce qui le rend disponible  l'achat"
dispose.usage=/p dispose
dispose.confirm=tes vous sr de vouloir mettre  disposition votre plot? Si oui, merci de faire /p dispose confirm
dispose.nomoney="Vous n'avez pas assez d'argent pour mettre  disposition ce plot"
dispose.success=Votre plot a bien t mit  disposition

; La commande /p reset Subcommand
reset.name=reset
reset.desc=Rinitialiser votre plot (le mettre  disposition et le remettre  0)
reset.usage=/p reset
reset.confirm=tes vous sr de vouloir remettre  zro votre plot? Si oui, merci de faire /p reset confirm
reset.nomoney="Vous n'avez pas assez d'argent pour rinitialiser ce plot"
reset.success=Votre plot a bien t rinitialiser, merci de patienter...

; La commande /p clear Subcommand
clear.name=clear
clear.desc=Remettre  0 votre plot
clear.usage=/p clear
clear.confirm="tes-vous sr de vouloir remettre  zro votre plot? Si oui, merci de faire /p plot confirm"
clear.nomoney="Vous n'avez pas assez d'argent pour remettre  0 ce plot"
clear.success=Votre plot a bien t remis  zro.

; La commande /p biome Subcommand
biome.name=biome
biome.desc=Changer le biome de votre plot
biome.usage=/p biome [biome: string]
biome.success=Votre plot a bien changer de biome
biome.invalid="Ce biome n'existe pas"
biome.possible=Les biomes disponibles sont: {%0}

; La commande /p biomes Subcommand
biomes.name=biomes
biomes.desc=Affiche la liste des biomes
biomes.usage=/p biomes
biomes.possible=Les biomes disponibles sont: {%0}

; La commande /p name Subcommand
name.name=name
name.desc=Donner un nom  votre plot
name.usage=/p name <name: string>
name.success=Le nom de votre plot est dsormais

; La commande /p home Subcommand
home.name=home
home.alias=h
home.desc=Se tlporter  votre plot.
home.usage=/p home [nombre: int] [monde: string]
home.noplots="Vous n'avez aucun plot"
home.notexist="Vous n'avez pas de plot avec le numro"
home.success=Tlportation au plot {%0}
home.error=Impossible de se tlpoter  ce plot

; La commande /p homes Subcommand
homes.name=homes
homes.desc=Affiche vos plots
homes.usage=/p homes [monde: string]
homes.noplots=Vous n'avez pas de plot(s).
homes.header=Vos plot(s):

; La commande /p info Subcommand
info.name=info
info.alias=i
info.desc=Voir les informations du plot sur lequel vous tes
info.usage=/p info [joueur] [plot]
info.about=Informations du plot
info.plotname=Nom: {%0}
info.owner=Propritaire: {%0}
info.helpers=Autres joueurs sur le plot: {%0}
info.denied=Joueurs bannis:
info.biome=Biome: {%0}
info.notfound=Ce plot n'est pas trouv

; La commande /p generate Subcommand - OP ou perm myplot.command.generatepermission
generate.name=generate
generate.alias=gen
generate.desc=
generate.usage=/p generate <name: string> [generator name: string]
generate.exists=Ce monde existe dj
generate.gexists="Ce gnrateur n'xiste pas"
generate.success=Monde gnr!
generate.error=le monde ne peut tre gnrer

; La commande /p give Subcommand
give.name=give
give.desc=Donne votre plot au joueur souhait.
give.usage=/p give [joueur: string]
give.notonline=Ce joueur est hors-ligne.
give.maxedout=Ce joueur possde trop de plots
give.toself=Vous ne pouvez pas donner votre plot  vous mme
give.confirm=tes-vous sr de vouloir donner le plot {%0}  {%1}? Si oui, merci de faire /p give {%1} confirm
give.success=Vous avez donn votre plot  {%0}
give.received={%0} vous a donn le plot {%1}

; La commande /p warp Subcommand
warp.name=warp
warp.desc=Tlporte a un warp
warp.usage=/p warp <monde: int> [world: string]
warp.wrongid=Mauvais id ( doit tre X;Z )
warp.notinplotworld="Vous n'tes pas dans un monde avec des plots"
warp.unclaimed=Vous ne pouvez vous tlporter dans un plot unclaum
warp.success=Tlport  {%0}

; La commande /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Tlporte au milieu du plot sur lequel vous tes
middle.usage=/p mid
middle.success=Tlport au milieu du plot

; La commande /p setowner Subcommand
setowner.name=setowner
setowner.desc=Dfinit le nouveau propritaire du plot
setowner.usage=/p setowner <player: string>
setowner.maxplots=Ce joueur a dj un maximum de plots
setowner.success={%0} est dsormais le propritaire du plot

; La commande /p list Subcommand
list.name=list
list.alias=l
list.desc=Voir la liste de vos plots
list.usage=/p list [joueur: string]
list.found="Plot {%0}  ({%1};{%2}),"

; La commande /p pvp Subcomand
pvp.name=pvp
pvp.desc=Active ou dsactive le pvp dans votre plot
pvp.usage=/p pvp
pvp.world="Le pvp n'est pas activ dans ce monde"
pvp.plot=Le pvp est dsactiv dans ce plot
pvp.success=Le pvp est dsormais {%0} pour ce plot
; Korean language pack for MyPlot
; Created by Johnmacrocraft
; Updated time : 2/17/2019

; Popup when entering a plot
popup={%0}  
popup.owner={%0}() 
popup.available=   . /p claim     .
popup.denied=    

; /p info
command.name=plot
command.alias=p
command.desc=  
command.usage=/p [help]
command.unknown=   . /p help   

subcommand.usage=: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=!  
notinplot=    
notowner=    
plugin.disabled=   

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=  
help.usage=/p help [ : int]
help.header=--- MyPlot  {%1}  {%0} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=  
addhelper.usage=/p addhelper <: string>
addhelper.alreadyone={%0}()    
addhelper.success={%0}()    

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=  
removehelper.usage=/p removehelper <: string>
removehelper.notone={%0}()  
removehelper.success={%0}()   

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=   
denyplayer.usage=/p deny <: string>
denyplayer.helper={%0}() 
denyplayer.alreadyone={%0}()    
denyplayer.notaplayer=     
denyplayer.cannotdeny={%0}()   
denyplayer.attempteddeny={%0}()    
denyplayer.success1={%0}()     
denyplayer.success2="{%0};{%1}   {%2}  "

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=    
undenyplayer.usage=/p undeny <: string>
undenyplayer.notone={%0}()   
undenyplayer.success1={%0}()  
undenyplayer.success2="{%0};{%1}  {%2}  "
undenyplayer.failure={%0}()   

; The /p claim Subcommand
claim.name=claim
claim.desc=    
claim.usage=/p claim [: string]
claim.yourplot=   
claim.alreadyclaimed=   {%0}()  
claim.maxplots=  {%0}  
claim.nomoney=     
claim.success=  

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=   
auto.usage=/p auto [ : bool] [: string]
auto.notplotworld=   
auto.success=" ({%0};{%1})  "
auto.noplots=     

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc= 
dispose.usage=/p dispose
dispose.confirm={%0}  ?  /p dispose confirm 
dispose.nomoney=     
dispose.success= 

; The /p reset Subcommand
reset.name=reset
reset.desc=  
reset.usage=/p reset
reset.confirm={%0}  ?  /p reset confirm 
reset.nomoney=     
reset.success= 

; The /p clear Subcommand
clear.name=clear
clear.desc= 
clear.usage=/p clear
clear.confirm={%0}  ?  /p clear confirm 
clear.nomoney=     
clear.success= 

; The /p biome Subcommand
biome.name=biome
biome.desc=   
biome.usage=/p biome [ : string]
biome.success=   {%0}() 
biome.invalid=    
biome.possible=    : {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=     
biomes.usage=/p biomes
biomes.possible=    : {%0}

; The /p name Subcommand
name.name=name
name.desc=   
name.usage=/p name <: string>
name.success=  {%0}() 

; The /p home Subcommand
home.name=home
home.alias=h
home.desc= 
home.usage=/p home [: int] [: string]
home.noplots=     
home.notexist=  id {%0}()    
home.success={%1}   {%0}() 
home.error=   

; The /p homes Subcommand
homes.name=homes
homes.desc=  
homes.usage=/p homes [: string]
homes.noplots=   
homes.header= :

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=   
info.usage=/p info [] [ ]
info.about={%0}   
info.plotname=: {%0}
info.owner=: {%0}
info.helpers=: {%0}
info.denied= : {%0}
info.biome= : {%0}
info.notfound=    

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=   
generate.usage=/p generate <: string> [ : string]
generate.exists={%0}()    
generate.gexists= {%0}()  
generate.success={%0}    
generate.error=   

; The /p give Subcommand
give.name=give
give.desc=   
give.usage=/p give [: string]
give.notonline=    
give.maxedout=     
give.toself=     
give.confirm= {%1} {%0}  ?  /p give {%1} confirm 
give.success={%0}  
give.received={%0}() {%1}  

; The /p warp Subcommand
warp.name=warp
warp.desc= 
warp.usage=/p warp <id: int> [: string]
warp.wrongid=" id X;Z  "
warp.notinplotworld=   
warp.unclaimed=     
warp.success={%0}  

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=    
middle.usage=/p mid
middle.success= 

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=      
setowner.usage=/p setowner <: string>
setowner.maxplots=  {%0}   
setowner.success={%0}()    

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=    
list.usage=/p list [: string]
list.found="({%1};{%2}) {%0} ,"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc= pvp  
pvp.usage=/p pvp
pvp.world=Pvp      
pvp.plot=Pvp    
pvp.success=Pvp   {%0}  ; lang language pack for MyPlot
; Created by username
; Updated time : 00/00/0000

; Popup when entering a plot
popup=
popup.owner=
popup.available=
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=
command.usage=/p [help]
command.unknown=

subcommand.usage=

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=
notinplot=
notowner=
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=
help.usage=/p help []
help.header=

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=
addhelper.usage=/p addhelper <>
addhelper.alreadyone=
addhelper.success=

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=
removehelper.usage=/p removehelper <>
removehelper.notone=
removehelper.success=

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper=
denyplayer.alreadyone=
denyplayer.notaplayer=
denyplayer.cannotdeny=
denyplayer.attempteddeny=
denyplayer.success1=
denyplayer.success2=

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone=
undenyplayer.success1=
undenyplayer.success2=
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=
claim.usage=/p claim []
claim.yourplot=
claim.alreadyclaimed=
claim.maxplots=
claim.nomoney=
claim.success=

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=
auto.usage=/p auto [] []
auto.notplotworld=
auto.success=
auto.noplots=

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=
dispose.usage=/p dispose
dispose.confirm=
dispose.nomoney=
dispose.success=

; The /p reset Subcommand
reset.name=reset
reset.desc=
reset.usage=/p reset
reset.confirm=
reset.nomoney=
reset.success=

; The /p clear Subcommand
clear.name=clear
clear.desc=
clear.usage=/p clear
clear.confirm=
clear.nomoney=
clear.success=

; The /p biome Subcommand
biome.name=biome
biome.desc=
biome.usage=/p biome []
biome.success=
biome.invalid=
biome.possible=

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=
biomes.usage=/p biomes
biomes.possible=

; The /p name Subcommand
name.name=name
name.desc=
name.usage=/p name <>
name.success=

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=
home.usage=/p home [] []
home.noplots=
home.notexist=
home.success=
home.error=

; The /p homes Subcommand
homes.name=homes
homes.desc=
homes.usage=/p homes []
homes.noplots=
homes.header=

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=
info.usage=/p info [] []
info.about=
info.plotname=
info.owner=
info.helpers=
info.denied=
info.biome=
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=
generate.usage=/p generate <> []
generate.exists=
generate.gexists=
generate.success=
generate.error=

; The /p give Subcommand
give.name=give
give.desc=
give.usage=/p give []
give.notonline=
give.maxedout=
give.toself=
give.confirm=
give.success=
give.received=

; The /p warp Subcommand
warp.name=warp
warp.desc=
warp.usage=/p warp <> []
warp.wrongid=
warp.notinplotworld=
warp.unclaimed=
warp.success=

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=
middle.usage=/p mid
middle.success=

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=
setowner.usage=/p setowner <>
setowner.maxplots=
setowner.success=

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=
list.usage=/p list []
list.found=

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=/p pvp
pvp.world=
pvp.plot=
pvp.success=; Dutch language pack for MyPlot
; Created by Wiez
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Dit is plot {%0}
popup.owner=Van {%0}
popup.available=
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=Beheer uw plots
command.usage=/plot <help|sub-cmd> [opties]
command.unknown=Onbekend commando. Gebruik /p help voor een lijst van alle commandos

subcommand.usage=Gebruik: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Oeps! Er is iets verkeerd gelopen
notinplot=Je staat niet in een plot
notowner=Dit is niet jouw plot
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Toont het help menu
help.usage=/p help [pagina]
help.header=--- MyPlot help pagina {%0} van de {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Voeg een helper toe aan jouw plot
addhelper.usage=/p addhelper <speler>
addhelper.alreadyone={%0} is al een helper van jouw plot
addhelper.success={%0} is nu een helper van jouw plot

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Verwijder een helper van jouw plot
removehelper.usage=/p removehelper <player>
removehelper.notone={%0} is geen helper
removehelper.success={%0} is verwijderd als helper

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper=
denyplayer.alreadyone=
denyplayer.cannotdeny=
denyplayer.attempteddeny=
denyplayer.success1=
denyplayer.success2=

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone=
undenyplayer.notaplayer=
undenyplayer.success1=
undenyplayer.success2=
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=Bemachtig het stukje land waar je op staat
claim.usage=/p claim [naam]
claim.yourplot=Dit is jouw plot al
claim.alreadyclaimed=Dit plot is al van {%0}
claim.maxplots=Je hebt de limiet bereikt van {%0} plots per speler
claim.nomoney=Je hebt niet genoeg geld om deze plot te bemachtigen
claim.success=Dit is nu jouw stukje land

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleporteer naar de volgende vrije plot
auto.usage=/p auto
auto.notplotworld=Je bent niet in een plot wereld
auto.success=Je bent geteleporteerd naar plot ({%0}, {%1})
auto.noplots=Er zijn geen vrije plots gevonden

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Doe afstand van deze plot
dispose.usage=/p dispose
dispose.confirm=Ben je zeker dat je niet meer de eigenaar wil zijn van plot {%0} ? Doe dan /p dispose confirm
dispose.nomoney=Je hebt hiervoor niet genoeg geld
dispose.success=Je bent niet meer de eigenaar van deze plot

; The /p reset Subcommand
reset.name=reset
reset.desc=Herstel een plot naar zijn begin toestand en doe er afstand van
reset.usage=/p reset
reset.confirm=Ben je zeker dat je plot {%0} wil resetten? Doe dan /p reset confirm
reset.nomoney=Je hebt niet genoeg geld om deze plot te resetten
reset.success=De plot is gereset

; The /p clear Subcommand
clear.name=clear
clear.desc=Herstelt deze plot naar zijn begin toestand
clear.usage=/p clear
clear.confirm=Ben je zeker dat je plot {%0} wil herstellen? Doe dan /p clear confirm
clear.nomoney=Je hebt niet genoeg geld om deze plot te herstellen
clear.success=De plot is hersteld

; The /p biome Subcommand
biome.name=biome
biome.desc=Verandert de biome in een ander type
biome.usage=/p biome [type]
biome.success=De biome van deze plot is veranderd naar {%0}
biome.invalid=Dat type bestaat niet
biome.possible=De mogelijke biome types zijn: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; The /p name Subcommand
name.name=name
name.desc=Verandert de naam van deze plot
name.usage=/p name <naam>
name.success=Deze plot noemt nu {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Ga naar een van je plots
home.usage=/p home [nummer]
home.noplots=Je hebt geen plots
home.notexist=Je hebt geen plot met nummer {%0}. Gebruik /p homes om al je plots te bekijken
home.success=Je bent geteleporteerd naar plot {%0}
home.error=Er is iets mis gegaan bij het teleporteren

; The /p homes Subcommand
homes.name=homes
homes.desc=Geeft een lijst van al jouw plots
homes.usage=/p homes
homes.noplots=Je hebt geen plots
homes.header=Jouw plots:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Toont informatie over een plot
info.usage=/p info
info.about=Info van plot {%0}
info.plotname=Naam: {%0}
info.owner=Eigenaar: {%0}
info.helpers=Helpers: {%0}
info.denied=
info.biome=Biome: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Genereert een nieuwe plot wereld
generate.usage=/p generate <naam>
generate.exists=Er bestaat al een wereld met naam {%0}
generate.gexists=
generate.success=De nieuwe plot wereld {%0} is gegenereerd
generate.error=De wereld kon niet gegenereerd worden

; The /p give Subcommand
give.name=give
give.desc=Geef je plot aan iemand anders
give.usage=/p give [speler]
give.notonline=Die speler is niet online
give.maxedout=Die speler heeft de maximale plot limiet bereikt
give.toself=Je kan de plot niet aan jezelf geven
give.confirm=Ben je zeker dat je plot {%0} wil geven aan {%1}? Doe dan /p give {%1} confirm
give.success=Je hebt jouw plot gegeven aan {%0}
give.received={%0} heeft plot {%1} aan jouw gegeven

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleporteer naar een plot
warp.usage=/p warp <x;z>
warp.wrongid=De plot nummer moet in het formaat X;Z zijn
warp.notinplotworld=Je bent niet in een plot wereld
warp.unclaimed=Je kan niet naar een leeg plot teleporteren
warp.success=Je bent geteleporteerd naar {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleports the player to exact center of plot at ground level
middle.usage=/p mid
middle.success=Teleporting complete

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Sets the new owner of the plot without charging anything
setowner.usage=/p setowner <player: string>
setowner.maxplots=That player reached their plots limit of {%0}
setowner.success={%0} is now the owner of this plot

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Shows all plots a player has
list.usage=/p list [player: string]
list.found="Plot {%0} at ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.success=Pvp is now {%0} for the plot; Spanish language pack for MyPlot
; Created by kenygamer
; Updated time: 2/17/2019

; Popup al entrar en un terreno
popup=Has ingresado al terreno {%0}
popup.owner=Propiedad de {%0}
popup.available=Este terreno est abierto. Usa /p claim para reclamar.
popup.denied=

; Main Command (/plot)
command.name=plot 
command.alias=p 
command.desc=Reclamar y gestionar sus parcelas.
command.usage=/p [help]
command.unknown=Comando desconocido. Utiliza /p help para la lista de comandos

subcommand.usage=Uso: {%0}

; Errores que aparecen cuando el jugador hace algo mal, o el plugin se averia
error=Oops! Ocurri un error
notinplot=No ests dentro de una parcela
notowner=No eres el dueo de esta parcela
plugin.disabled=

confirm=confirmar

; El subcomando /p help
help.name=help 
help.desc=Help men 
help.usage=/p help [pagina] 
help.header=---MyPlot Mostrando ayuda {%0} de {%1}---

; El subcomando /p addhelper
addhelper.name=addhelper 
addhelper.alias=addh 
addhelper.desc=Add un ayudante a su parcela 
addhelper.usage=/p addhelper
addhelper.alreadyone={%0} es un ayudante de esta parcela
addhelper.success={%0} es ahora un ayudante de esta parcela

;El subcomando /p removehelper
removehelper.name=removehelper 
removehelper.alias=delh 
removehelper.desc=Aadir un ayudante a su terreno
removehelper.usage=/p removehelper
removehelper.notone={%0} no es un ayudante
removehelper.success={%0} se ha quitado de los ayudantes de su parcela

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper=
denyplayer.alreadyone=
denyplayer.notaplayer=
denyplayer.cannotdeny=
denyplayer.attempteddeny=
denyplayer.success1=
denyplayer.success2=

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone=
undenyplayer.success1=
undenyplayer.success2=
undenyplayer.failure=

; El subcomando /p claim
claim.name=claim 
claim.desc=Reclame la parcela en la que ests
claim.usage=/p claim [nombre: cadena]
claim.yourplot=Esta ya es su parcela
claim.alreadyclaimed=Esta parcela ya fue reclamada por {0%}
claim.maxplots=Ha alcanzado el lmite de parcelas por jugador {%0}
claim.nomoney=No tiene suficiente dinero para reclamar este terreno
claim.success=Ha reclamado con xito esta parcela

; El subcomando /p auto
auto.name=auto 
auto.alias=a 
auto.desc=Teletransporta a la parcela libre ms cercana
auto.usage=/p auto
auto.notplotworld=No est en un mundo de parcelas
auto.success=Teletransportado a parcela libre ({%0}, {1%}) 
auto.noplots=No hay parcelas disponibles aqu

; El subcomnado /p dispose
dispose.name=dispose
dispose.desc=Deshacerse de su parcela
dispose.usage=Est seguro de deshacerse de su parcela {%0}? Si es as, use /p dispose confirm
dispose.confirm=
dispose.nomoney=No tiene suficiente dinero para deshacerse de esta parcela
dispose.success=Terreno eliminado

; El subcomando /p reset
reset.name=reset 
reset.desc=Se deshace de su terreno como tambin lo borra
reset.usage=Est seguro de deshacer su terreno y borrarlo {%0}? Si es as, use /p reset confirm
reset.confirm=
reset.nomoney=No tiene suficiente dinero para borarr este terreno
reset.success=Plot reset

; El subcomando /p clear
clear.name=clear 
clear.desc=Limpiar su terreno 
clear.usage=Est seguro de limpiar su terreno {%0}? Si es as, use /p clear confirm
clear.confirm=
clear.nomoney=No tiene suficiente dinero para limpiar este terreno
clear.success=Plot despejado

; El subcomando /p biome
biome.name=biome 
biome.desc=Cambia el bioma de su parcela 
biome.usage=/p biome [bioma] 
biome.success=Bioma de su terreno cambiado a {%0}
biome.invalid=Ese bioma no existe 
biome.possible=Los biomas posibles son: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; El subcomando /p name
name.name=name 
name.desc=Establece o cambia el nombre de su parcela 
name.usage=/p name 
name.success=Nombre del terreno cambiado a {%0}

; El subcomando /p home
home.name=home 
home.alias=h 
home.desc=Regresar a su parcela 
home.usage=/p home [nmero] 
home.noplots=No posees ninguna parcela
home.notexist=No posees ninguna parcela con el identificador {%0} 
home.success=Teletransportado a la parcela {%0} 
home.error=No se pudo regresar a su parcela

; El subcomando /p homes
homes.name=homes 
homes.desc=Muestra sus parcelas reclamadas 
homes.usage=/p homes 
homes.noplots=No posees ninguna parcela reclamada 
homes.header=Tus parcelas:

; El subcomando /p info
info.name=info 
info.alias=i 
info.desc=Muestra informacin sobre una parcela
info.usage=/p info 
info.about=Informacin sobre la parcela {%0} 
info.plotname= Nombre: {%0} 
info.owner=Dueo: {%0} 
info.helpers=Ayudantes: {%0}
info.denied=
info.biome=Bioma: {%0}
info.notfound=

; El subcomando /p generate - slo puede ser utilizado por OPs o los jugadores con el permiso de myplot.command.generate
generate.name=generate
generate.alias=gen 
generate.desc=Genera un nuevo mundo de parcelas
generate.usage=/p generate 
generate.exists=Un mundo con nombre {%0} ya existe
generate.gexists=
generate.success=Se ha generado con xito el mundo de parcelas {%0}
generate.error=El mundo no se pudo generar

; El subcomando /p give
give.name=give 
give.desc=Darle su parcela a alguien 
give.usage=/p give [nombre]
give.notonline=El jugador no est en lnea 
give.maxedout=El jugador ha alcanzado el nmero mximo de parcelas
give.toself=No te puedes dar una parcela a ti mismo
give.confirm=Est seguro de que desea darle su parcela {%0} al jugador {%1}? Si es as, use /p {%1} confirm
give.success=Ha dado su parcela {0%} 
give.received={%0} te dio su parcela, {%1}

; El subcomando /p warp
warp.name=warp 
warp.desc=Teletransportarse a un terreno
warp.usage=/p warp [x;z]
warp.wrongid=
warp.notinplotworld=No ests en un mundo de terrenos
warp.unclaimed=No puedes teletransportarte a un terreno no reclamado
warp.success=Has sido teletransportado a la parcela {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleports the player to exact center of plot at ground level
middle.usage=/p mid
middle.success=Teleporting complete

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Sets the new owner of the plot without charging anything
setowner.usage=/p setowner <player: string>
setowner.maxplots=That player reached their plots limit of {%0}
setowner.success={%0} is now the owner of this plot

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Shows all plots a player has
list.usage=/p list [player: string]
list.found="Plot {%0} at ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.success=Pvp is now {%0} for the plot; Turkish language pack for MyPlot
; Created by Eren5960
; Updated time : 2/17/2019

; Popup when entering a plot
popup={%0} arsasna giri yaptn
popup.owner=Sahibi: {%0}
popup.available=Bu arsa sahipsiz. /p al komutu ile sahip olabilirsin.
popup.denied=Bu arsaya giriimin engellenmi.

; /p info
command.name=plot
command.alias=p
command.desc=Arsa alma ve ynetme komutlar.
command.usage=/p [help]
command.unknown=Bilinmeyen komut. /p yardim yazarak komutlar renebilirsin.

subcommand.usage=Kullanm: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Th! Bir eyler yanl gitti
notinplot=Bir arsa ierisinde durmuyorsun
notowner=Bu arsaya sahip deilsin
plugin.disabled=Bu eklenti aktif deil

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Yardm sayfasn grntler
help.usage=/p help [sayfa: say]
help.header=--- MyPlot Yardm Sayfas {%0}/{%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Arsana ortak ekler
addhelper.usage=/p addhelper <oyuncu: dizi>
addhelper.alreadyone={%0} zaten arsanda ortak
addhelper.success={%0} baaryla arsanda ortak oldu

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Arsandan ortak kaldr
removehelper.usage=/p removehelper <oyuncu: dizi>
removehelper.notone={%0} arsanda ortak deil
removehelper.success={%0} ortaklar arasndan kaldrld

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Oyuncunun arsana eriimini engeller
denyplayer.usage=/p deny <oyuncu: dizi>
denyplayer.helper={%0} oyuncusu bir ortak
denyplayer.alreadyone={%0} zaten bu arsadan engellendi
denyplayer.notaplayer=Oyuncu uan da aktif deil
denyplayer.cannotdeny={%0} oyuncusunun eriimi engellenemez
denyplayer.attempteddeny={%0} arsasna eriimini engellemeye alt
denyplayer.success1={%0} oyuncusunun arsana eriimi engellendi
denyplayer.success2="{%0};{%1} arsasna eriimin {%2} tarafndan engellendi"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Oyuncunun arsana eriim engelini kaldrr
undenyplayer.usage=/p undenyplayer <oyuncu: dizi>
undenyplayer.notone={%0} oyuncusunun eriim engeli zaten yok
undenyplayer.success1={%0} oyuncusunun eriim engeli kaldrld
undenyplayer.success2="{%0};{%1} arsasna eriim engelin {%2} tarafndan kaldrld"
undenyplayer.failure={%0} hl reddedildi

; The /p claim Subcommand
claim.name=claim
claim.desc=Arsaya sahip olursun
claim.usage=/p claim [isim: dizi]
claim.yourplot=Bu arsaya zaten sahipsin
claim.alreadyclaimed=Bu arsa zaten {%0} tarafndan alnm
claim.maxplots=Oyuncu bana {%0} arsa snrna ulatn
claim.nomoney=Bu arsay alabilmek iin yeterli paraya sahip deilsin
claim.success=Arsay baaryla aldn

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Rastgele bir arsaya nlar
auto.usage=/p auto [sahipsiz: mantksal] [isim: dizi]
auto.notplotworld=Arsa dnyasnda deilsin
auto.success="({%0};{%1}) arsas bulundu"
auto.noplots=Sahipsiz arsa bulunamad

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Arsan siler
dispose.usage=/p dispose
dispose.confirm={%0} arsasn silmek istediine emin misin? Eer onaylyorsan /p sil onay komutunu kullan
dispose.nomoney=Arsay silmek iin yeterli paraya sahip deilsin
dispose.success=Arsa silindi

; The /p reset Subcommand
reset.name=reset
reset.desc=Arsan siler ve temizler
reset.usage=/p reset
reset.confirm={%0} arsasn silmek istediine emin misin? Eer onaylyorsan /p sifirla onay komutunu kullan
reset.nomoney=Arsay sfrlamak iin yeterli paraya sahip deilsin
reset.success=Arsa sfrland

; The /p clear Subcommand
clear.name=clear
clear.desc=Arsan temizler
clear.usage=/p clear
clear.confirm={%0} arsasn silmek istediine emin misin? Eer onaylyorsan /p temizle onay komutunu kullan
clear.nomoney=Arsay temizlemek iin yeterli paraya sahip deilsin
clear.success=Arsa temizlendi

; The /p biome Subcommand
biome.name=biome
biome.desc=Arsann biomunu deitir
biome.usage=/p biome [biom: dizi]
biome.success=Arsa biomu {%0} olarak ayarland
biome.invalid=Setiiniz biom bulunamad
biome.possible=Olas biyomlar: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=Biom listesini grntler
biomes.usage=/p biomes
biomes.possible=Olas biomlar: {%0}

; The /p name Subcommand
name.name=name
name.desc=Arsann ismini ayarlar
name.usage=/p name <isim: dizi>
name.success=Arsa ismi {%0} olarak ayarland

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Arsa evini ziyaret eder
home.usage=/p home [id: say] [dnya: dizi]
home.noplots=Arsa dnyasnda deilsin
home.notexist="Bu dnyada {%0} ID'li bir ev noktas bulunamad"
home.success="{%1} dnyasndaki {%0} ID'li ev noktasna nlandn"
home.error=Ev noktas bulunamad

; The /p homes Subcommand
homes.name=homes
homes.desc=Sahip olduun evleri gsterir
homes.usage=/p homes [dnya: dizi]
homes.noplots=Hibir eve sahip deilsin
homes.header=Evler:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Arsa hakknda bilgileri grntler
info.usage=/p info [oyuncu: dizi] [plot says: say]
info.about={%0} arsas hakknda bilgiler
info.plotname=sim: {%0}
info.owner=Sahip: {%0}
info.helpers=Ortaklar: {%0}
info.denied=Yasakllar: {%0}
info.biome=Biom: {%0}
info.notfound=Arsa hakknda bilgi bulunamad

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Bir arsa dnyas olutur
generate.usage=/p generate <isim: dizi> [oluturucu ismi: dizi]
generate.exists={%0} isimli dnya zaten var
generate.gexists={%0} isimli oluturucu bulunamad
generate.success=Baaryla {%0} isimli arsa dnyas oluturuldu
generate.error=Dnya oluturulamad

; The /p give Subcommand
give.name=give
give.desc=Arsay baka bir oyuncuya devreder
give.usage=/p give [oyuncu: dizi]
give.notonline=Oyuncu uan da aktif deil
give.maxedout=Bu oyuncu azami {%0} saysna ulat
give.toself=Kendi arsan kendine aktaramazsn
give.confirm={%1} oyuncusuna {%0} arsan devretmek istediine emin misin? Eer onaylyorsan /p devret {%1} onay komutunu kullan
give.success=Arsan {%0} oyuncusuna devrettin
give.received={%0} oyuncusu arsasn sana devretti, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Bir plota nlar
warp.usage=/p warp <id: say> [dnya: dizi]
warp.wrongid="ID format X;Z eklinde olmaldr"
warp.notinplotworld=Arsa dnyasnda deilsin
warp.unclaimed=Hibir arsaya sahip deilsin
warp.success={%0} arsasna nlandn

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Bir arsann ortasna nlar
middle.usage=/p mid
middle.success=Inlandn

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Herhangi bir ey deitirmeden arsa sahibini ayarlar
setowner.usage=/p setowner <oyuncu: dizi>
setowner.maxplots=Bu oyuncu azami {%0} saysna ulat
setowner.success={%0} artk arsann yeni sahibi

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Oyuncuya ait arsalar listeler
list.usage=/p list [oyuncu: dizi]
list.found="({%1};{%2}) da ki {%0} arsas"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Arsadaki pvp durumunu ayarlar
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp zellii bu arsada aktif deil
pvp.success=Pvp durumu imdi: {%0}; Vietnamese language pack for MyPlot
; Created by QuangDo and Parroted
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Bn  vo plot {%0}
popup.owner=S hu bi {%0}
popup.available=Plot ny cha c ch! Dng /p claim
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=Nhn v qun l plot
command.usage = /plot <help|sub-cmd> [options]
command.unknown=Lnh khng r. Nhp /p help  xem cc lnh

subcommand.usage=Cch dng: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=! C g  khng n
notinplot=Bn ang khng ng trong mt plot
notowner=Bn khng phi l ch ca plot
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Xem danh sch tr gip
help.usage=/p help [page]
help.header=--- ang m trang hng dn {%0} of {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Thm ngi vo plot ca bn
addhelper.usage=/p addhelper <player>
addhelper.alreadyone={%0} hin  l helper ca plot ny ri
addhelper.success={%0}  tr thnh helper ca plot

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Khng cho ngi vo plot ca bn
removehelper.usage=/p removehelper <player>
removehelper.notone={%0} khng phi l helper ca plot
removehelper.success={%0} khng cn l helper ca plot

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Deny a player from accessing your plot
denyplayer.usage=/p deny <player: string>
denyplayer.helper={%0} is a helper
denyplayer.alreadyone={%0} has already been denied from this plot
denyplayer.cannotdeny={%0} cannot be denied
denyplayer.attempteddeny={%0} attempted to deny you from their plot
denyplayer.success1={%0} is now denied access to the plot
denyplayer.success2="You were denied access to plot {%0};{%1} by {%2}"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Undeny a player from accessing your plot
undenyplayer.usage=/p undeny <player: string>
undenyplayer.notone={%0} is allowed already
undenyplayer.notaplayer=That player is not online right now
undenyplayer.success1={%0} has been allowed into the plot
undenyplayer.success2="You were allowed access to plot {%0};{%1} by {%2}"
undenyplayer.failure={%0} is still denied

; The /p claim Subcommand
claim.name=claim
claim.desc=Mua plot bn ang ng
claim.usage=/p claim [name]
claim.yourplot=y  l plot ca bn
claim.alreadyclaimed=Plot  c ch {%0}
claim.maxplots=Bn  s hu ti a {%0} plot
claim.nomoney=Bn khng  tin  mua plot ny
claim.success= mua plot

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=i n plot trng
auto.usage=/p auto
auto.notplotworld=Bn ang  ngoi world plot
auto.success= i n ({%0}, {%1})
auto.noplots=Khng c plot trng no  quanh y

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=B hn plot ca bn
dispose.usage=/p dispose
dispose.confirm=Bn c chc mun b plot {%0} ? Nu chc dng /p dispose confirm
dispose.nomoney=Bn khng  tin  b plot
dispose.success=Plot  b b

; The /p reset Subcommand
reset.name=reset
reset.desc=B v xa plot ca bn
reset.usage=/p reset
reset.confirm=Bn c chc mun b v xa plot {%0} ? Nu chc dng /p reset confirm
reset.nomoney=Bn khng  tin  b v xa plot
reset.success=Plot  b b v xa

; The /p clear Subcommand
clear.name=clear
clear.desc=Xa plot ca bn
clear.usage=/p clear
clear.confirm=Bn c chc mun xa plot {%0} ? Nu chc dng /p clear confirm
clear.nomoney=Bn khng  tin  xa plot
clear.success=Plot  b xa

; The /p biome Subcommand
biome.name=biome
biome.desc=i h sinh thi trong plot ca bn
biome.usage=/p biome [biome]
biome.success=H sinh thi ca plot i thnh {%0}
biome.invalid=Khng c h sinh thi 
biome.possible=Nhng h sinh thi ang c: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; The /p name Subcommand
name.name=name
name.desc=t hoc i tn cho plot ca bn
name.usage=/p name <name>
name.success=Tn ca plot c i thnh: {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=i v plot ca bn
home.usage=/p home [number]
home.noplots=Bn ang khng c plot no
home.notexist=Bn khng s hu plot s {%0} 
home.success=ang i n plot {%0}
home.error=Khng th i n plot

; The /p homes Subcommand
homes.name=homes
homes.desc=Danh sch plot ca bn
homes.usage=/p homes
homes.noplots=Bn khng s hu plot no
homes.header=Plots ca bn:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Xem thng tin v plot
info.usage=/p info
info.about=Thng tin v {%0}
info.plotname=Tn: {%0}
info.owner=Ch: {%0}
info.helpers=Ngi gip: {%0}
info.denied=
info.biome=H sinh thi: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=To ra mt world plot mi
generate.usage=/p generate <name>
generate.exists=World c tn {%0}  c sn
generate.gexists=
generate.success= to ra world plot {%0} thnh cng
generate.error=World khng th to ra c

; The /p give Subcommand
give.name=give
give.desc=Cho plot ca mnh cho ngi khc
give.usage=/p give [name]
give.notonline=Ngi chi  khng online
give.maxedout=Ngi chi   c  s plot cho php
give.toself=Bn khng th gi cho chnh mnh
give.confirm=Bn chc bn mun gi plot {%0} cho {%1}? Nu c, dng /p give {%1} confirm
give.success=Bn  gi plot cho {%0} thnh cng
give.received={%0}  cho bn plot ca h, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Di chuyn ti plot
warp.usage=/p warp <id>
warp.wrongid=M plot phi theo dng X;Z
warp.notinplotworld=Bn ang khng  trong world plot
warp.unclaimed=Bn khng th di chuyn ti plot cha c mua
warp.success=Bn ang di chuyn n plot {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=
middle.usage=/p mid
middle.success=

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=
setowner.usage=/p setowner <>
setowner.maxplots=
setowner.success=

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=
list.usage=/p list []
list.found=

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=/p pvp
pvp.world=
pvp.plot=
pvp.success=; Chinese(ROC) language pack for MyPlot
; Created by jerryzooyoyo
; Updated time : 2/17/2019

; Popup when entering a plot
popup= {%0}
popup.owner= {%0}
popup.available=!  /p claim 
popup.denied=,!

; /p info
command.name=plot
command.alias=p
command.desc=
command.usage=/p <help|> []
command.unknown=, /p help 

subcommand.usage=: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=!!
notinplot=,
notowner=,
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=
help.usage=/p help []
help.header=------ (/p!) {%0} / {%1} ------

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=( addh )
addhelper.usage=/p addh <>
addhelper.alreadyone={%0} !
addhelper.success={%0} 

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=( delh )
removehelper.usage=/p delh <>
removehelper.notone={%0} 
removehelper.success={%0} 

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper={%0} ,!
denyplayer.alreadyone={%0} !
denyplayer.cannotdeny={%0} !
denyplayer.attempteddeny={%0} !
denyplayer.success1={%0} 
denyplayer.success2= {%2} !: {%0};{%1}

; The /p undenyplayer Subcommand
undenyplayer.name=undeny
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone={%0} !
undenyplayer.notaplayer=
undenyplayer.success1={%0} 
undenyplayer.success2= {%2}  {%0};{%1} !
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=
claim.usage=/p claim [,]
claim.yourplot=
claim.alreadyclaimed=! {%0}
claim.maxplots=! {%0} 
claim.nomoney=,
claim.success=,!

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=,
auto.usage=/p auto ( a )
auto.notplotworld=,
auto.success= ({%0}, {%1})
auto.noplots=~

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=,
dispose.usage=/p dispose
dispose.confirm= {%0} ? , /p dispose confirm
dispose.nomoney=,
dispose.success=

; The /p reset Subcommand
reset.name=reset
reset.desc=,
reset.usage=/p reset
reset.confirm= {%0} ? , /p reset confirm
reset.nomoney=,
reset.success=

; The /p clear Subcommand
clear.name=clear
clear.desc=,
clear.usage=/p clear
clear.confirm= {%0} ? , /p clear confirm
clear.nomoney=,
clear.success=

; The /p biome Subcommand
biome.name=biome
biome.desc=
biome.usage=/p biome []
biome.success= {%0}
biome.invalid=!
biome.possible=: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=
biomes.usage=/p biomes
biomes.possible=: {%0}

; The /p name Subcommand
name.name=name
name.desc=
name.usage=/p name <>
name.success= {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=( h )
home.usage=/p home []
home.noplots=
home.notexist= {%0} ! /p homes 
home.success= {%0}
home.error=,

; The /p homes Subcommand
homes.name=homes
homes.desc=
homes.usage=/p homes
homes.noplots=
homes.header=:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=( i )
info.usage=/p info
info.about= {%0} 
info.plotname=: {%0}
info.owner=: {%0}
info.helpers=: {%0}
info.denied=
info.biome=: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=
generate.usage=/p g <>
generate.exists= {%0} 
generate.gexists=
generate.success= {%0}
generate.error=,

; The /p give Subcommand
give.name=give
give.desc=
give.usage=/p give <>
give.notonline=,
give.maxedout=,
give.toself=
give.confirm= {%0}  {%1} ? , /p give {%1} confirm
give.success= {%0}
give.received={%0} , {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=
warp.usage=/p warp <>
warp.wrongid= X;Z 
warp.notinplotworld=,
warp.unclaimed=
warp.success= {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=
middle.usage=/p mid
middle.success=

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=
setowner.usage=/p setowner <>
setowner.maxplots=!: {%0}
setowner.success={%0} 

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=
list.usage=/p list <>
list.found=" {%0}  ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=/p pvp
pvp.world=
pvp.plot=
pvp.success=<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotClearEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;
	/** @var int $maxBlocksPerTick */
	private $maxBlocksPerTick = 256;

	/**
	 * MyPlotClearEvent constructor.
	 *
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 */
	public function __construct(Plot $plot, int $maxBlocksPerTick = 256) {
		$this->maxBlocksPerTick = $maxBlocksPerTick;
		parent::__construct($plot);
	}

	/**
	 * @return int
	 */
	public function getMaxBlocksPerTick() : int {
		return $this->maxBlocksPerTick;
	}

	/**
	 * @param int $maxBlocksPerTick
	 */
	public function setMaxBlocksPerTick(int $maxBlocksPerTick) : void {
		$this->maxBlocksPerTick = $maxBlocksPerTick;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\IPlayer;

class MyPlotDenyEvent extends MyPlotPlotEvent implements Cancellable {
	const ADD = 0;
	const REMOVE = 1;
	public static $handlerList = null;
	/** @var int $type */
	private $type;
	/** @var string $player */
	private $player;

	/**
	 * MyPlotDenyEvent constructor.
	 *
	 * @param Plot $plot
	 * @param int $type
	 * @param string $player
	 */
	public function __construct(Plot $plot, int $type, string $player) {
		$this->type = $type;
		$this->player = $player;
		parent::__construct($plot);
	}

	/**
	 * @return int
	 */
	public function getType() : int {
		return $this->type;
	}

	/**
	 * @param int $type
	 */
	public function setType(int $type) : void {
		$this->type = $type;
	}

	/**
	 * @return string
	 */
	public function getDenied() : string {
		return $this->player;
	}

	/**
	 * @param IPlayer|string $player
	 */
	public function setDenied($player) : void {
		if($player instanceof IPlayer) {
			$this->player = $player->getName();
		}elseif(is_string($player)) {
			$this->player = $player;
		}
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotDisposeEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;

	/**
	 * MyPlotClearEvent constructor.
	 *
	 * @param Plot $plot
	 */
	public function __construct(Plot $plot) {
		parent::__construct($plot);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use pocketmine\event\Cancellable;
use pocketmine\event\Event;

class MyPlotGenerationEvent extends Event implements Cancellable {
	/** @var string $levelName */
	private $levelName;
	/** @var string $generator */
	private $generator = "myplot";
	/** @var array $settings */
	private $settings = [];

	public function __construct(string $levelName, string $generator = "myplot", array $settings = []) {
		$this->levelName = $levelName;
		$this->generator = $generator;
		$this->settings = $settings;
	}

	/**
	 * @return string
	 */
	public function getLevelName() : string {
		return $this->levelName;
	}

	/**
	 * @param string $levelName
	 */
	public function setLevelName(string $levelName) : void {
		$this->levelName = $levelName;
	}

	/**
	 * @return string
	 */
	public function getGenerator() : string {
		return $this->generator;
	}

	/**
	 * @param string $generator
	 */
	public function setGenerator(string $generator) : void {
		$this->generator = $generator;
	}

	/**
	 * @return array
	 */
	public function getSettings() : array {
		return $this->settings;
	}

	/**
	 * @param array $settings
	 */
	public function setSettings(array $settings) : void {
		$this->settings = $settings;
		$this->settings["preset"] = json_encode($settings);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\Player;

class MyPlotPvpEvent extends MyPlotPlotEvent implements Cancellable {
	/** @var Player $attacker */
	private $attacker;
	/** @var Player $damaged */
	private $damaged;
	/** @var EntityDamageByEntityEvent|null $event */
	private $event;

	public function __construct(Plot $plot, Player $attacker, Player $damaged, ?EntityDamageByEntityEvent $event = null) {
		$this->attacker = $attacker;
		$this->damaged = $damaged;
		$this->event = $event;
		parent::__construct($plot);
	}

	/**
	 * @return Player
	 */
	public function getAttacker() : Player {
		return $this->attacker;
	}

	/**
	 * @return Player
	 */
	public function getDamaged() : Player {
		return $this->damaged;
	}

	/**
	 * @return EntityDamageByEntityEvent|null
	 */
	public function getEvent() : ?EntityDamageByEntityEvent {
		return $this->event;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotResetEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;

	/**
	 * MyPlotClearEvent constructor.
	 *
	 * @param Plot $plot
	 */
	public function __construct(Plot $plot) {
		parent::__construct($plot);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotSaveEvent extends MyPlotPlotEvent implements Cancellable {
	const SQLITE3 = 0;
	const MySQL = 1;
	const JSON = 2;
	const YAML = 3;
	const OTHER = -1;
	public static $handlerList = null;
	/** @var int $type */
	private $type;

	public function __construct(int $type, Plot $plot) {
		$this->type = $type;
		parent::__construct($plot);
	}

	/**
	 * @return int
	 */
	public function getSaveType() : int {
		return $this->type;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotSettingEvent extends MyPlotPlotEvent implements Cancellable {
	/** @var Plot $newPlot */
	private $oldPlot;

	public function __construct(Plot $oldPlot, Plot $newPlot) {
		$this->oldPlot = $oldPlot;
		parent::__construct($newPlot);
	}

	/**
	 * @return Plot
	 */
	public function getOldPlot() : Plot {
		return $this->oldPlot;
	}

	/**
	 * @param Plot $oldPlot
	 */
	public function setOldPlot(Plot $oldPlot) : void {
		$this->oldPlot = $oldPlot;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use EssentialsPE\Loader;
use pocketmine\Player;

class EssentialsPEProvider implements EconomyProvider {
	/** @var Loader $plugin */
	private $plugin;

	/**
	 * EssentialsPEProvider constructor.
	 *
	 * @param Loader $plugin
	 */
	public function __construct(Loader $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool {
		if($amount === 0) {
			return true;
		}elseif($amount < 0) {
			$amount = -$amount;
		}
		$pre = $this->plugin->getAPI()->getPlayerBalance($player);
		$this->plugin->getAPI()->addToPlayerBalance($player, (int) -$amount);
		if($this->plugin->getAPI()->getPlayerBalance($player) == $pre - (int) $amount) {
			$this->plugin->getLogger()->debug("MyPlot reduced money of ".$player->getName());
			return true;
		}
		$this->plugin->getLogger()->debug("MyPlot failed to reduce money of ".$player->getName());
		return false;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;
use pocketmine\utils\Config;

class JSONDataProvider extends DataProvider {
	/** @var MyPlot $plugin */
	protected $plugin;
	/** @var Config $json */
	private $json;

	/**
	 * JSONDataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		parent::__construct($plugin, $cacheSize);
		$this->json = new Config($this->plugin->getDataFolder() . "Data" . DIRECTORY_SEPARATOR . "plots.yml", Config::JSON, ["count" => 0, "plots" => []]);
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$plots = $this->json->get("plots", []);
		$plots[$plot->id] = ["level" => $plot->levelName, "x" => $plot->X, "z" => $plot->Z, "name" => $plot->name, "owner" => $plot->owner, "helpers" => $plot->helpers, "denied" => $plot->denied, "biome" => $plot->biome];
		$this->json->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->json->save();
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		$plots = $this->json->get("plots", []);
		unset($plots[$plot->id]);
		$this->json->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->json->save();
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) !== null) {
			return $plot;
		}
		$plots = $this->json->get("plots", []);
		$levelKeys = array_keys($plots, $levelName);
		$xKeys = array_keys($plots, $X);
		$zKeys = array_keys($plots, $Z);
		/** @var int|null $key */
		$key = null;
		foreach($levelKeys as $levelKey) {
			foreach($xKeys as $xKey) {
				foreach($zKeys as $zKey) {
					if($zKey == $xKey and $xKey == $levelKey and $zKey == $levelKey) {
						$key = $levelKey;
						break 3;
					}
				}
			}
		}
		if($key != null) {
			$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
			$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
			$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
			$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
			$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
			$pvp = $plot[$key]["pvp"] == null ? false : $plot[$key]["pvp"];
			return new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
		}
		$count = $this->json->get("count", 0);
		$this->json->set("count", (int) $count++);
		$this->json->save();
		return new Plot($levelName, $X, $Z, "", "", [], [], "PLAINS", (int) $count);
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		$plots = $this->json->get("plots", []);
		$ownerPlots = [];
		if($levelName != "") {
			$levelKeys = array_keys($plots, $levelName);
			$ownerKeys = array_keys($plots, $owner);
			foreach($levelKeys as $levelKey) {
				foreach($ownerKeys as $ownerKey) {
					if($levelKey == $ownerKey) {
						$X = $plots[$levelKey]["x"];
						$Z = $plots[$levelKey]["z"];
						$plotName = $plots[$levelKey]["name"] == "" ? "" : $plots[$levelKey]["name"];
						$owner = $plots[$levelKey]["owner"] == "" ? "" : $plots[$levelKey]["owner"];
						$helpers = $plots[$levelKey]["helpers"] == [] ? [] : $plots[$levelKey]["helpers"];
						$denied = $plots[$levelKey]["denied"] == [] ? [] : $plots[$levelKey]["denied"];
						$biome = strtoupper($plots[$levelKey]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$levelKey]["biome"]);
						$pvp = $plots[$levelKey]["pvp"] == null ? false : $plots[$levelKey]["pvp"];
						$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $levelKey);
					}
				}
			}
		}else{
			$ownerKeys = array_keys($plots, $owner);
			foreach($ownerKeys as $key) {
				$levelName = $plots[$key]["level"];
				$X = $plots[$key]["x"];
				$Z = $plots[$key]["z"];
				$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
				$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
				$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
				$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
				$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
				$pvp = $plots[$key]["pvp"] == null ? false : $plots[$key]["pvp"];
				$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
			}
		}
		return $ownerPlots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		$plotsArr = $this->json->get("plots", []);
		for($i = 0; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$existing = [];
			foreach($plotsArr as $id => $data) {
				if($data["level"] === $levelName) {
					if(abs($data["x"]) === $i and abs($data["z"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}elseif(abs($data["z"]) === $i and abs($data["x"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}
				}
			}
			$plots = [];
			foreach($existing as $XZ) {
				$plots[$XZ[0]][$XZ[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		$this->json->save();
		unset($this->json);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;

class MySQLProvider extends DataProvider {
	/** @var MyPlot $plugin */
	protected $plugin;
	/** @var \mysqli $db */
	private $db;
	/** @var array $settings */
	private $settings;
	/** @var \mysqli_stmt */
	private $sqlGetPlot, $sqlSavePlot, $sqlSavePlotById, $sqlRemovePlot, $sqlRemovePlotById, $sqlGetPlotsByOwner, $sqlGetPlotsByOwnerAndLevel, $sqlGetExistingXZ;

	/**
	 * MySQLProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 * @param array $settings
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0, array $settings = []) {
		ini_set("mysqli.reconnect", "1");
		ini_set('mysqli.allow_persistent', "1");
		ini_set('mysql.connect_timeout', "300");
		ini_set('default_socket_timeout', "300");
		$this->plugin = $plugin;
		parent::__construct($plugin, $cacheSize);
		$this->settings = $settings;
		$this->db = new \mysqli($settings['Host'], $settings['Username'], $settings['Password'], $settings['DatabaseName'], $settings['Port']);
		$this->db->query("CREATE TABLE IF NOT EXISTS plots (id INT PRIMARY KEY AUTO_INCREMENT, level TEXT, X INT, Z INT, name TEXT, owner TEXT, helpers TEXT, denied TEXT, biome TEXT, pvp INT);");
		try{
			$this->db->query("ALTER TABLE plots ADD COLUMN pvp INT AFTER biome;");
		}catch(\Exception $e) {
			// do nothing :P
		}
		$this->prepare();
		$this->plugin->getLogger()->debug("MySQL data provider registered");
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$this->reconnect();
		$helpers = implode(',', $plot->helpers);
		$denied = implode(',', $plot->denied);
		if($plot->id >= 0) {
			$stmt = $this->sqlSavePlotById;
			$stmt->bind_param('isiisssssi', $plot->id, $plot->levelName, $plot->X, $plot->Z, $plot->name, $plot->owner, $helpers, $denied, $plot->biome, $plot->pvp);
		}else{
			$stmt = $this->sqlSavePlot;
			$stmt->bind_param('siisiisssssi', $plot->levelName, $plot->X, $plot->Z, $plot->levelName, $plot->X, $plot->Z, $plot->name, $plot->owner, $helpers, $denied, $plot->biome, $plot->pvp);
		}
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return false;
		}
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		$this->reconnect();
		if($plot->id >= 0) {
			$stmt = $this->sqlRemovePlot;
			$stmt->bind_param('i', $plot->id);
		}else{
			$stmt = $this->sqlRemovePlotById;
			$stmt->bind_param('sii', $plot->levelName, $plot->X, $plot->Z);
		}
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return false;
		}
		$plot = new Plot($plot->levelName, $plot->X, $plot->Z);
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		$this->reconnect();
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) != null) {
			return $plot;
		}
		$stmt = $this->sqlGetPlot;
		$stmt->bind_param('sii', $levelName, $X, $Z);
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return null;
		}
		$result = $stmt->get_result();
		if($val = $result->fetch_array(MYSQLI_ASSOC)) {
			if(empty($val["helpers"])) {
				$helpers = [];
			}else{
				$helpers = explode(",", (string) $val["helpers"]);
			}
			if(empty($val["denied"])) {
				$denied = [];
			}else{
				$denied = explode(",", (string) $val["denied"]);
			}
			$plot = new Plot($levelName, $X, $Z, (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}else{
			$plot = new Plot($levelName, $X, $Z);
		}
		$this->cachePlot($plot);
		return $plot;
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return array
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		$this->reconnect();
		if(empty($levelName)) {
			$stmt = $this->sqlGetPlotsByOwner;
			$stmt->bind_param('s', $owner);
		}else{
			$stmt = $this->sqlGetPlotsByOwnerAndLevel;
			$stmt->bind_param('ss', $owner, $levelName);
		}
		$plots = [];
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return $plots;
		}
		$result = $stmt->get_result();
		while($val = $result->fetch_array()) {
			$helpers = explode(",", (string) $val["helpers"]);
			$denied = explode(",", (string) $val["denied"]);
			$plots[] = new Plot((string) $val["level"], (int) $val["X"], (int) $val["Z"], (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}
		// Remove unloaded plots
		$plots = array_filter($plots, function($plot) {
			return $this->plugin->isLevelLoaded($plot->levelName);
		});
		// Sort plots by level
		usort($plots, function($plot1, $plot2) {
			return strcmp($plot1->levelName, $plot2->levelName);
		});
		return $plots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		$this->reconnect();
		$i = 0;
		for(; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$stmt = $this->sqlGetExistingXZ;
			$stmt->bind_param('siiii', $levelName, $i, $i, $i, $i);
			$result = $stmt->execute();
			if($result === false) {
				$this->plugin->getLogger()->error($stmt->error);
				continue;
			}
			$result = $stmt->get_result();
			$plots = [];
			while($val = $result->fetch_array(MYSQLI_NUM)) {
				$plots[$val[0]][$val[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		if($this->db->close())
			$this->plugin->getLogger()->debug("MySQL database closed!");
	}

	/**
	 * @return bool
	 */
	private function reconnect() : bool {
		if(!$this->db->ping()) {
			$this->plugin->getLogger()->error("The MySQL server can not be reached! Trying to reconnect!");
			$this->close();
			$this->db->connect($this->settings['Host'], $this->settings['Username'], $this->settings['Password'], $this->settings['DatabaseName'], $this->settings['Port']);
			$this->prepare();
			if($this->db->ping()) {
				$this->plugin->getLogger()->notice("The MySQL connection has been re-established!");
				return true;
			}else{
				$this->plugin->getLogger()->critical("The MySQL connection could not be re-established!");
				$this->plugin->getLogger()->critical("Closing level to prevent griefing!");
				foreach($this->plugin->getPlotLevels() as $levelName => $settings) {
					$level = $this->plugin->getServer()->getLevelByName($levelName);
					$level->save(); // don't force in case owner doesn't want it saved
					$level->unload(true); // force unload to prevent possible griefing
				}
				if($this->plugin->getConfig()->getNested("MySQLSettings.ShutdownOnFailure", false)) {
					$this->plugin->getServer()->shutdown();
				}
				return false;
			}
		}
		return true;
	}

	private function prepare() : void {
		$this->sqlGetPlot = $this->db->prepare("SELECT id, name, owner, helpers, denied, biome FROM plots WHERE level = ? AND X = ? AND Z = ?;");
		$this->sqlSavePlot = $this->db->prepare("INSERT INTO plots (`id`, `level`, `X`, `Z`, `name`, `owner`, `helpers`, `denied`, `biome`, `pvp`) VALUES((SELECT id FROM plots p WHERE p.level = ? AND X = ? AND Z = ?),?,?,?,?,?,?,?,?,?) ON DUPLICATE KEY UPDATE name = VALUES(name), owner = VALUES(owner), helpers = VALUES(helpers), denied = VALUES(denied), biome = VALUES(biome), pvp = VALUES(pvp);");
		$this->sqlSavePlotById = $this->db->prepare("UPDATE plots SET id = ?, level = ?, X = ?, Z = ?, name = ?, owner = ?, helpers = ?, denied = ?, biome = ?, pvp = ? WHERE id = VALUES(id);");
		$this->sqlRemovePlot = $this->db->prepare("DELETE FROM plots WHERE id = ?;");
		$this->sqlRemovePlotById = $this->db->prepare("DELETE FROM plots WHERE level = ? AND X = ? AND Z = ?;");
		$this->sqlGetPlotsByOwner = $this->db->prepare("SELECT * FROM plots WHERE owner = ?;");
		$this->sqlGetPlotsByOwnerAndLevel = $this->db->prepare("SELECT * FROM plots WHERE owner = ? AND level = ?;");
		$this->sqlGetExistingXZ = $this->db->prepare("SELECT X, Z FROM plots WHERE (level = ? AND ((abs(X) = ? AND abs(Z) <= ?) OR (abs(Z) = ? AND abs(X) <= ?)));");
	}
}
<?php
declare(strict_types=1);
namespace MyPlot\provider;

use pocketmine\Player;
use PocketMoney\PocketMoney;

class PocketMoneyProvider implements EconomyProvider
{
	/** @var PocketMoney $plugin */
	private $plugin;

	/**
	 * PocketMoneyProvider constructor.
	 *
	 * @param PocketMoney $plugin
	 */
	public function __construct(PocketMoney $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool {
		if($amount === 0) {
			return true;
		}elseif($amount < 0) {
			$amount = -$amount;
		}
		$money = $this->plugin->getMoney($player->getName());
		if($money === false or ($money - $amount) < 0) {
			return false;
		}
		if($this->plugin->setMoney($player->getName(), $money - $amount)) {
			$this->plugin->getLogger()->debug("MyPlot reduced money of " . $player->getName());
			return true;
		}
		$this->plugin->getLogger()->debug("MyPlot failed to reduce money of " . $player->getName());
		return false;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;
use pocketmine\utils\Config;

class YAMLDataProvider extends DataProvider {
	/** @var MyPlot $plugin */
	protected $plugin;
	/** @var Config $yaml */
	private $yaml;

	/**
	 * YAMLDataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		parent::__construct($plugin, $cacheSize);
		$this->yaml = new Config($this->plugin->getDataFolder() . "Data" . DIRECTORY_SEPARATOR . "plots.yml", Config::YAML, ["count" => 0, "plots" => []]);
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$plots = $this->yaml->get("plots", []);
		$plots[$plot->id] = ["level" => $plot->levelName, "x" => $plot->X, "z" => $plot->Z, "name" => $plot->name, "owner" => $plot->owner, "helpers" => $plot->helpers, "denied" => $plot->denied, "biome" => $plot->biome, "pvp" => $plot->pvp];
		$this->yaml->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->yaml->save();
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		$plots = $this->yaml->get("plots", []);
		unset($plots[$plot->id]);
		$this->yaml->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->yaml->save();
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) !== null) {
			return $plot;
		}
		$plots = $this->yaml->get("plots");
		$levelKeys = array_keys($plots, $levelName);
		$xKeys = array_keys($plots, $X);
		$zKeys = array_keys($plots, $Z);
		/** @var int|null $key */
		$key = null;
		foreach($levelKeys as $levelKey) {
			foreach($xKeys as $xKey) {
				foreach($zKeys as $zKey) {
					if($zKey == $xKey and $xKey == $levelKey and $zKey == $levelKey) {
						$key = $levelKey;
						break 3;
					}
				}
			}
		}
		if($key != null) {
			$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
			$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
			$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
			$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
			$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
			$pvp = $plot[$key]["pvp"] == null ? false : $plot[$key]["pvp"];
			return new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
		}
		$count = $this->yaml->get("count", 0);
		$this->yaml->set("count", (int) $count++);
		$this->yaml->save();
		return new Plot($levelName, $X, $Z, "", "", [], [], "PLAINS", true, (int) $count);
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		$plots = $this->yaml->get("plots", []);
		$ownerPlots = [];
		if($levelName != "") {
			$levelKeys = array_keys($plots, $levelName);
			$ownerKeys = array_keys($plots, $owner);
			foreach($levelKeys as $levelKey) {
				foreach($ownerKeys as $ownerKey) {
					if($levelKey == $ownerKey) {
						$X = $plots[$levelKey]["x"];
						$Z = $plots[$levelKey]["z"];
						$plotName = $plots[$levelKey]["name"] == "" ? "" : $plots[$levelKey]["name"];
						$owner = $plots[$levelKey]["owner"] == "" ? "" : $plots[$levelKey]["owner"];
						$helpers = $plots[$levelKey]["helpers"] == [] ? [] : $plots[$levelKey]["helpers"];
						$denied = $plots[$levelKey]["denied"] == [] ? [] : $plots[$levelKey]["denied"];
						$biome = strtoupper($plots[$levelKey]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$levelKey]["biome"]);
						$pvp = $plots[$levelKey]["pvp"] == null ? false : $plots[$levelKey]["pvp"];
						$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $levelKey);
					}
				}
			}
		}else{
			$ownerKeys = array_keys($plots, $owner);
			foreach($ownerKeys as $key) {
				$levelName = $plots[$key]["level"];
				$X = $plots[$key]["x"];
				$Z = $plots[$key]["z"];
				$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
				$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
				$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
				$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
				$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
				$pvp = $plots[$key]["pvp"] == null ? false : $plots[$key]["pvp"];
				$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
			}
		}
		return $ownerPlots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?plot {
		$plotsArr = $this->yaml->get("plots", []);
		for($i = 0; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$existing = [];
			foreach($plotsArr as $id => $data) {
				if($data["level"] === $levelName) {
					if(abs($data["x"]) === $i and abs($data["z"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}elseif(abs($data["z"]) === $i and abs($data["x"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}
				}
			}
			$plots = [];
			foreach($existing as $arr) {
				$plots[$arr[0]][$arr[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		unset($this->yaml);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\task;

use MyPlot\MyPlot;
use MyPlot\Plot;
use pocketmine\block\Block;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\scheduler\Task;

class ClearPlotTask extends Task {
	/** @var MyPlot $plugin */
	private $plugin;
	private $plot, $level, $height, $bottomBlock, $plotFillBlock, $plotFloorBlock, $plotBeginPos, $xMax, $zMax, $maxBlocksPerTick, $pos;

	/**
	 * ClearPlotTask constructor.
	 *
	 * @param MyPlot $plugin
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 */
	public function __construct(MyPlot $plugin, Plot $plot, int $maxBlocksPerTick = 256) {
		$this->plugin = $plugin;
		$this->plot = $plot;
		$this->plotBeginPos = $plugin->getPlotPosition($plot);
		$this->level = $this->plotBeginPos->getLevel();
		$plotLevel = $plugin->getLevelSettings($plot->levelName);
		$plotSize = $plotLevel->plotSize;
		$this->xMax = $this->plotBeginPos->x + $plotSize;
		$this->zMax = $this->plotBeginPos->z + $plotSize;
		$this->height = $plotLevel->groundHeight;
		$this->bottomBlock = $plotLevel->bottomBlock;
		$this->plotFillBlock = $plotLevel->plotFillBlock;
		$this->plotFloorBlock = $plotLevel->plotFloorBlock;
		$this->maxBlocksPerTick = $maxBlocksPerTick;
		$this->pos = new Vector3($this->plotBeginPos->x, 0, $this->plotBeginPos->z);
		$this->plugin = $plugin;
		$plugin->getLogger()->debug("Clear Task started at plot {$plot->X};{$plot->Z}");
	}

	/**
	 * @param int $currentTick
	 */
	public function onRun(int $currentTick) : void {
		foreach($this->level->getEntities() as $entity) {
			if($this->plugin->getPlotBB($this->plot)->isVectorInXZ($entity)) {
				if(!$entity instanceof Player) {
					$entity->flagForDespawn();
				}else{
					$this->plugin->teleportPlayerToPlot($entity, $this->plot);
				}
			}
		}
		$blocks = 0;
		while($this->pos->x < $this->xMax) {
			while($this->pos->z < $this->zMax) {
				while($this->pos->y < $this->level->getWorldHeight()) {
					if($this->pos->y === 0) {
						$block = $this->bottomBlock;
					}elseif($this->pos->y < $this->height) {
						$block = $this->plotFillBlock;
					}elseif($this->pos->y === $this->height) {
						$block = $this->plotFloorBlock;
					}else{
						$block = Block::get(0);
					}
					$this->level->setBlock($this->pos, $block, false, false);
					$blocks++;
					if($blocks >= $this->maxBlocksPerTick) {
						$this->plugin->getScheduler()->scheduleDelayedTask($this, 1);
						return;
					}
					$this->pos->y++;
				}
				$this->pos->y = 0;
				$this->pos->z++;
			}
			$this->pos->z = $this->plotBeginPos->z;
			$this->pos->x++;
		}
		foreach($this->level->getTiles() as $tile) {
			if(($plot = $this->plugin->getPlotByPosition($tile)) != null) {
				if($plot->X === $this->plot->X and $plot->Z === $this->plot->Z) {
					$tile->close();
				}
			}
		}
		$this->plugin->getLogger()->debug("Clear task completed at {$this->plotBeginPos->x};{$this->plotBeginPos->z}");
	}
}{"MyPlot\\libs\\spoondetector":{"name":"SpoonDetector","version":"0.0.0","antigen":"spoondetector","api":["2.0.0","3.0.0-ALPHA1","3.0.0-ALPHA2","3.0.0-ALPHA3","3.0.0-ALPHA4","3.0.0-ALPHA5"],"php":[7],"author":"Falk","build":{"builder":"PoggitCI\/1.0-beta poggit-virion\/1.0","buildTime":"2017-05-30T23:37:02+0000","poggitBuildId":23779,"projectBuildNumber":4,"class":"Dev"}}}