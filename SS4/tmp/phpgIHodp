<?php
declare(strict_types=1);
namespace MyPlot;

use EssentialsPE\Loader;
use MyPlot\events\MyPlotClearEvent;
use MyPlot\events\MyPlotDisposeEvent;
use MyPlot\events\MyPlotGenerationEvent;
use MyPlot\events\MyPlotResetEvent;
use MyPlot\events\MyPlotSettingEvent;
use MyPlot\events\MyPlotTeleportEvent;
use MyPlot\provider\DataProvider;
use MyPlot\provider\EconomyProvider;
use MyPlot\provider\EconomySProvider;
use MyPlot\provider\EssentialsPEProvider;
use MyPlot\provider\JSONDataProvider;
use MyPlot\provider\MySQLProvider;
use MyPlot\provider\PocketMoneyProvider;
use MyPlot\provider\SQLiteDataProvider;
use MyPlot\provider\YAMLDataProvider;
use MyPlot\task\ClearPlotTask;
use onebone\economyapi\EconomyAPI;
use pocketmine\event\level\LevelLoadEvent;
use pocketmine\lang\BaseLang;
use pocketmine\level\biome\Biome;
use pocketmine\level\format\Chunk;
use pocketmine\level\generator\GeneratorManager;
use pocketmine\level\Level;
use pocketmine\level\Position;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\permission\Permission;
use pocketmine\permission\PermissionManager;
use pocketmine\Player;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\Config;
use pocketmine\utils\TextFormat as TF;
use PocketMoney\PocketMoney;
use MyPlot\libs\spoondetector\SpoonDetector;

class MyPlot extends PluginBase
{
	/** @var MyPlot $instance */
	private static $instance;
	/** @var PlotLevelSettings[] $levels */
	private $levels = [];
	/** @var DataProvider $dataProvider */
	private $dataProvider = null;
	/** @var EconomyProvider $economyProvider */
	private $economyProvider = null;
	/** @var BaseLang $baseLang */
	private $baseLang = null;

	/**
	 * @return MyPlot
	 */
	public static function getInstance() : self {
		return self::$instance;
	}

	/**
	 * Returns the Multi-lang management class
	 *
	 * @api
	 *
	 * @return BaseLang
	 */
	public function getLanguage() : BaseLang {
		return $this->baseLang;
	}

	/**
	 * Returns the DataProvider that is being used
	 *
	 * @api
	 *
	 * @return DataProvider
	 */
	public function getProvider() : DataProvider {
		return $this->dataProvider;
	}

	/**
	 * Returns the EconomyProvider that is being used
	 *
	 * @api
	 *
	 * @return EconomyProvider|null
	 */
	public function getEconomyProvider() : ?EconomyProvider {
		return $this->economyProvider;
	}

	/**
	 * Allows setting the economy provider to a custom provider or to null to disable economy mode
	 *
	 * @api
	 *
	 * @param EconomyProvider|null $provider
	 */
	public function setEconomyProvider(?EconomyProvider $provider) : void {
		if($provider === null) {
			$this->getConfig()->set("UseEconomy", false);
			$this->getLogger()->info("Economy mode disabled!");
		}else{
			$this->getLogger()->info("A custom economy provider has been registered. Economy mode now enabled!");
			$this->getConfig()->set("UseEconomy", true);
			$this->economyProvider = $provider;
		}
	}

	/**
	 * Returns a PlotLevelSettings object which contains all the settings of a level
	 *
	 * @api
	 *
	 * @param string $levelName
	 *
	 * @return PlotLevelSettings|null
	 */
	public function getLevelSettings(string $levelName) : ?PlotLevelSettings {
		return $this->levels[$levelName] ?? null;
	}

	/**
	 * Checks if a plot level is loaded
	 *
	 * @api
	 *
	 * @param string $levelName
	 *
	 * @return bool
	 */
	public function isLevelLoaded(string $levelName) : bool {
		return isset($this->levels[$levelName]);
	}

	/**
	 * Generate a new plot level with optional settings
	 *
	 * @api
	 *
	 * @param string $levelName
	 * @param string $generator
	 * @param array $settings
	 *
	 * @return bool
	 */
	public function generateLevel(string $levelName, string $generator = "myplot", array $settings = []) : bool {
		$ev = new MyPlotGenerationEvent($levelName, $generator, $settings);
		$ev->call();
		if($ev->isCancelled() or $this->getServer()->isLevelGenerated($levelName)) {
			return false;
		}
		$generator = GeneratorManager::getGenerator($generator);
		if(empty($settings)) {
			$this->getConfig()->reload();
			$settings = $this->getConfig()->get("DefaultWorld", []);
		}
		$default = array_filter($this->getConfig()->get("DefaultWorld", []), function($key){
			return !in_array($key, ["PlotSize", "GroundHeight", "RoadWidth", "RoadBlock", "WallBlock", "PlotFloorBlock", "PlotFillBlock", "BottomBlock"]);
		}, ARRAY_FILTER_USE_KEY);
		new Config($this->getDataFolder()."worlds".DIRECTORY_SEPARATOR.$levelName.".yml", Config::YAML, $default);
		$settings = ["preset" => json_encode($settings)];
		return $this->getServer()->generateLevel($levelName, null, $generator, $settings);
	}

	/**
	 * Saves provided plot if changed
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		return $this->dataProvider->savePlot($plot);
	}

	/**
	 * Get all the plots a player owns (in a certain level if $levelName is provided)
	 *
	 * @api
	 *
	 * @param string $username
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public function getPlotsOfPlayer(string $username, string $levelName) : array {
		return $this->dataProvider->getPlotsByOwner($username, $levelName);
	}

	/**
	 * Get the next free plot in a level
	 *
	 * @api
	 *
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		return $this->dataProvider->getNextFreePlot($levelName, $limitXZ);
	}

	/**
	 * Finds the plot at a certain position or null if there is no plot at that position
	 *
	 * @api
	 *
	 * @param Position $position
	 *
	 * @return Plot|null
	 */
	public function getPlotByPosition(Position $position) : ?Plot {
		$x = $position->x;
		$z = $position->z;
		$levelName = $position->level->getFolderName();

		$plotLevel = $this->getLevelSettings($levelName);
		if($plotLevel === null)
			return null;
		$plotSize = $plotLevel->plotSize;
		$roadWidth = $plotLevel->roadWidth;
		$totalSize = $plotSize + $roadWidth;
		if($x >= 0) {
			$X = (int) floor($x / $totalSize);
			$difX = $x % $totalSize;
		}else{
			$X = (int) ceil(($x - $plotSize + 1) / $totalSize);
			$difX = abs(($x - $plotSize + 1) % $totalSize);
		}
		if($z >= 0) {
			$Z = (int) floor($z / $totalSize);
			$difZ = $z % $totalSize;
		}else{
			$Z = (int) ceil(($z - $plotSize + 1) / $totalSize);
			$difZ = abs(($z - $plotSize + 1) % $totalSize);
		}
		if(($difX > $plotSize - 1) or ($difZ > $plotSize - 1)) {
			return null;
		}
		return $this->dataProvider->getPlot($levelName, $X, $Z);
	}

	/**
	 * Get the begin position of a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return Position|null
	 */
	public function getPlotPosition(Plot $plot) : ?Position {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null)
			return null;
		$plotSize = $plotLevel->plotSize;
		$roadWidth = $plotLevel->roadWidth;
		$totalSize = $plotSize + $roadWidth;
		$x = $totalSize * $plot->X;
		$z = $totalSize * $plot->Z;
		$level = $this->getServer()->getLevelByName($plot->levelName);
		return new Position($x, $plotLevel->groundHeight, $z, $level);
	}

	/**
	 * Returns the AABB of the plot area
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return AxisAlignedBB|null
	 */
	public function getPlotBB(Plot $plot) : ?AxisAlignedBB {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null)
			return null;
		$plotSize = $plotLevel->plotSize;
		$roadWidth = $plotLevel->roadWidth;
		$totalSize = $plotSize + $roadWidth;
		$directionalX = $totalSize * $plot->X; // x closest to 0
		$directionalZ = $totalSize * $plot->Z; // z closest to 0

		$x = $directionalX + $totalSize - 1; // -1 should put us within plot area
		$z = $directionalZ + $totalSize - 1; // -1 should put us within plot area
		if($x >= 0) {
			$difX = $x % $totalSize;
		}else{
			$difX = abs(($x - $plotSize + 1) % $totalSize);
		}
		if($z >= 0) {
			$difZ = $z % $totalSize;
		}else{
			$difZ = abs(($z - $plotSize + 1) % $totalSize);
		}
		if($difX > $plotSize - 1) {
			$minX = $directionalX;
			$maxX = $directionalX + $totalSize;
		}else{
			$minX = $directionalX - $totalSize;
			$maxX = $directionalX;
		}
		if($difZ > $plotSize - 1) {
			$minZ = $directionalZ;
			$maxZ = $directionalZ + $totalSize;
		}else{
			$minZ = $directionalZ - $totalSize;
			$maxZ = $directionalZ;
		}

		return new AxisAlignedBB($minX, 0, $minZ, $maxX, Level::Y_MAX, $maxZ);
	}

	/**
	 * Teleport a player to a plot
	 *
	 * @api
	 *
	 * @param Player $player
	 * @param Plot $plot
	 * @param bool $center
	 *
	 * @return bool
	 */
	public function teleportPlayerToPlot(Player $player, Plot $plot, bool $center = false) : bool {
		$ev = new MyPlotTeleportEvent($plot, $player, $center);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		if($center)
			return $this->teleportMiddle($player, $plot);
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null)
			return false;
		$pos = $this->getPlotPosition($plot);
		$pos->x += floor($plotLevel->plotSize / 2);
		$pos->y += 1.5;
		$pos->z -= 1;
		return $player->teleport($pos);
	}

	/**
	 * Claims a plot in a players name
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param string $claimer
	 * @param string $plotName
	 *
	 * @return bool
	 */
	public function claimPlot(Plot $plot, string $claimer, string $plotName = "") : bool {
		$newPlot = clone $plot;
		$newPlot->owner = $claimer;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		$plot = $ev->getPlot();
		if(!empty($plotName)) {
			$this->renamePlot($plot, $plotName);
		}
		return $this->savePlot($plot);
	}

	/**
	 * @param Plot $plot
	 * @param string $newName
	 *
	 * @return bool
	 */
	public function renamePlot(Plot $plot, string $newName = "") : bool {
		$newPlot = clone $plot;
		$newPlot->name = $newName;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * Reset all the blocks inside a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 *
	 * @return bool
	 */
	public function clearPlot(Plot $plot, int $maxBlocksPerTick = 256) : bool {
		$ev = new MyPlotClearEvent($plot, $maxBlocksPerTick);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		$plot = $ev->getPlot();
		$maxBlocksPerTick = $ev->getMaxBlocksPerTick();
		if(!$this->isLevelLoaded($plot->levelName)) {
			return false;
		}
		foreach($this->getServer()->getLevelByName($plot->levelName)->getEntities() as $entity) {
			$plotB = $this->getPlotByPosition($entity);
			if($plotB != null) {
				if($plotB === $plot) {
					if(!$entity instanceof Player) {
						$entity->close();
					}
				}
			}
		}
		$this->getScheduler()->scheduleTask(new ClearPlotTask($this, $plot, $maxBlocksPerTick));
		return true;
	}

	/**
	 * Delete the plot data
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function disposePlot(Plot $plot) : bool {
		$ev = new MyPlotDisposeEvent($plot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->dataProvider->deletePlot($plot);
	}

	/**
	 * Clear and dispose a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 *
	 * @return bool
	 */
	public function resetPlot(Plot $plot, int $maxBlocksPerTick = 256) : bool {
		$ev = new MyPlotResetEvent($plot);
		$ev->call();
		if($ev->isCancelled())
			return false;
		if($this->disposePlot($plot)) {
			return $this->clearPlot($plot, $maxBlocksPerTick);
		}
		return false;
	}

	/**
	 * Changes the biome of a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 * @param Biome $biome
	 *
	 * @return bool
	 */
	public function setPlotBiome(Plot $plot, Biome $biome) : bool {
		$newPlot = clone $plot;
		$newPlot->biome = strtoupper($biome->getName());
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		$plot = $ev->getPlot();
		$biome = Biome::getBiome(constant(Biome::class . "::" . $plot->biome) ?? Biome::PLAINS);
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null) {
			return false;
		}
		$level = $this->getServer()->getLevelByName($plot->levelName);
		$pos = $this->getPlotPosition($plot);
		$plotSize = $plotLevel->plotSize;
		$xMax = $pos->x + $plotSize;
		$zMax = $pos->z + $plotSize;
		$chunkIndexes = [];
		for($x = $pos->x; $x < $xMax; $x++) {
			for($z = $pos->z; $z < $zMax; $z++) {
				$index = Level::chunkHash($x >> 4, $z >> 4);
				if(!in_array($index, $chunkIndexes)) {
					$chunkIndexes[] = $index;
				}
				Level::getXZ($index, $plot->X, $plot->Z);
				$chunk = $level->getChunk($plot->X, $plot->Z, true);
				$chunk->setBiomeId($x, $z, $biome->getId());
			}
		}
		foreach($chunkIndexes as $index) {
			Level::getXZ($index, $plot->X, $plot->Z);
			$chunk = $level->getChunk($plot->X, $plot->Z, true);
			foreach($level->getViewersForPosition(new Vector3($plot->X, 0, $plot->Z)) as $player) {
				$player->onChunkChanged($chunk);
			}
		}
		$this->savePlot($plot);
		return true;
	}

	/**
	 * @param Plot $plot
	 * @param bool $pvp
	 *
	 * @return bool
	 */
	public function setPlotPvp(Plot $plot, bool $pvp) : bool {
		$newPlot = clone $plot;
		$newPlot->pvp = $pvp;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function addPlotHelper(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->addHelper($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function removePlotHelper(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->removeHelper($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function addPlotDenied(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->denyPlayer($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * @param Plot $plot
	 * @param string $player
	 *
	 * @return bool
	 */
	public function removePlotDenied(Plot $plot, string $player) : bool {
		$newPlot = clone $plot;
		$ev = new MyPlotSettingEvent($plot, $newPlot);
		$ev->setCancelled(!$newPlot->unDenyPlayer($player));
		$ev->call();
		if($ev->isCancelled()) {
			return false;
		}
		return $this->savePlot($ev->getPlot());
	}

	/**
	 * Returns the PlotLevelSettings of all the loaded levels
	 *
	 * @api
	 *
	 * @return PlotLevelSettings[]
	 */
	public function getPlotLevels() : array {
		return $this->levels;
	}

	/**
	 * Returns the Chunks contained in a plot
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return Chunk[]
	 */
	public function getPlotChunks(Plot $plot) : array {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		$level = $this->getServer()->getLevelByName($plot->levelName);
		$pos = $this->getPlotPosition($plot);
		$plotSize = $plotLevel->plotSize;
		$xMax = ($pos->x + $plotSize) >> 4;
		$zMax = ($pos->z + $plotSize) >> 4;
		$chunks = [];
		for($x = $pos->x >> 4; $x < $xMax; $x++) {
			for($z = $pos->z >> 4; $z < $zMax; $z++) {
				$chunks[] = $level->getChunk($x, $z, true);
			}
		}
		return $chunks;
	}

	/**
	 * Get the maximum number of plots a player can claim
	 *
	 * @api
	 *
	 * @param Player $player
	 *
	 * @return int
	 */
	public function getMaxPlotsOfPlayer(Player $player) : int {
		if($player->hasPermission("myplot.claimplots.unlimited"))
			return PHP_INT_MAX;
		/** @var Permission[] $perms */
		$perms = array_merge(PermissionManager::getInstance()->getDefaultPermissions($player->isOp()), $player->getEffectivePermissions());
		$perms = array_filter($perms, function($name) {
			return (substr($name, 0, 18) === "myplot.claimplots.");
		}, ARRAY_FILTER_USE_KEY);
		if(count($perms) === 0)
			return 0;
		krsort($perms, SORT_FLAG_CASE | SORT_NATURAL);
		foreach($perms as $name => $perm) {
			$maxPlots = substr($name, 18);
			if(is_numeric($maxPlots)) {
				return (int) $maxPlots;
			}
		}
		return 0;
	}

	/**
	 * Finds the exact center of the plot at ground level
	 *
	 * @api
	 *
	 * @param Plot $plot
	 *
	 * @return Position|null
	 */
	public function getPlotMid(Plot $plot) : ?Position {
		$plotLevel = $this->getLevelSettings($plot->levelName);
		if($plotLevel === null) {
			return null;
		}
		$plotSize = $plotLevel->plotSize;
		$pos = $this->getPlotPosition($plot);
		$pos = new Position($pos->x + ($plotSize / 2), $pos->y + 1, $pos->z + ($plotSize / 2));
		return $pos;
	}

	/**
	 * Teleports the player to the exact center of the plot at nearest open space to the ground level
	 *
	 * @internal
	 *
	 * @param Plot $plot
	 * @param Player $player
	 *
	 * @return bool
	 */
	private function teleportMiddle(Player $player, Plot $plot) : bool {
		$mid = $this->getPlotMid($plot);
		if($mid === null) {
			return false;
		}
		return $player->teleport($mid);
	}

	/* -------------------------- Non-API part -------------------------- */
	public function onLoad() : void {
		$this->getLogger()->debug(TF::BOLD."Loading...");
		self::$instance = $this;
		$this->getLogger()->debug(TF::BOLD . "Loading Config");
		$this->saveDefaultConfig();
		$this->reloadConfig();
		@mkdir($this->getDataFolder() . "worlds");
		$this->getLogger()->debug(TF::BOLD . "Loading MyPlot Generator");
		GeneratorManager::addGenerator(MyPlotGenerator::class, "myplot", true);
		$this->getLogger()->debug(TF::BOLD . "Loading Languages");
		// Loading Languages
		/** @var string $lang */
		$lang = $this->getConfig()->get("language", BaseLang::FALLBACK_LANGUAGE);
		$this->baseLang = new BaseLang($lang, $this->getFile() . "resources/");
		$this->getLogger()->debug(TF::BOLD . "Loading Data Provider settings");
		// Initialize DataProvider
		/** @var int $cacheSize */
		$cacheSize = $this->getConfig()->get("PlotCacheSize", 256);
		switch(strtolower($this->getConfig()->get("DataProvider", "sqlite3"))) {
			case "mysql":
				if(extension_loaded("mysqli")) {
					$settings = $this->getConfig()->get("MySQLSettings");
					$this->dataProvider = new MySQLProvider($this, $cacheSize, $settings);
				}else {
					$this->getLogger()->info("MySQLi is not installed in your php build! SQLite3 will be used instead.");
					$this->dataProvider = new SQLiteDataProvider($this, $cacheSize);
				}
			break;
			case "yaml":
				$this->dataProvider = new YAMLDataProvider($this, $cacheSize);
			break;
			case "json":
				$this->dataProvider = new JSONDataProvider($this, $cacheSize);
			break;
			case "sqlite3":
			case "sqlite":
			default:
				$this->dataProvider = new SQLiteDataProvider($this, $cacheSize);
			break;
		}
		$this->getLogger()->debug(TF::BOLD . "Loading MyPlot Commands");
		// Register command
		$this->getServer()->getCommandMap()->register("myplot", new Commands($this));
	}

	public function onEnable() : void {
		SpoonDetector::printSpoon($this, "spoon.txt");
		if($this->isDisabled()) {
			return;
		}
		$this->getLogger()->debug(TF::BOLD . "Loading economy settings");
		// Initialize EconomyProvider
		if($this->getConfig()->get("UseEconomy", false) === true) {
			if(($plugin = $this->getServer()->getPluginManager()->getPlugin("EconomyAPI")) !== null) {
				if($plugin instanceof EconomyAPI) {
					$this->economyProvider = new EconomySProvider($plugin);
					$this->getLogger()->debug("Eco set to EconomySProvider");
				}
				$this->getLogger()->debug("Eco not instance of EconomyAPI");
			}
			elseif(($plugin = $this->getServer()->getPluginManager()->getPlugin("EssentialsPE")) !== null) {
				if($plugin instanceof Loader) {
					$this->economyProvider = new EssentialsPEProvider($plugin);
					$this->getLogger()->debug("Eco set to EssentialsPE");
				}
				$this->getLogger()->debug("Eco not instance of EssentialsPE");
			}
			elseif(($plugin = $this->getServer()->getPluginManager()->getPlugin("PocketMoney")) !== null) {
				if($plugin instanceof PocketMoney) {
					$this->economyProvider = new PocketMoneyProvider($plugin);
					$this->getLogger()->debug("Eco set to PocketMoney");
				}
				$this->getLogger()->debug("Eco not instance of PocketMoney");
			}
			if(!isset($this->economyProvider)) {
				$this->getLogger()->info("No supported economy plugin found!");
				$this->getConfig()->set("UseEconomy", false);
				//$this->getConfig()->save();
			}
		}
		$this->getLogger()->debug(TF::BOLD . "Loading Events");
		$eventListener = new EventListener($this);
		$this->getServer()->getPluginManager()->registerEvents($eventListener, $this);
		$this->getLogger()->debug(TF::BOLD . "Registering Loaded Levels");
		foreach($this->getServer()->getLevels() as $level) {
			$eventListener->onLevelLoad(new LevelLoadEvent($level));
		}
		$this->getLogger()->debug(TF::BOLD.TF::GREEN."Enabled!");
	}

	/**
	 * @param string $levelName
	 * @param PlotLevelSettings $settings
	 *
	 * @return bool
	 */
	public function addLevelSettings(string $levelName, PlotLevelSettings $settings) : bool {
		$this->levels[$levelName] = $settings;
		return true;
	}

	/**
	 * @param string $levelName
	 *
	 * @return bool
	 */
	public function unloadLevelSettings(string $levelName) : bool {
		if(isset($this->levels[$levelName])) {
			unset($this->levels[$levelName]);
			$this->getLogger()->debug("Level " . $levelName . " settings unloaded!");
			return true;
		}
		return false;
	}

	public function onDisable() : void {
		if($this->dataProvider !== null)
			$this->dataProvider->close();
	}
}
<?php
declare(strict_types=1);
namespace MyPlot;

use pocketmine\block\Block;
use pocketmine\level\biome\Biome;
use pocketmine\level\ChunkManager;
use pocketmine\level\generator\Generator;
use pocketmine\math\Vector3;
use pocketmine\utils\Random;

class MyPlotGenerator extends Generator {
	/** @var ChunkManager $level */
	protected $level;
	/** @var string[] $settings */
	private $settings;
	/** @var Block */
	public $roadBlock, $wallBlock, $plotFloorBlock, $plotFillBlock, $bottomBlock;
	/** @var int */
	public $roadWidth = 7, $plotSize = 32, $groundHeight = 64;
	const PLOT = 0;
	const ROAD = 1;
	const WALL = 2;

	/**
	 * MyPlotGenerator constructor.
	 *
	 * @param array $settings
	 */
	public function __construct(array $settings = []) {
		if(isset($settings["preset"])) {
			$settings = json_decode($settings["preset"], true);
			if($settings === false or is_null($settings)) {
				$settings = [];
			}
		}else{
			$settings = [];
		}
		$this->roadBlock = PlotLevelSettings::parseBlock($settings, "RoadBlock", Block::get(Block::PLANKS));
		$this->wallBlock = PlotLevelSettings::parseBlock($settings, "WallBlock", Block::get(Block::STONE_SLAB));
		$this->plotFloorBlock = PlotLevelSettings::parseBlock($settings, "PlotFloorBlock", Block::get(Block::GRASS));
		$this->plotFillBlock = PlotLevelSettings::parseBlock($settings, "PlotFillBlock", Block::get(Block::DIRT));
		$this->bottomBlock = PlotLevelSettings::parseBlock($settings, "BottomBlock", Block::get(Block::BEDROCK));
		$this->roadWidth = PlotLevelSettings::parseNumber($settings, "RoadWidth", 7);
		$this->plotSize = PlotLevelSettings::parseNumber($settings, "PlotSize", 32);
		$this->groundHeight = PlotLevelSettings::parseNumber($settings, "GroundHeight", 64);
		$this->settings = [];
		$this->settings["preset"] = json_encode(["RoadBlock" => $this->roadBlock->getId() . (($meta = $this->roadBlock->getDamage()) === 0 ? '' : ':' . $meta), "WallBlock" => $this->wallBlock->getId() . (($meta = $this->wallBlock->getDamage()) === 0 ? '' : ':' . $meta), "PlotFloorBlock" => $this->plotFloorBlock->getId() . (($meta = $this->plotFloorBlock->getDamage()) === 0 ? '' : ':' . $meta), "PlotFillBlock" => $this->plotFillBlock->getId() . (($meta = $this->plotFillBlock->getDamage()) === 0 ? '' : ':' . $meta), "BottomBlock" => $this->bottomBlock->getId() . (($meta = $this->bottomBlock->getDamage()) === 0 ? '' : ':' . $meta), "RoadWidth" => $this->roadWidth, "PlotSize" => $this->plotSize, "GroundHeight" => $this->groundHeight]);
	}

	/**
	 * @return string
	 */
	public function getName() : string {
		return "myplot";
	}

	/**
	 * @return string[]
	 */
	public function getSettings() : array {
		return $this->settings;
	}

	/**
	 * @param ChunkManager $level
	 * @param Random $random
	 */
	public function init(ChunkManager $level, Random $random) : void {
		$this->level = $level;
	}

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 */
	public function generateChunk(int $chunkX, int $chunkZ) : void {
		$shape = $this->getShape($chunkX << 4, $chunkZ << 4);
		$chunk = $this->level->getChunk($chunkX, $chunkZ);
		$bottomBlockId = $this->bottomBlock->getId();
		$bottomBlockMeta = $this->bottomBlock->getDamage();
		$plotFillBlockId = $this->plotFillBlock->getId();
		$plotFillBlockMeta = $this->plotFillBlock->getDamage();
		$plotFloorBlockId = $this->plotFloorBlock->getId();
		$plotFloorBlockMeta = $this->plotFloorBlock->getDamage();
		$roadBlockId = $this->roadBlock->getId();
		$roadBlockMeta = $this->roadBlock->getDamage();
		$wallBlockId = $this->wallBlock->getId();
		$wallBlockMeta = $this->wallBlock->getDamage();
		$groundHeight = $this->groundHeight;
		for($Z = 0; $Z < 16; ++$Z) {
			for($X = 0; $X < 16; ++$X) {
				$chunk->setBiomeId($X, $Z, Biome::PLAINS);
				$chunk->setBlock($X, 0, $Z, $bottomBlockId, $bottomBlockMeta);
				for($y = 1; $y < $groundHeight; ++$y) {
					$chunk->setBlock($X, $y, $Z, $plotFillBlockId, $plotFillBlockMeta);
				}
				$type = $shape[($Z << 4) | $X];
				if($type === self::PLOT) {
					$chunk->setBlock($X, $groundHeight, $Z, $plotFloorBlockId, $plotFloorBlockMeta);
				}elseif($type === self::ROAD) {
					$chunk->setBlock($X, $groundHeight, $Z, $roadBlockId, $roadBlockMeta);
				}else{
					$chunk->setBlock($X, $groundHeight, $Z, $roadBlockId, $roadBlockMeta);
					$chunk->setBlock($X, $groundHeight + 1, $Z, $wallBlockId, $wallBlockMeta);
				}
			}
		}
		$chunk->setX($chunkX);
		$chunk->setZ($chunkZ);
		$chunk->setGenerated();
		$this->level->setChunk($chunkX, $chunkZ, $chunk);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return \SplFixedArray
	 */
	public function getShape(int $x, int $z) {
		$totalSize = $this->plotSize + $this->roadWidth;
		if($x >= 0) {
			$X = $x % $totalSize;
		}else{
			$X = $totalSize - abs($x % $totalSize);
		}
		if($z >= 0) {
			$Z = $z % $totalSize;
		}else{
			$Z = $totalSize - abs($z % $totalSize);
		}
		$startX = $X;
		$shape = new \SplFixedArray(256);
		for($z = 0; $z < 16; $z++, $Z++) {
			if($Z === $totalSize) {
				$Z = 0;
			}
			if($Z < $this->plotSize) {
				$typeZ = self::PLOT;
			}elseif($Z === $this->plotSize or $Z === ($totalSize - 1)) {
				$typeZ = self::WALL;
			}else{
				$typeZ = self::ROAD;
			}
			for($x = 0, $X = $startX; $x < 16; $x++, $X++) {
				if($X === $totalSize) {
					$X = 0;
				}
				if($X < $this->plotSize) {
					$typeX = self::PLOT;
				}elseif($X === $this->plotSize or $X === ($totalSize - 1)) {
					$typeX = self::WALL;
				}else{
					$typeX = self::ROAD;
				}
				if($typeX === $typeZ) {
					$type = $typeX;
				}elseif($typeX === self::PLOT) {
					$type = $typeZ;
				}elseif($typeZ === self::PLOT) {
					$type = $typeX;
				}else{
					$type = self::ROAD;
				}
				$shape[($z << 4) | $x] = $type;
			}
		}
		return $shape;
	}

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 */
	public function populateChunk(int $chunkX, int $chunkZ) : void {
	}

	/**
	 * @return Vector3
	 */
	public function getSpawn() : Vector3 {
		return new Vector3(0, $this->groundHeight + 1, 0);
	}
}; English language pack for MyPlot
; Created by Wiez, Exxarion, and jasonwynn10
; Updated time : 2/17/2019

; Popup when entering a plot
popup=You entered plot {%0}
popup.owner=Owned by {%0}
popup.available=This plot is open. Use /p claim to claim the plot.
popup.denied=You are denied access to this plot

; /p info
command.name=plot
command.alias=p
command.desc=Claim and manage your plots
command.usage=/p [help]
command.unknown=Unknown command. Try /p help for a list of commands

subcommand.usage=Usage: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Whoops! Something went wrong
notinplot=You are not standing inside a plot
notowner=You do not own this plot
plugin.disabled=This plugin is disabled

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Shows the help menu
help.usage=/p help [page: int]
help.header=--- Showing MyPlot help page {%0} of {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Add a helper to your plot
addhelper.usage=/p addhelper <player: string>
addhelper.alreadyone={%0} is already a helper of this plot
addhelper.success={%0} is now a helper of this plot

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Remove a helper from your plot
removehelper.usage=/p removehelper <player: string>
removehelper.notone={%0} is not a helper
removehelper.success={%0} has been removed from plot helpers

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Deny a player from accessing your plot
denyplayer.usage=/p deny <player: string>
denyplayer.helper={%0} is a helper
denyplayer.alreadyone={%0} has already been denied from this plot
denyplayer.notaplayer=That player is not online right now
denyplayer.cannotdeny={%0} cannot be denied
denyplayer.attempteddeny={%0} attempted to deny you from their plot
denyplayer.success1={%0} is now denied access to the plot
denyplayer.success2="You were denied access to plot {%0};{%1} by {%2}"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Undeny a player from accessing your plot
undenyplayer.usage=/p undeny <player: string>
undenyplayer.notone={%0} is allowed already
undenyplayer.success1={%0} has been allowed into the plot
undenyplayer.success2="You were allowed access to plot {%0};{%1} by {%2}"
undenyplayer.failure={%0} is still denied

; The /p claim Subcommand
claim.name=claim
claim.desc=Claim the current plot you are standing on
claim.usage=/p claim [name: string]
claim.yourplot=You have already claimed this plot
claim.alreadyclaimed=This plot is already claimed by {%0}
claim.maxplots=You reached the limit of {%0} plots per player
claim.nomoney=You do not have enough money to claim this plot
claim.success=You have successfully claimed the plot

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleports to the next free plot
auto.usage=/p auto [claim: bool] [name: string]
auto.notplotworld=You are not in a plot world
auto.success="Teleported to free plot ({%0};{%1})"
auto.noplots=Could not find any available plots

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Disposes your plot
dispose.usage=/p dispose
dispose.confirm=Are you sure you want to dispose plot {%0}? If so, use /p dispose confirm
dispose.nomoney=You do not have enough money to dispose this plot
dispose.success=Plot disposed

; The /p reset Subcommand
reset.name=reset
reset.desc=Disposes and clears your plot
reset.usage=/p reset
reset.confirm=Are you sure you want to reset plot {%0}? If so, use /p reset confirm
reset.nomoney=You do not have enough money to reset this plot
reset.success=Plot reset

; The /p clear Subcommand
clear.name=clear
clear.desc=Clears your plot
clear.usage=/p clear
clear.confirm=Are you sure you want to clear plot {%0}? If so, use /p clear confirm
clear.nomoney=You do not have enough money to clear this plot
clear.success=Plot cleared

; The /p biome Subcommand
biome.name=biome
biome.desc=Changes your plot biome
biome.usage=/p biome [biome: string]
biome.success=Plot biome changed to {%0}
biome.invalid=That biome does not exist
biome.possible=Possible biomes are: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; The /p name Subcommand
name.name=name
name.desc=Sets or changes your plot name
name.usage=/p name <name: string>
name.success=Plot successfully renamed

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Travel to your plot
home.usage=/p home [number: int] [world: string]
home.noplots=You do not own any plots in this world
home.notexist=You do not own a plot with id {%0} in this world
home.success=Teleported to plot {%0} in world {%1}
home.error=Could not travel to plot

; The /p homes Subcommand
homes.name=homes
homes.desc=Shows your claimed plots
homes.usage=/p homes [world: string]
homes.noplots=You do not own any plots
homes.header=Plots you own:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Shows information about a plot
info.usage=/p info [player: string] [number: int]
info.about=Info about plot {%0}
info.plotname=Name: {%0}
info.owner=Owner: {%0}
info.helpers=Helpers: {%0}
info.denied=Denied: {%0}
info.biome=Biome: {%0}
info.notfound=That plot could not be found

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Generate a new plot world
generate.usage=/p generate <name: string> [generator name: string] [teleport: bool]
generate.exists=World with name {%0} already exists
generate.gexists=Generator {%0} does not exist
generate.success=Successfully generated plot world {%0}
generate.error=World could not be generated

; The /p give Subcommand
give.name=give
give.desc=Give your plot to someone else
give.usage=/p give [player: string]
give.notonline=That player is not online
give.maxedout=That player has reached the maximum number of plots
give.toself=You cannot give a plot to yourself
give.confirm=Are you sure you want to give plot {%0} to player {%1}? If so, use /p give {%1} confirm
give.success=You have given the plot to {%0}
give.received={%0} gave you their plot, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleport to a plot
warp.usage=/p warp <id: int> [world: string]
warp.wrongid="The plot id should be in the format X;Z"
warp.notinplotworld=You are not in a plot world
warp.unclaimed=You cannot warp to an unclaimed plot
warp.success=You are teleported to plot {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleports the player to exact center of plot at ground level
middle.usage=/p mid
middle.success=Teleporting complete

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Sets the new owner of the plot without charging anything
setowner.usage=/p setowner <player: string>
setowner.maxplots=That player reached their plots limit of {%0}
setowner.success={%0} is now the owner of this plot

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Shows all plots a player has
list.usage=/p list [player: string]
list.found="Plot {%0} at ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.disabled=Pvp is disabled here
pvp.success=Pvp is now {%0} for the plot<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;

class SQLiteDataProvider extends DataProvider
{
	/** @var \SQLite3 $db */
	private $db;
	/** @var \SQLite3Stmt */
	private $sqlGetPlot, $sqlSavePlot, $sqlSavePlotById, $sqlRemovePlot, $sqlRemovePlotById, $sqlGetPlotsByOwner, $sqlGetPlotsByOwnerAndLevel, $sqlGetExistingXZ;

	/**
	 * SQLiteDataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		parent::__construct($plugin, $cacheSize);
		$this->db = new \SQLite3($this->plugin->getDataFolder() . "plots.db");
		$this->db->exec("CREATE TABLE IF NOT EXISTS plots
			(id INTEGER PRIMARY KEY AUTOINCREMENT, level TEXT, X INTEGER, Z INTEGER, name TEXT,
			 owner TEXT, helpers TEXT, denied TEXT, biome TEXT, pvp INTEGER);");
		try{
			$this->db->exec("ALTER TABLE plots ADD pvp INTEGER;");
		}catch(\Exception $e) {
			// nothing :P
		}
		$this->sqlGetPlot = $this->db->prepare("SELECT id, name, owner, helpers, denied, biome, pvp FROM plots WHERE level = :level AND X = :X AND Z = :Z;");
		$this->sqlSavePlot = $this->db->prepare("INSERT OR REPLACE INTO plots (id, level, X, Z, name, owner, helpers, denied, biome, pvp) VALUES
			((SELECT id FROM plots WHERE level = :level AND X = :X AND Z = :Z),
			 :level, :X, :Z, :name, :owner, :helpers, :denied, :biome, :pvp);");
		$this->sqlSavePlotById = $this->db->prepare("UPDATE plots SET name = :name, owner = :owner, helpers = :helpers, denied = :denied, biome = :biome, pvp = :pvp WHERE id = :id;");
		$this->sqlRemovePlot = $this->db->prepare("DELETE FROM plots WHERE level = :level AND X = :X AND Z = :Z;");
		$this->sqlRemovePlotById = $this->db->prepare("DELETE FROM plots WHERE id = :id;");
		$this->sqlGetPlotsByOwner = $this->db->prepare("SELECT * FROM plots WHERE owner = :owner;");
		$this->sqlGetPlotsByOwnerAndLevel = $this->db->prepare("SELECT * FROM plots WHERE owner = :owner AND level = :level;");
		$this->sqlGetExistingXZ = $this->db->prepare("SELECT X, Z FROM plots WHERE (
				level = :level
				AND (
					(abs(X) = :number AND abs(Z) <= :number) OR
					(abs(Z) = :number AND abs(X) <= :number)
				)
			);");
		$this->plugin->getLogger()->debug("SQLite data provider registered");
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$helpers = implode(",", $plot->helpers);
		$denied = implode(",", $plot->denied);
		if($plot->id >= 0) {
			$stmt = $this->sqlSavePlotById;
			$stmt->bindValue(":id", $plot->id, SQLITE3_INTEGER);
		}else{
			$stmt = $this->sqlSavePlot;
			$stmt->bindValue(":level", $plot->levelName, SQLITE3_TEXT);
			$stmt->bindValue(":X", $plot->X, SQLITE3_INTEGER);
			$stmt->bindValue(":Z", $plot->Z, SQLITE3_INTEGER);
		}
		$stmt->bindValue(":name", $plot->name, SQLITE3_TEXT);
		$stmt->bindValue(":owner", $plot->owner, SQLITE3_TEXT);
		$stmt->bindValue(":helpers", $helpers, SQLITE3_TEXT);
		$stmt->bindValue(":denied", $denied, SQLITE3_TEXT);
		$stmt->bindValue(":biome", $plot->biome, SQLITE3_TEXT);
		$stmt->bindValue(":pvp", $plot->pvp, SQLITE3_INTEGER);
		$stmt->reset();
		$result = $stmt->execute();
		if($result === false) {
			return false;
		}
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		if($plot->id >= 0) {
			$stmt = $this->sqlRemovePlotById;
			$stmt->bindValue(":id", $plot->id, SQLITE3_INTEGER);
		}else{
			$stmt = $this->sqlRemovePlot;
			$stmt->bindValue(":level", $plot->levelName, SQLITE3_TEXT);
			$stmt->bindValue(":X", $plot->X, SQLITE3_INTEGER);
			$stmt->bindValue(":Z", $plot->Z, SQLITE3_INTEGER);
		}
		$stmt->reset();
		$result = $stmt->execute();
		if($result === false) {
			return false;
		}
		$plot = new Plot($plot->levelName, $plot->X, $plot->Z);
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) !== null) {
			return $plot;
		}
		$this->sqlGetPlot->bindValue(":level", $levelName, SQLITE3_TEXT);
		$this->sqlGetPlot->bindValue(":X", $X, SQLITE3_INTEGER);
		$this->sqlGetPlot->bindValue(":Z", $Z, SQLITE3_INTEGER);
		$this->sqlGetPlot->reset();
		$result = $this->sqlGetPlot->execute();
		if($val = $result->fetchArray(SQLITE3_ASSOC)) {
			if($val["helpers"] === null or $val["helpers"] === "") {
				$helpers = [];
			}else{
				$helpers = explode(",", (string) $val["helpers"]);
			}
			if($val["denied"] === null or $val["denied"] === "") {
				$denied = [];
			}else{
				$denied = explode(",", (string) $val["denied"]);
			}
			$plot = new Plot($levelName, $X, $Z, (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}else{
			$plot = new Plot($levelName, $X, $Z);
		}
		$this->cachePlot($plot);
		return $plot;
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return array
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		if($levelName === "") {
			$stmt = $this->sqlGetPlotsByOwner;
		}else{
			$stmt = $this->sqlGetPlotsByOwnerAndLevel;
			$stmt->bindValue(":level", $levelName, SQLITE3_TEXT);
		}
		$stmt->bindValue(":owner", $owner, SQLITE3_TEXT);
		$plots = [];
		$stmt->reset();
		$result = $stmt->execute();
		while($val = $result->fetchArray(SQLITE3_ASSOC)) {
			$helpers = explode(",", (string) $val["helpers"]);
			$denied = explode(",", (string) $val["denied"]);
			$plots[] = new Plot((string) $val["level"], (int) $val["X"], (int) $val["Z"], (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}
		// Remove unloaded plots
		$plots = array_filter($plots, function($plot) {
			return $this->plugin->isLevelLoaded($plot->levelName);
		});
		// Sort plots by level
		usort($plots, function($plot1, $plot2) {
			return strcmp($plot1->levelName, $plot2->levelName);
		});
		return $plots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		$this->sqlGetExistingXZ->bindValue(":level", $levelName, SQLITE3_TEXT);
		$i = 0;
		$this->sqlGetExistingXZ->bindParam(":number", $i, SQLITE3_INTEGER);
		for(; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$this->sqlGetExistingXZ->reset();
			$result = $this->sqlGetExistingXZ->execute();
			$plots = [];
			while($val = $result->fetchArray(SQLITE3_NUM)) {
				$plots[$val[0]][$val[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		$this->db->close();
		$this->plugin->getLogger()->debug("SQLite database closed!");
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;

abstract class DataProvider
{
	/** @var Plot[] $cache */
	private $cache = [];
	/** @var int $cacheSize */
	private $cacheSize;
	/** @var MyPlot $plugin */
	protected $plugin;

	/**
	 * DataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		$this->plugin = $plugin;
		$this->cacheSize = $cacheSize;
	}

	/**
	 * @param Plot $plot
	 */
	protected final function cachePlot(Plot $plot) : void {
		if($this->cacheSize > 0) {
			$key = $plot->levelName . ';' . $plot->X . ';' . $plot->Z;
			if(isset($this->cache[$key])) {
				unset($this->cache[$key]);
			}
			elseif($this->cacheSize <= count($this->cache)) {
				array_shift($this->cache);
			}
			$this->cache = array_merge([$key => clone $plot], $this->cache);
			$this->plugin->getLogger()->debug("Plot {$plot->X};{$plot->Z} has been cached");
		}
	}

	/**
	 * @param $levelName
	 * @param $X
	 * @param $Z
	 *
	 * @return Plot|null
	 */
	protected final function getPlotFromCache(string $levelName, int $X, int $Z) : ?Plot {
		if($this->cacheSize > 0) {
			$key = $levelName . ';' . $X . ';' . $Z;
			if(isset($this->cache[$key])) {
				#$this->plugin->getLogger()->debug("Plot {$X};{$Z} was loaded from the cache");
				return $this->cache[$key];
			}
		}
		return null;
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public abstract function savePlot(Plot $plot) : bool;

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public abstract function deletePlot(Plot $plot) : bool;

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public abstract function getPlot(string $levelName, int $X, int $Z) : Plot;

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public abstract function getPlotsByOwner(string $owner, string $levelName = "") : array;

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public abstract function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot;

	public abstract function close() : void;

	/**
	 * @param int $a
	 * @param int $b
	 * @param array[] $plots
	 *
	 * @return array|null
	 */
	protected static function findEmptyPlotSquared(int $a, int $b, array $plots) : ?array {
		if(!isset($plots[$a][$b]))
			return [$a, $b];
		if(!isset($plots[$b][$a]))
			return [$b, $a];
		if($a !== 0) {
			if(!isset($plots[-$a][$b]))
				return [-$a, $b];
			if(!isset($plots[$b][-$a]))
				return [$b, -$a];
		}
		if($b !== 0) {
			if(!isset($plots[-$b][$a]))
				return [-$b, $a];
			if(!isset($plots[$a][-$b]))
				return [$a, -$b];
		}
		if($a | $b === 0) {
			if(!isset($plots[-$a][-$b]))
				return [-$a, -$b];
			if(!isset($plots[-$b][-$a]))
				return [-$b, -$a];
		}
		return null;
	}
}<?php
declare(strict_types=1);
namespace MyPlot;

use MyPlot\subcommand\AddHelperSubCommand;
use MyPlot\subcommand\AutoSubCommand;
use MyPlot\subcommand\BiomeSubCommand;
use MyPlot\subcommand\ClaimSubCommand;
use MyPlot\subcommand\ClearSubCommand;
use MyPlot\subcommand\DenyPlayerSubCommand;
use MyPlot\subcommand\DisposeSubCommand;
use MyPlot\subcommand\GenerateSubCommand;
use MyPlot\subcommand\GiveSubCommand;
use MyPlot\subcommand\HelpSubCommand;
use MyPlot\subcommand\HomesSubCommand;
use MyPlot\subcommand\HomeSubCommand;
use MyPlot\subcommand\InfoSubCommand;
use MyPlot\subcommand\ListSubCommand;
use MyPlot\subcommand\MiddleSubCommand;
use MyPlot\subcommand\NameSubCommand;
use MyPlot\subcommand\PvpSubCommand;
use MyPlot\subcommand\RemoveHelperSubCommand;
use MyPlot\subcommand\ResetSubCommand;
use MyPlot\subcommand\SetOwnerSubCommand;
use MyPlot\subcommand\SubCommand;
use MyPlot\subcommand\UnDenySubCommand;
use MyPlot\subcommand\WarpSubCommand;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginCommand;
use pocketmine\utils\TextFormat;

class Commands extends PluginCommand
{
	/** @var SubCommand[] $subCommands */
	private $subCommands = [];
	/** @var SubCommand[] $aliasSubCommands */
	private $aliasSubCommands = [];

	/**
	 * Commands constructor.
	 *
	 * @param MyPlot $plugin
	 */
	public function __construct(MyPlot $plugin) {
		parent::__construct($plugin->getLanguage()->get("command.name"), $plugin);
		$this->setPermission("myplot.command");
		$this->setAliases([$plugin->getLanguage()->get("command.alias")]);
		$this->setDescription($plugin->getLanguage()->get("command.desc"));
		$this->setUsage($plugin->getLanguage()->get("command.usage"));
		$this->loadSubCommand(new HelpSubCommand($plugin, "help", $this));
		$this->loadSubCommand(new ClaimSubCommand($plugin, "claim"));
		$this->loadSubCommand(new GenerateSubCommand($plugin, "generate"));
		$this->loadSubCommand(new InfoSubCommand($plugin, "info"));
		$this->loadSubCommand(new AddHelperSubCommand($plugin, "addhelper"));
		$this->loadSubCommand(new RemoveHelperSubCommand($plugin, "removehelper"));
		$this->loadSubCommand(new AutoSubCommand($plugin, "auto"));
		$this->loadSubCommand(new ClearSubCommand($plugin, "clear"));
		$this->loadSubCommand(new DisposeSubCommand($plugin, "dispose"));
		$this->loadSubCommand(new ResetSubCommand($plugin, "reset"));
		$this->loadSubCommand(new BiomeSubCommand($plugin, "biome"));
		$this->loadSubCommand(new HomeSubCommand($plugin, "home"));
		$this->loadSubCommand(new HomesSubCommand($plugin, "homes"));
		$this->loadSubCommand(new NameSubCommand($plugin, "name"));
		$this->loadSubCommand(new GiveSubCommand($plugin, "give"));
		$this->loadSubCommand(new WarpSubCommand($plugin, "warp"));
		$this->loadSubCommand(new MiddleSubCommand($plugin, "middle"));
		$this->loadSubCommand(new DenyPlayerSubCommand($plugin, "denyplayer"));
		$this->loadSubCommand(new UnDenySubCommand($plugin, "undenyplayer"));
		$this->loadSubCommand(new SetOwnerSubCommand($plugin, "setowner"));
		$this->loadSubCommand(new ListSubCommand($plugin, "list"));
		$this->loadSubCommand(new PvpSubCommand($plugin, "pvp"));
		$plugin->getLogger()->debug("Commands Registered to MyPlot");
	}

	/**
	 * @return SubCommand[]
	 */
	public function getCommands() : array {
		return $this->subCommands;
	}

	/**
	 * @param SubCommand $command
	 */
	public function loadSubCommand(SubCommand $command) : void {
		$this->subCommands[$command->getName()] = $command;
		if($command->getAlias() != "") {
			$this->aliasSubCommands[$command->getAlias()] = $command;
		}
	}

	/**
	 * @param string $name
	 */
	public function unloadSubCommand(string $name) : void {
		$subcommand = $this->subCommands[$name] ?? $this->aliasSubCommands[$name] ?? null;
		if($subcommand !== null) {
			unset($this->subCommands[$subcommand->getName()]);
			unset($this->aliasSubCommands[$subcommand->getAlias()]);
		}
	}

	/**
	 * @param CommandSender $sender
	 * @param string $alias
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, string $alias, array $args) : bool {
		if($this->getPlugin()->isDisabled()) {
			/** @noinspection PhpUndefinedMethodInspection */
			$sender->sendMessage($this->getPlugin()->getLanguage()->get("plugin.disabled"));
			return true;
		}
		if(!isset($args[0])) {
			$args[0] = "help";
		}
		$subCommand = strtolower(array_shift($args));
		if(isset($this->subCommands[$subCommand])) {
			$command = $this->subCommands[$subCommand];
		}elseif(isset($this->aliasSubCommands[$subCommand])) {
			$command = $this->aliasSubCommands[$subCommand];
		}else{
			/** @noinspection PhpUndefinedMethodInspection */
			$sender->sendMessage(TextFormat::RED . $this->getPlugin()->getLanguage()->get("command.unknown"));
			return true;
		}
		if($command->canUse($sender)) {
			if(!$command->execute($sender, $args)) {
				/** @noinspection PhpUndefinedMethodInspection */
				$usage = $this->getPlugin()->getLanguage()->translateString("subcommand.usage", [$command->getUsage()]);
				$sender->sendMessage($usage);
			}
		}else{
			/** @noinspection PhpUndefinedMethodInspection */
			$sender->sendMessage(TextFormat::RED . $this->getPlugin()->getLanguage()->get("command.unknown"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Commands;
use MyPlot\MyPlot;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class HelpSubCommand extends SubCommand
{
	/** @var Commands $cmds */
	private $cmds;

	/**
	 * HelpSubCommand constructor.
	 *
	 * @param MyPlot $plugin
	 * @param string $name
	 * @param Commands $cmds
	 */
	public function __construct(MyPlot $plugin, string $name, Commands $cmds) {
		parent::__construct($plugin, $name);
		$this->cmds = $cmds;
	}

	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return $sender->hasPermission("myplot.command.help");
	}

	/**
	 * @param CommandSender $sender
	 * @param string[] $args
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			$pageNumber = 1;
		}elseif(is_numeric($args[0])) {
			$pageNumber = (int) array_shift($args);
			if ($pageNumber <= 0) {
				$pageNumber = 1;
			}
		}else{
			return false;
		}

		$commands = [];
		foreach($this->cmds->getCommands() as $command) {
			if ($command->canUse($sender)) {
				$commands[$command->getName()] = $command;
			}
		}
		ksort($commands, SORT_NATURAL | SORT_FLAG_CASE);
		$commands = array_chunk($commands, $sender->getScreenLineHeight());
		/** @var SubCommand[][] $commands */
		$pageNumber = (int) min(count($commands), $pageNumber);

		$sender->sendMessage($this->translateString("help.header", [$pageNumber, count($commands)]));
		foreach($commands[$pageNumber - 1] as $command) {
			$sender->sendMessage(TextFormat::DARK_GREEN . $command->getName() . ": " . TextFormat::WHITE . $command->getDescription());
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\MyPlot;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\plugin\Plugin;

abstract class SubCommand implements PluginIdentifiableCommand
{
	/** @var MyPlot $plugin */
    private $plugin;
	/** @var string $name */
    private $name;

    /**
     * @param MyPlot $plugin
     * @param string $name
     */
	public function __construct(MyPlot $plugin, string $name) {
        $this->plugin = $plugin;
        $this->name = $name;
    }

    /**
     * @return MyPlot
     */
	public final function getPlugin() : Plugin {
        return $this->plugin;
    }

    /**
     * @param string $str
     * @param string[] $params
     *
     * @param string $onlyPrefix
     * @return string
     */
	protected function translateString(string $str, array $params = [], string $onlyPrefix = null) : string {
        return $this->plugin->getLanguage()->translateString($str, $params, $onlyPrefix);
    }

    /**
     * @param CommandSender $sender
     * @return bool
     */
	public abstract function canUse(CommandSender $sender) : bool;

    /**
     * @return string
     */
	public final function getUsage() : string {
        $usage = $this->getPlugin()->getLanguage()->get($this->name . ".usage");
        return ($usage == $this->name . ".usage") ? "" : $usage;
    }

    /**
     * @return string
     */
	public final function getName() : string {
        $name = $this->getPlugin()->getLanguage()->get($this->name . ".name");
        return ($name == $this->name . ".name") ? "" : $name;
    }

    /**
     * @return string
     */
	public final function getDescription() : string {
        $desc = $this->getPlugin()->getLanguage()->get($this->name . ".desc");
        return ($desc == $this->name . ".desc") ? "" : $desc;
    }

    /**
     * @return string
     */
	public final function getAlias() : string {
        $alias = $this->getPlugin()->getLanguage()->get($this->name . ".alias");
        return ($alias == $this->name . ".alias") ? "" : $alias;
    }

	/**
	 * @param CommandSender $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public abstract function execute(CommandSender $sender, array $args) : bool;
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ClaimSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.claim");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$name = "";
		if(isset($args[0])) {
			$name = $args[0];
		}
		$player = $sender->getServer()->getPlayer($sender->getName());
		$plot = $this->getPlugin()->getPlotByPosition($player);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner != "") {
			if($plot->owner === $sender->getName()) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("claim.yourplot"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("claim.alreadyclaimed", [$plot->owner]));
			}
			return true;
		}
		$maxPlots = $this->getPlugin()->getMaxPlotsOfPlayer($player);
		$plotsOfPlayer = 0;
		foreach($this->getPlugin()->getPlotLevels() as $level => $settings) {
			$level = $this->getPlugin()->getServer()->getLevelByName((string)$level);
			if(!$level->isClosed()) {
				$plotsOfPlayer += count($this->getPlugin()->getPlotsOfPlayer($player->getName(), $level->getFolderName()));
			}
		}
		if($plotsOfPlayer >= $maxPlots) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("claim.maxplots", [$maxPlots]));
			return true;
		}
		$plotLevel = $this->getPlugin()->getLevelSettings($plot->levelName);
		$economy = $this->getPlugin()->getEconomyProvider();
		if($economy !== null and !$economy->reduceMoney($player, $plotLevel->claimPrice)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("claim.nomoney"));
			return true;
		}
		if($this->getPlugin()->claimPlot($plot, $sender->getName(), $name)) {
			$sender->sendMessage($this->translateString("claim.success"));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Plot;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class GenerateSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return $sender->hasPermission("myplot.command.generate");
	}

	/**
	 * @param CommandSender $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$levelName = $args[0];
		if($sender->getServer()->isLevelGenerated($levelName)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("generate.exists", [$levelName]));
			return true;
		}
		if($this->getPlugin()->generateLevel($levelName, $args[1] ?? "myplot")) {
			if(isset($args[2]) and $args[2] == true and $sender instanceof Player) {
				$this->getPlugin()->teleportPlayerToPlot($sender, new Plot($levelName, 0, 0));
			}
			$sender->sendMessage($this->translateString("generate.success", [$levelName]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("generate.error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Plot;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class InfoSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.info");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(isset($args[0])) {
			if(isset($args[1]) and is_numeric($args[1])) {
				$key = ((int) $args[1] - 1) < 1 ? 1 : ((int) $args[1] - 1);
				/** @var Plot[] $plots */
				$plots = [];
				foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
					$plots = array_merge($plots, $this->getPlugin()->getPlotsOfPlayer($args[0], $levelName));
				}
				if(isset($plots[$key])) {
					$plot = $plots[$key];
					$sender->sendMessage($this->translateString("info.about", [TextFormat::GREEN . $plot]));
					$sender->sendMessage($this->translateString("info.owner", [TextFormat::GREEN . $plot->owner]));
					$sender->sendMessage($this->translateString("info.plotname", [TextFormat::GREEN . $plot->name]));
					$helpers = implode(", ", $plot->helpers);
					$sender->sendMessage($this->translateString("info.helpers", [TextFormat::GREEN . $helpers]));
					$denied = implode(", ", $plot->denied);
					$sender->sendMessage($this->translateString("info.denied", [TextFormat::GREEN . $denied]));
					$sender->sendMessage($this->translateString("info.biome", [TextFormat::GREEN . $plot->biome]));
				}else{
					$sender->sendMessage(TextFormat::RED . $this->translateString("info.notfound"));
				}
			}else{
				return false;
			}
		}else{
			$plot = $this->getPlugin()->getPlotByPosition($sender);
			if($plot === null) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
				return true;
			}
			$sender->sendMessage($this->translateString("info.about", [TextFormat::GREEN . $plot]));
			$sender->sendMessage($this->translateString("info.owner", [TextFormat::GREEN . $plot->owner]));
			$sender->sendMessage($this->translateString("info.plotname", [TextFormat::GREEN . $plot->name]));
			$helpers = implode(", ", $plot->helpers);
			$sender->sendMessage($this->translateString("info.helpers", [TextFormat::GREEN . $helpers]));
			$denied = implode(", ", $plot->denied);
			$sender->sendMessage($this->translateString("info.denied", [TextFormat::GREEN . $denied]));
			$sender->sendMessage($this->translateString("info.biome", [TextFormat::GREEN . $plot->biome]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class AddHelperSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.addhelper");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$helper = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.addhelper")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$helper = $this->getPlugin()->getServer()->getPlayer($helper) ?? $this->getPlugin()->getServer()->getOfflinePlayer($helper);
		if($this->getPlugin()->addPlotHelper($plot, $helper->getName())) {
			$sender->sendMessage($this->translateString("addhelper.success", [$helper->getName()]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class RemoveHelperSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.removehelper");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$helper = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.removehelper")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$helper = $this->getPlugin()->getServer()->getPlayer($helper) ?? $this->getPlugin()->getServer()->getOfflinePlayer($helper);
		if($this->getPlugin()->removePlotHelper($plot, $helper->getName())) {
			$sender->sendMessage($this->translateString("removehelper.success", [$helper->getName()]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class AutoSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.auto");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$levelName = $sender->getLevel()->getFolderName();
		if(!$this->getPlugin()->isLevelLoaded($levelName)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("auto.notplotworld"));
			return true;
		}
		if(($plot = $this->getPlugin()->getNextFreePlot($levelName)) !== null) {
			if($this->getPlugin()->teleportPlayerToPlot($sender, $plot, true)) {
				$sender->sendMessage($this->translateString("auto.success", [$plot->X, $plot->Z]));
				$cmd = new ClaimSubCommand($this->getPlugin(), "claim");
				if(isset($args[0]) and strtolower($args[0]) == "true" and $cmd->canUse($sender)) {
					$cmd->execute($sender, [$args[1]]);
				}
			}else {
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("auto.noplots"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ClearSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.clear");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.clear")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(isset($args[0]) and $args[0] == $this->translateString("confirm")) {
			$economy = $this->getPlugin()->getEconomyProvider();
			$price = $this->getPlugin()->getLevelSettings($plot->levelName)->clearPrice;
			if($economy !== null and !$economy->reduceMoney($sender, $price)) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("clear.nomoney"));
				return true;
			}
			/** @var int $maxBlocksPerTick */
			$maxBlocksPerTick = (int) $this->getPlugin()->getConfig()->get("ClearBlocksPerTick", 256);
			if($this->getPlugin()->clearPlot($plot, $maxBlocksPerTick)) {
				$sender->sendMessage($this->translateString("clear.success"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("clear.confirm", [$plotId]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class DisposeSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.dispose");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.dispose")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(isset($args[0]) and $args[0] == $this->translateString("confirm")) {
			$economy = $this->getPlugin()->getEconomyProvider();
			$price = $this->getPlugin()->getLevelSettings($plot->levelName)->disposePrice;
			if($economy !== null and !$economy->reduceMoney($sender, $price)) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("dispose.nomoney"));
				return true;
			}
			if($this->getPlugin()->disposePlot($plot)) {
				$sender->sendMessage($this->translateString("dispose.success"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("dispose.confirm", [$plotId]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ResetSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.reset");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.reset")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(isset($args[0]) and $args[0] == $this->translateString("confirm")) {
			$economy = $this->getPlugin()->getEconomyProvider();
			$price = $this->getPlugin()->getLevelSettings($plot->levelName)->resetPrice;
			if($economy !== null and !$economy->reduceMoney($sender, $price)) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("reset.nomoney"));
				return true;
			}
			/** @var int $maxBlocksPerTick */
			$maxBlocksPerTick = $this->getPlugin()->getConfig()->get("ClearBlocksPerTick", 256);
			if($this->getPlugin()->resetPlot($plot, $maxBlocksPerTick)) {
				$sender->sendMessage($this->translateString("reset.success"));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("reset.confirm", [$plotId]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\level\biome\Biome;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class BiomeSubCommand extends SubCommand
{
	/** @var int[] $biomes */
	private $biomes = ["PLAINS" => Biome::PLAINS, "DESERT" => Biome::DESERT, "MOUNTAINS" => Biome::MOUNTAINS, "FOREST" => Biome::FOREST, "TAIGA" => Biome::TAIGA, "SWAMP" => Biome::SWAMP, "NETHER" => Biome::HELL, "HELL" => Biome::HELL, "ICE" => Biome::ICE_PLAINS];

	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.biome");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			$biomes = TextFormat::WHITE . implode(", ", array_keys($this->biomes));
			$sender->sendMessage($this->translateString("biome.possible", [$biomes]));
			return true;
		}
		$player = $sender->getServer()->getPlayer($sender->getName());
		$biome = strtoupper($args[0]);
		$plot = $this->getPlugin()->getPlotByPosition($player);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.biome")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(is_numeric($biome)) {
			$biome = (int) $biome;
			if($biome > 27 or $biome < 0) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.invalid"));
				$biomes = implode(", ", array_keys($this->biomes));
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.possible", [$biomes]));
				return true;
			}
			$biome = Biome::getBiome($biome);
		}else{
			if(constant(Biome::class."::".$biome) === null) {
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.invalid"));
				$biomes = implode(", ", array_keys($this->biomes));
				$sender->sendMessage(TextFormat::RED . $this->translateString("biome.possible", [$biomes]));
				return true;
			}
			$biome = Biome::getBiome(constant(Biome::class."::".$biome));
		}
		if($this->getPlugin()->setPlotBiome($plot, $biome)) {
			$sender->sendMessage($this->translateString("biome.success", [$biome->getName()]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use MyPlot\Plot;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class HomeSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.home");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			$plotNumber = 1;
		}elseif(is_numeric($args[0])) {
			$plotNumber = (int) $args[0];
		}else{
			return false;
		}
		$levelName = $args[1] ?? $sender->getLevel()->getFolderName();
		$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
		if(empty($plots)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("home.noplots"));
			return true;
		}
		if(!isset($plots[$plotNumber - 1])) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("home.notexist", [$plotNumber]));
			return true;
		}
		usort($plots, function(Plot $plot1, Plot $plot2) {
			if($plot1->levelName == $plot2->levelName) {
				return 0;
			}
			return ($plot1->levelName < $plot2->levelName) ? -1 : 1;
		});
		$plot = $plots[$plotNumber - 1];
		if($this->getPlugin()->teleportPlayerToPlot($sender, $plot)) {
			$sender->sendMessage($this->translateString("home.success", [$plot, $plot->levelName]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("home.error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class HomesSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.homes");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$levelName = $args[0] ?? $sender->getLevel()->getFolderName();
		$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
		if(empty($plots)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("homes.noplots"));
			return true;
		}
		$sender->sendMessage(TextFormat::DARK_GREEN . $this->translateString("homes.header"));
		for($i = 0; $i < count($plots); $i++) {
			$plot = $plots[$i];
			$message = TextFormat::DARK_GREEN . ($i + 1) . ") ";
			$message .= TextFormat::WHITE . $plot->levelName . " " . $plot;
			if($plot->name !== "") {
				$message .= " = " . $plot->name;
			}
			$sender->sendMessage($message);
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class NameSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.name");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.name")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if($this->getPlugin()->renamePlot($plot, $args[0])) {
			$sender->sendMessage($this->translateString("name.success"));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class GiveSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.give");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$newOwner = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName()) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$newOwner = $this->getPlugin()->getServer()->getPlayer($newOwner);
		if(!$newOwner instanceof Player) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("give.notonline"));
			return true;
		}elseif($newOwner->getName() === $sender->getName()) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("give.toself"));
			return true;
		}
		$maxPlots = $this->getPlugin()->getMaxPlotsOfPlayer($newOwner);
		$plotsOfPlayer = count($this->getPlugin()->getPlotsOfPlayer($newOwner->getName(), $newOwner->getLevel()->getFolderName()));
		if($plotsOfPlayer >= $maxPlots) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("give.maxedout", [$maxPlots]));
			return true;
		}
		if(count($args) == 2 and $args[1] == $this->translateString("confirm")) {
			if($this->getPlugin()->claimPlot($plot, $newOwner->getName())) {
				$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
				$oldOwnerName = TextFormat::GREEN . $sender->getName() . TextFormat::WHITE;
				$newOwnerName = TextFormat::GREEN . $newOwner->getName() . TextFormat::WHITE;
				$sender->sendMessage($this->translateString("give.success", [$newOwnerName]));
				$newOwner->sendMessage($this->translateString("give.received", [$oldOwnerName, $plotId]));
			}else{
				$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
			}
		}else{
			$plotId = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$newOwnerName = TextFormat::GREEN . $newOwner->getName() . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("give.confirm", [$plotId, $newOwnerName]));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class WarpSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.warp");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$levelName = $args[1] ?? $sender->getLevel()->getFolderName();
		if(!$this->getPlugin()->isLevelLoaded($levelName)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("warp.notinplotworld"));
			return true;
		}
		/** @var string[] $plotIdArray */
		$plotIdArray = explode(";", $args[0]);
		if(count($plotIdArray) != 2 or !is_numeric($plotIdArray[0]) or !is_numeric($plotIdArray[1])) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("warp.wrongid"));
			return true;
		}
		$plot = $this->getPlugin()->getProvider()->getPlot($levelName, (int) $plotIdArray[0], (int) $plotIdArray[1]);
		if($plot->owner == "" and !$sender->hasPermission("myplot.admin.warp")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("warp.unclaimed"));
			return true;
		}
		if($this->getPlugin()->teleportPlayerToPlot($sender, $plot)) {
			$plot = TextFormat::GREEN . $plot . TextFormat::WHITE;
			$sender->sendMessage($this->translateString("warp.success", [$plot]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("generate.error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class MiddleSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and ($sender->hasPermission("myplot.command.middle"));
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(count($args) != 0) {
			return false;
		}
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.middle")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if($this->getPlugin()->teleportPlayerToPlot($sender, $plot, true)) {
			$sender->sendMessage(TextFormat::GREEN . $this->translateString("middle.success"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class DenyPlayerSubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.denyplayer");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$dplayer = strtolower($args[0]);
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.denyplayer")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		$dplayer = $this->getPlugin()->getServer()->getPlayer($dplayer) ?? $this->getPlugin()->getServer()->getOfflinePlayer($dplayer);
		if(!$dplayer instanceof Player) {
			$sender->sendMessage($this->translateString("denyplayer.notaplayer"));
			return true;
		}
		if($dplayer->hasPermission("myplot.admin.denyplayer.bypass") or $dplayer->getName() === $plot->owner) {
			$sender->sendMessage($this->translateString("denyplayer.cannotdeny", [$dplayer->getName()]));
			if($dplayer instanceof Player)
				$dplayer->sendMessage($this->translateString("denyplayer.attempteddeny", [$sender->getName()]));
			return true;
		}
		if($this->getPlugin()->addPlotDenied($plot, $dplayer->getName())) {
			$sender->sendMessage($this->translateString("denyplayer.success1", [$dplayer->getName()]));
			if($dplayer instanceof Player) {
				$dplayer->sendMessage($this->translateString("denyplayer.success2", [$plot->X, $plot->Z, $sender->getName()]));
			}
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class UnDenySubCommand extends SubCommand
{
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.undenyplayer");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$dplayer = $args[0];
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.undenyplayer")) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notowner"));
			return true;
		}
		if(!$plot->unDenyPlayer($dplayer)) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("undenyplayer.failure", [$dplayer]));
			return true;
		}
		$dplayer = $this->getPlugin()->getServer()->getPlayer($dplayer) ?? $this->getPlugin()->getServer()->getOfflinePlayer($dplayer);
		if($this->getPlugin()->removePlotDenied($plot, $dplayer->getName())) {
			$sender->sendMessage($this->translateString("undenyplayer.success1", [$dplayer->getName()]));
			if($dplayer instanceof Player) {
				$dplayer->sendMessage($this->translateString("undenyplayer.success2", [$plot->X, $plot->Z, $sender->getName()]));
			}
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SetOwnerSubCommand extends SubCommand {
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.admin.setowner");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if(empty($args)) {
			return false;
		}
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("notinplot"));
			return true;
		}
		$maxPlots = $this->getPlugin()->getMaxPlotsOfPlayer($sender);
		$plotsOfPlayer = 0;
		foreach($this->getPlugin()->getPlotLevels() as $level => $settings) {
			$level = $this->getPlugin()->getServer()->getLevelByName($level);
			if(!$level->isClosed()) {
				$plotsOfPlayer += count($this->getPlugin()->getPlotsOfPlayer($sender->getName(), $level->getFolderName()));
			}
		}
		if($plotsOfPlayer >= $maxPlots) {
			$sender->sendMessage(TextFormat::RED . $this->translateString("setowner.maxplots", [$maxPlots]));
			return true;
		}
		if($this->getPlugin()->claimPlot($plot, $args[0])) {
			$sender->sendMessage($this->translateString("setowner.success", [$plot->owner]));
		}else{
			$sender->sendMessage(TextFormat::RED . $this->translateString("error"));
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat as TF;

class ListSubCommand extends SubCommand {
	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.list");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		if($sender->hasPermission("myplot.admin.list")) {
			if(!empty($args)) {
				foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
					$plots = $this->getPlugin()->getPlotsOfPlayer($args[0], $levelName);
					foreach($plots as $plot) {
						$name = $plot->name;
						$x = $plot->X;
						$z = $plot->Z;
						$sender->sendMessage(TF::YELLOW . $this->translateString("list.found", [$name, $x, $z]));
					}
				}
			}else{
				foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
					$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
					foreach($plots as $plot) {
						$name = $plot->name;
						$x = $plot->X;
						$z = $plot->Z;
						$sender->sendMessage(TF::YELLOW . $this->translateString("list.found", [$name, $x, $z]));
					}
					return true;
				}
			}
		}elseif($sender->hasPermission("myplot.command.list")) {
			foreach($this->getPlugin()->getPlotLevels() as $levelName => $settings) {
				$plots = $this->getPlugin()->getPlotsOfPlayer($sender->getName(), $levelName);
				foreach($plots as $plot) {
					$name = $plot->name;
					$x = $plot->X;
					$z = $plot->Z;
					$sender->sendMessage(TF::YELLOW . $this->translateString("list.found", [$name, $x, $z]));
				}
			}
		}
		return true;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\subcommand;

use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class PvpSubCommand extends SubCommand {

	/**
	 * @param CommandSender $sender
	 *
	 * @return bool
	 */
	public function canUse(CommandSender $sender) : bool {
		return ($sender instanceof Player) and $sender->hasPermission("myplot.command.pvp");
	}

	/**
	 * @param Player $sender
	 * @param string[] $args
	 *
	 * @return bool
	 */
	public function execute(CommandSender $sender, array $args) : bool {
		$plot = $this->getPlugin()->getPlotByPosition($sender);
		if($plot === null) {
			$sender->sendMessage(TextFormat::RED.$this->translateString("notinplot"));
			return true;
		}
		if($plot->owner !== $sender->getName() and !$sender->hasPermission("myplot.admin.pvp")) {
			$sender->sendMessage(TextFormat::RED.$this->translateString("notowner"));
			return true;
		}
		$levelSettings = $this->getPlugin()->getLevelSettings($sender->level->getFolderName());
		if($levelSettings->restrictPVP) {
			$sender->sendMessage(TextFormat::RED.$this->translateString("pvp.world"));
			return true;
		}
		if($this->getPlugin()->setPlotPvp($plot, !$plot->pvp)) {
			$sender->sendMessage($this->translateString("pvp.success", [$plot->pvp ? "enabled" : "disabled"]));
		}else {
			$sender->sendMessage(TextFormat::RED.$this->translateString("error"));
		}
		return true;
	}
}<?php
namespace MyPlot\libs\spoondetector;

use pocketmine\plugin\PluginBase;
use pocketmine\Server;

/**
 * This class is deliberately meant to be silly
 * Class SpoonDetector
 * @package falkirks\simplewarp\utils
 */
class SpoonDetector{

    private static $subtleAsciiSpoon = "   
         ___ _ __   ___   ___  _ __  
        / __| '_ \\ / _ \\ / _ \\| '_ \\ 
        \\__ \\ |_) | (_) | (_) | | | |
        |___/ .__/ \\___/ \\___/|_| |_|
            | |                      
            |_|                      
    ";

    private static $spoonTxtContent = "
    The author of this plugin does not provide support for third-party builds of 
    PocketMine-MP (spoons). Spoons detract from the overall quality of the MCPE plugin environment, which is already 
    lacking in quality. They force plugin developers to waste time trying to support conflicting APIs.
    
    In order to begin using this plugin you must understand that you will be offered no support. 
    
    Furthermore, the GitHub issue tracker for this project is targeted at vanilla PocketMine only. Any bugs you create which don't affect vanilla PocketMine, will be deleted.
    
    Have you read and understood the above (type 'yes' after the question mark)?";

    private static $thingsThatAreNotSpoons = [
        'PocketMine-MP'
    ];

    public static function isThisSpoon() : bool {
        return !in_array(Server::getInstance()->getName(), self::$thingsThatAreNotSpoons);
    }

    private static function contentValid(string $content): bool {
        return (strpos($content, self::$spoonTxtContent) !== false) && (strrpos($content, "yes") > strrpos($content, "?"));
    }

    public static function printSpoon(PluginBase $pluginBase, $fileToCheck){
        if(self::isThisSpoon()){
            if(!file_exists($pluginBase->getDataFolder() . $fileToCheck)){
                file_put_contents($pluginBase->getDataFolder() . $fileToCheck, self::$spoonTxtContent);
            }
            if(!self::contentValid(file_get_contents($pluginBase->getDataFolder() . $fileToCheck))) {
                $pluginBase->getLogger()->info(self::$subtleAsciiSpoon);
                $pluginBase->getLogger()->warning("You are attempting to run " . $pluginBase->getDescription()->getName() . " on a SPOON!");
                $pluginBase->getLogger()->warning("Before using the plugin you will need to open /plugins/" . $pluginBase->getDescription()->getName() . "/" . $fileToCheck . " in a text editor and agree to the terms.");
                $pluginBase->getServer()->getPluginManager()->disablePlugin($pluginBase);
            }
        }
    }

}
<?php
declare(strict_types=1);
namespace MyPlot\provider;

use onebone\economyapi\EconomyAPI;
use pocketmine\Player;

class EconomySProvider implements EconomyProvider
{
	/** @var EconomyAPI $plugin */
	private $plugin;

	/**
	 * EconomySProvider constructor.
	 *
	 * @param EconomyAPI $plugin
	 */
	public function __construct(EconomyAPI $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool {
		if($amount === 0) {
			return true;
		}elseif($amount < 0) {
			$amount = -$amount;
		}
		$ret = $this->plugin->reduceMoney($player, $amount, true, "MyPlot");
		if($ret === EconomyAPI::RET_SUCCESS) {
			$this->plugin->getLogger()->debug("MyPlot Reduced money of " . $player->getName());
			return true;
		}
		$this->plugin->getLogger()->debug("MyPlot failed to reduce money of ".$player->getName());
		return false;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use pocketmine\Player;

interface EconomyProvider {
	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool;
}<?php
declare(strict_types=1);
namespace MyPlot;

use MyPlot\events\MyPlotBlockEvent;
use MyPlot\events\MyPlotPlayerEnterPlotEvent;
use MyPlot\events\MyPlotPlayerLeavePlotEvent;
use MyPlot\events\MyPlotPvpEvent;
use pocketmine\block\Sapling;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\block\BlockSpreadEvent;
use pocketmine\event\block\SignChangeEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityExplodeEvent;
use pocketmine\event\entity\EntityMotionEvent;
use pocketmine\event\level\LevelLoadEvent;
use pocketmine\event\level\LevelUnloadEvent;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\Player;
use pocketmine\utils\Config;
use pocketmine\utils\TextFormat;

class EventListener implements Listener
{
	/** @var MyPlot $plugin */
	private $plugin;

	/**
	 * EventListener constructor.
	 *
	 * @param MyPlot $plugin
	 */
	public function __construct(MyPlot $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param LevelLoadEvent $event
	 */
	public function onLevelLoad(LevelLoadEvent $event) : void {
		if(file_exists($this->plugin->getDataFolder()."worlds".DIRECTORY_SEPARATOR.$event->getLevel()->getFolderName().".yml")) {
			$this->plugin->getLogger()->debug("MyPlot level " . $event->getLevel()->getFolderName() . " loaded!");
			$settings = $event->getLevel()->getProvider()->getGeneratorOptions();
			if(!isset($settings["preset"]) or empty($settings["preset"])) {
				return;
			}
			$settings = json_decode($settings["preset"], true);
			if($settings === false) {
				return;
			}
			$levelName = $event->getLevel()->getFolderName();
			$default = $this->plugin->getConfig()->get("DefaultWorld", []);
			$config = new Config($this->plugin->getDataFolder()."worlds".DIRECTORY_SEPARATOR.$levelName.".yml", Config::YAML, $default);
			foreach(array_keys($default) as $key) {
				$settings[$key] = $config->get($key);
			}
			$this->plugin->addLevelSettings($levelName, new PlotLevelSettings($levelName, $settings));
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority MONITOR
	 *
	 * @param LevelUnloadEvent $event
	 */
	public function onLevelUnload(LevelUnloadEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getLevel()->getFolderName();
		if($this->plugin->unloadLevelSettings($levelName)) {
			$this->plugin->getLogger()->debug("Level " . $event->getLevel()->getFolderName() . " unloaded!");
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param BlockPlaceEvent $event
	 */
	public function onBlockPlace(BlockPlaceEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param BlockBreakEvent $event
	 */
	public function onBlockBreak(BlockBreakEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param PlayerInteractEvent $event
	 */
	public function onPlayerInteract(PlayerInteractEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param SignChangeEvent $event
	 */
	public function onSignChange(SignChangeEvent $event) : void {
		$this->onEventOnBlock($event);
	}

	/**
	 * @param BlockPlaceEvent|BlockBreakEvent|PlayerInteractEvent|SignChangeEvent $event
	 */
	private function onEventOnBlock($event) : void {
		$levelName = $event->getBlock()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName)) {
			return;
		}
		$plot = $this->plugin->getPlotByPosition($event->getBlock());
		if($plot !== null) {
			$ev = new MyPlotBlockEvent($plot, $event->getBlock(), $event->getPlayer(), $event);
			if($event->isCancelled()) {
				$ev->setCancelled($event->setCancelled());
			}
			$ev->call();
			$event->setCancelled($ev->isCancelled());
			$username = $event->getPlayer()->getName();
			if($plot->owner == $username or $plot->isHelper($username) or $plot->isHelper("*") or $event->getPlayer()->hasPermission("myplot.admin.build.plot")) {
				if(!($event instanceof PlayerInteractEvent and $event->getBlock() instanceof Sapling))
					return;
				/*
				 * Prevent growing a tree near the edge of a plot
				 * so the leaves won't go outside the plot
				 */
				$block = $event->getBlock();
				$maxLengthLeaves = (($block->getDamage() & 0x07) == Sapling::SPRUCE) ? 3 : 2;
				$beginPos = $this->plugin->getPlotPosition($plot);
				$endPos = clone $beginPos;
				$beginPos->x += $maxLengthLeaves;
				$beginPos->z += $maxLengthLeaves;
				$plotSize = $this->plugin->getLevelSettings($levelName)->plotSize;
				$endPos->x += $plotSize - $maxLengthLeaves;
				$endPos->z += $plotSize - $maxLengthLeaves;
				if($block->x >= $beginPos->x and $block->z >= $beginPos->z and $block->x < $endPos->x and $block->z < $endPos->z) {
					return;
				}
			}
		}elseif($event->getPlayer()->hasPermission("myplot.admin.build.road"))
			return;
		$event->setCancelled();
		$this->plugin->getLogger()->debug("Block placement cancelled");
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param EntityExplodeEvent $event
	 */
	public function onExplosion(EntityExplodeEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getEntity()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$plot = $this->plugin->getPlotByPosition($event->getPosition());
		if($plot === null) {
			$event->setCancelled();
			return;
		}
		$beginPos = $this->plugin->getPlotPosition($plot);
		$endPos = clone $beginPos;
		$plotSize = $this->plugin->getLevelSettings($levelName)->plotSize;
		$endPos->x += $plotSize;
		$endPos->z += $plotSize;
		$blocks = array_filter($event->getBlockList(), function($block) use ($beginPos, $endPos) {
			if($block->x >= $beginPos->x and $block->z >= $beginPos->z and $block->x < $endPos->x and $block->z < $endPos->z) {
				return true;
			}
			return false;
		});
		$event->setBlockList($blocks);
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param EntityMotionEvent $event
	 */
	public function onEntityMotion(EntityMotionEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getEntity()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$settings = $this->plugin->getLevelSettings($levelName);
		if($settings->restrictEntityMovement and !($event->getEntity() instanceof Player)) {
			$event->setCancelled();
			$this->plugin->getLogger()->debug("Cancelled entity motion on " . $levelName);
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param BlockSpreadEvent $event
	 */
	public function onBlockSpread(BlockSpreadEvent $event) : void {
		if($event->isCancelled()) {
			return;
		}
		$levelName = $event->getBlock()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$settings = $this->plugin->getLevelSettings($levelName);
		if(!$settings->updatePlotLiquids) {
			$event->setCancelled();
			$this->plugin->getLogger()->debug("Cancelled block spread on " . $levelName);
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param PlayerMoveEvent $event
	 */
	public function onPlayerMove(PlayerMoveEvent $event) : void {
		if(!$this->plugin->getConfig()->get("ShowPlotPopup", true))
			return;
		$levelName = $event->getPlayer()->getLevel()->getFolderName();
		if(!$this->plugin->isLevelLoaded($levelName))
			return;
		$plot = $this->plugin->getPlotByPosition($event->getTo());
		if($plot !== null and $plot !== $this->plugin->getPlotByPosition($event->getFrom())) {
			$ev = new MyPlotPlayerEnterPlotEvent($plot, $event->getPlayer());
			$ev->setCancelled($event->isCancelled());
			if($plot->isDenied($event->getPlayer()->getName())) {
				$ev->setCancelled();
				return;
			}
			if(strpos((string) $plot, "-0")) {
				return;
			}
			$ev->call();
			$event->setCancelled($ev->isCancelled());
			if($event->isCancelled()) {
				return;
			}
			$popup = $this->plugin->getLanguage()->translateString("popup", [TextFormat::GREEN . $plot]);
			if($plot->owner !== "") {
				$owner = TextFormat::GREEN . $plot->owner;
				$ownerPopup = $this->plugin->getLanguage()->translateString("popup.owner", [$owner]);
				$paddingSize = (int) floor((strlen($popup) - strlen($ownerPopup)) / 2);
				$paddingPopup = str_repeat(" ", max(0, -$paddingSize));
				$paddingOwnerPopup = str_repeat(" ", max(0, $paddingSize));
				$popup = TextFormat::WHITE . $paddingPopup . $popup . "\n" . TextFormat::WHITE . $paddingOwnerPopup . $ownerPopup;
			}else{
				$ownerPopup = $this->plugin->getLanguage()->translateString("popup.available");
				$paddingSize = (int) floor((strlen($popup) - strlen($ownerPopup)) / 2);
				$paddingPopup = str_repeat(" ", max(0, -$paddingSize));
				$paddingOwnerPopup = str_repeat(" ", max(0, $paddingSize));
				$popup = TextFormat::WHITE . $paddingPopup . $popup . "\n" . TextFormat::WHITE . $paddingOwnerPopup . $ownerPopup;
			}
			$event->getPlayer()->sendTip($popup);
		}elseif($plot === null and ($plot = $this->plugin->getPlotByPosition($event->getFrom())) !== null) {
			$ev = new MyPlotPlayerLeavePlotEvent($plot, $event->getPlayer());
			$ev->setCancelled($event->isCancelled());
			$ev->call();
			$event->setCancelled($ev->isCancelled());
		}
	}

	/**
	 * @ignoreCancelled false
	 * @priority LOWEST
	 *
	 * @param EntityDamageByEntityEvent $event
	 */
	public function onEntityDamage(EntityDamageByEntityEvent $event) : void {
		if($event->getEntity() instanceof Player and $event->getDamager() instanceof Player) {
			$levelName = $event->getEntity()->getLevel()->getFolderName();
			if(!$this->plugin->isLevelLoaded($levelName)) {
				return;
			}
			$settings = $this->plugin->getLevelSettings($levelName);
			$plot = $this->plugin->getPlotByPosition($event->getEntity());
			if($plot !== null) {
				/** @noinspection PhpParamsInspection */
				$ev = new MyPlotPvpEvent($plot, $event->getDamager(), $event->getEntity(), $event);
				$ev->setCancelled($event->isCancelled());
				/** @noinspection PhpUndefinedMethodInspection */
				if(($settings->restrictPVP or !$plot->pvp) and !$event->getDamager()->hasPermission("myplot.admin.pvp.bypass")) {
					$ev->setCancelled();
					$this->plugin->getLogger()->debug("Cancelled pvp event in plot ".$plot->X.";".$plot->Z." on level '" . $levelName . "'");
				}
				$ev->call();
				$event->setCancelled($ev->isCancelled());
				if($event->isCancelled()) {
					$ev->getAttacker()->sendMessage(TextFormat::RED . $this->plugin->getLanguage()->translateString("pvp.disabled")); // generic message- we dont know if by config or plot
				}
				return;
			}
			/** @noinspection PhpUndefinedMethodInspection */
			if($event->isCancelled() or $event->getDamager()->hasPermission("myplot.admin.pvp.bypass")) {
				return;
			}
			if($settings->restrictPVP) {
				$event->setCancelled();
				/** @noinspection PhpUndefinedMethodInspection */
				$event->getDamager()->sendMessage(TextFormat::RED.$this->plugin->getLanguage()->translateString("pvp.world"));
				$this->plugin->getLogger()->debug("Cancelled pvp event on ".$levelName);
			}
		}
	}
}<?php
declare(strict_types=1);
namespace MyPlot;

use pocketmine\block\Block;

class PlotLevelSettings
{
	/** @var string $name */
	public $name;
	/** @var Block */
	public $roadBlock, $wallBlock, $plotFloorBlock, $plotFillBlock, $bottomBlock;
	/** @var int */
	public $roadWidth = 7, $plotSize = 32, $groundHeight = 64, $claimPrice = 0, $clearPrice = 0, $disposePrice = 0, $resetPrice = 0;
	/** @var bool */
	public $restrictEntityMovement = true, $restrictPVP = false, $updatePlotLiquids = false, $displayDoneNametags = false;

	/**
	 * PlotLevelSettings constructor.
	 *
	 * @param string $name
	 * @param array $settings
	 */
	public function __construct(string $name, array $settings = []) {
		$this->name = $name;
		if(!empty($settings)) {
			$this->roadBlock = self::parseBlock($settings, "RoadBlock", Block::get(Block::PLANKS));
			$this->wallBlock = self::parseBlock($settings, "WallBlock", Block::get(Block::STONE_SLAB));
			$this->plotFloorBlock = self::parseBlock($settings, "PlotFloorBlock", Block::get(Block::GRASS));
			$this->plotFillBlock = self::parseBlock($settings, "PlotFillBlock", Block::get(Block::DIRT));
			$this->bottomBlock = self::parseBlock($settings, "BottomBlock", Block::get(Block::BEDROCK));
			$this->roadWidth = self::parseNumber($settings, "RoadWidth", 7);
			$this->plotSize = self::parseNumber($settings, "PlotSize", 32);
			$this->groundHeight = self::parseNumber($settings, "GroundHeight", 64);
			$this->claimPrice = self::parseNumber($settings, "ClaimPrice", 0);
			$this->clearPrice = self::parseNumber($settings, "ClearPrice", 0);
			$this->disposePrice = self::parseNumber($settings, "DisposePrice", 0);
			$this->resetPrice = self::parseNumber($settings, "ResetPrice", 0);
			$this->restrictEntityMovement = self::parseBool($settings, "RestrictEntityMovement", true);
			$this->restrictPVP = self::parseBool($settings, "RestrictPVP", false);
			$this->updatePlotLiquids = self::parseBool($settings, "UpdatePlotLiquids", false);
		}
	}

	/**
	 * @param array $array
	 * @param string|int $key
	 * @param Block $default
	 *
	 * @return Block
	 */
	public static function parseBlock(array &$array, $key, Block $default) : Block {
		if(isset($array[$key])) {
			$id = $array[$key];
			if(is_numeric($id)) {
				$block = Block::get((int) $id);
			}else{
				$split = explode(":", $id);
				if(count($split) === 2 and is_numeric($split[0]) and is_numeric($split[1])) {
					$block = Block::get((int) $split[0], (int) $split[1]);
				}else{
					$block = $default;
				}
			}
		}else{
			$block = $default;
		}
		return $block;
	}

	/**
	 * @param array $array
	 * @param string|int $key
	 * @param int $default
	 *
	 * @return int
	 */
	public static function parseNumber(array &$array, $key, int $default) : int {
		if(isset($array[$key]) and is_numeric($array[$key])) {
			return (int) $array[$key];
		}else{
			return $default;
		}
	}

	/**
	 * @param array $array
	 * @param string|int $key
	 * @param bool $default
	 *
	 * @return bool
	 */
	public static function parseBool(array &$array, $key, bool $default) : bool {
		if(isset($array[$key]) and is_bool($array[$key])) {
			return (bool) $array[$key];
		}else{
			return $default;
		}
	}
}<?php
declare(strict_types=1);
namespace MyPlot;

class Plot
{

	public $levelName = "", $X = -0, $Z = -0, $name = "", $owner = "", $helpers = [], $denied = [], $biome = "PLAINS", $pvp = true, $id = -1;

	/**
	 * Plot constructor.
	 *
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 * @param string $name
	 * @param string $owner
	 * @param array $helpers
	 * @param array $denied
	 * @param string $biome
	 * @param bool $pvp
	 * @param int $id
	 */
	public function __construct(string $levelName, int $X, int $Z, string $name = "", string $owner = "", array $helpers = [], array $denied = [], string $biome = "PLAINS", $pvp = true, int $id = -1) {
		$this->levelName = $levelName;
		$this->X = $X;
		$this->Z = $Z;
		$this->name = $name;
		$this->owner = $owner;
		$this->helpers = $helpers;
		$this->denied = $denied;
		$this->biome = strtoupper($biome);
		$settings = MyPlot::getInstance()->getLevelSettings($levelName);
		if($settings !== null) {
			$this->pvp = !$settings->restrictPVP;
		}else{
			$this->pvp = $pvp;
		}
		$this->id = $id;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function isHelper(string $username) : bool {
		return in_array($username, $this->helpers);
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function addHelper(string $username) : bool {
		if(!$this->isHelper($username)) {
			$this->unDenyPlayer($username);
			$this->helpers[] = $username;
			return true;
		}
		return false;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function removeHelper(string $username) : bool {
		if(!$this->isHelper($username)) {
			return false;
		}
		$key = array_search($username, $this->helpers);
		if($key === false) {
			return false;
		}
		unset($this->helpers[$key]);
		return true;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function isDenied(string $username) : bool {
		return in_array($username, $this->denied);
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function denyPlayer(string $username) : bool {
		if(!$this->isDenied($username)) {
			$this->removeHelper($username);
			$this->denied[] = $username;
			return true;
		}
		return false;
	}

	/**
	 * @api
	 *
	 * @param string $username
	 *
	 * @return bool
	 */
	public function unDenyPlayer(string $username) : bool {
		if(!$this->isDenied($username)) {
			return false;
		}
		$key = array_search($username, $this->denied);
		if($key === false) {
			return false;
		}
		unset($this->denied[$key]);
		return true;
	}

	/**
	 * @return string
	 */
	public function __toString() : string {
		return "(" . $this->X . ";" . $this->Z . ")";
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class MyPlotPlayerEnterPlotEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;
	/** @var Player $player */
	private $player;

	/**
	 * MyPlotPlayerEnterPlotEvent constructor.
	 *
	 * @param Plot $plot
	 * @param Player $player
	 */
	public function __construct(Plot $plot, Player $player) {
		$this->player = $player;
		parent::__construct($plot);
	}

	/**
	 * @return Player
	 */
	public function getPlayer() : Player {
		return $this->player;
	}

	/**
	 * @param Player $player
	 */
	public function setPlayer(Player $player) {
		$this->player = $player;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Event;

class MyPlotPlotEvent extends Event {
	/** @var Plot $plot */
	protected $plot;

	public function __construct(Plot $plot) {
		$this->plot = $plot;
	}

	/**
	 * @return Plot
	 */
	public function getPlot() : Plot {
		return $this->plot;
	}

	/**
	 * @param Plot $plot
	 */
	public function setPlot(Plot $plot) : void {
		$this->plot = $plot;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\block\Block;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\block\SignChangeEvent;
use pocketmine\event\Cancellable;
use pocketmine\event\Event;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\Player;

class MyPlotBlockEvent extends MyPlotPlotEvent implements Cancellable {
	/** @var Block $block */
	private $block;
	/** @var Event $event */
	private $event;
	/** @var Player $player */
	private $player;

	public function __construct(Plot $plot, Block $block, Player $player, Event $event) {
		$this->block = $block;
		$this->player = $player;
		$this->event = $event;
		parent::__construct($plot);
	}

	/**
	 * @return Block
	 */
	public function getBlock() : Block {
		return $this->block;
	}

	/**
	 * @return BlockPlaceEvent|BlockBreakEvent|PlayerInteractEvent|SignChangeEvent
	 */
	public function getEvent() : Event {
		return $this->event;
	}

	/**
	 * @return Player
	 */
	public function getPlayer() : Player {
		return $this->player;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class MyPlotPlayerLeavePlotEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;
	/** @var Player $player */
	private $player;

	/**
	 * MyPlotPlayerLeavePlotEvent constructor.
	 *
	 * @param Plot $plot
	 * @param Player $player
	 */
	public function __construct(Plot $plot, Player $player) {
		$this->player = $player;
		parent::__construct($plot);
	}

	/**
	 * @return Player
	 */
	public function getPlayer() : Player {
		return $this->player;
	}

	/**
	 * @param Player $player
	 */
	public function setPlayer(Player $player) {
		$this->player = $player;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\Player;

class MyPlotTeleportEvent extends MyPlotPlayerEnterPlotEvent {
	/** @var bool $center */
	private $center = false;

	public function __construct(Plot $plot, Player $player, bool $center = false) {
		$this->center = $center;
		parent::__construct($plot, $player);
	}

	/**
	 * @return bool
	 */
	public function toCenter() : bool {
		return $this->center;
	}

	/**
	 * @param bool $center
	 */
	public function setToCenter(bool $center) : void {
		$this->center = $center;
	}
}; Chinese(PRC) language pack for MyPlot
; Created by jerryzooyoyo
; Updated time : 2/17/2019

; Popup when entering a plot
popup=你来到了领地 {%0}
popup.owner=这个领地的领主为 {%0}
popup.available=这个领地是无主地! 使用 /p claim 来购买
popup.denied=因为这个领地设置了黑名单,你不得进入!

; /p info
command.name=plot
command.alias=p
command.desc=领地系统总指令
command.usage=/p <help|其他项目> [资讯]
command.unknown=貌似你输入错误了，试试看 /p help 来查看所有指令

subcommand.usage=用法: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=发生错误了！麻烦立刻通报管理员！记得附上图片
notinplot=你并没有站立在指定的领地，请确认位置
notowner=你并不是这个领地的领主，无法使用管理指令
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=显示所有领地系统的指令
help.usage=/p help [页数]
help.header=------ 领地系统指令大全 (记得要写/ p开头啊！) {%0} / {%1} ------

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=对自己的领地添加助手(简写是 addh )
addhelper.usage=/p addhelper <玩家名称>
addhelper.alreadyone={%0} 已经是这个领地的助手了!
addhelper.success={%0} 成功成为领地助手

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=将一个领地助手移除(简写是 delh )
removehelper.usage=/p removehelper <玩家名称>
removehelper.notone={%0} 并不是领地助手
removehelper.success={%0} 成功从领地助手列表移除

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=对自己的领地添加黑名单
denyplayer.usage=/p deny <玩家名称>
denyplayer.helper={%0} 已经是这个领地的助手,不可将其加入黑名单!
denyplayer.alreadyone={%0} 已经被列在这个领地黑名单了!
denyplayer.notaplayer=
denyplayer.cannotdeny={%0} 不能被列入黑名单!
denyplayer.attempteddeny={%0} 尝试要将你列入他的领地黑名单!
denyplayer.success1={%0} 成功列入领地黑名单
denyplayer.success2=你被 {%2} 列入他的领地黑名单!领地: {%0};{%1}

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=为自己的领地移除黑名单
undenyplayer.usage=/p undeny <玩家名称>
undenyplayer.notone={%0} 并没有在领地黑名单内!
undenyplayer.success1={%0} 成功从领地黑名单中移除
undenyplayer.success2=你可以进入 {%2} 的领地 {%0};{%1} 了!
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=购买你所在的领地
claim.usage=/p claim [领地昵称，可不填]
claim.yourplot=这块领地已经是你的领地了
claim.alreadyclaimed=这块领地已经有领主!领主为 {%0}
claim.maxplots=你已经达到玩家领地所有上限!上限为 {%0} 塊
claim.nomoney=你的口袋不够深,没办法购买这个领地
claim.success=成功购买领地,开始你的新生活吧!

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=自动找寻无主领地,方便购买
auto.usage=/p auto (简写是 a )
auto.notplotworld=你并不在住宅区内,请确认位置
auto.success=成功传送到无主领地 ({%0}, {%1})
auto.noplots=目前没有无主领地可以购买喔~

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=卖出领地,保留领地状态
dispose.usage=/p dispose
dispose.confirm=你确定要卖出领地 {%0} ? 如果确定,请输入 /p dispose confirm
dispose.nomoney=你的口袋不够深,没办法卖出此领地
dispose.success=成功卖出领地

; The /p reset Subcommand
reset.name=reset
reset.desc=卖出领地，同时重置领地
reset.usage=/p reset
reset.confirm=你确定要卖出领地 {%0} ? 如果确定,请输入 /p reset confirm
reset.nomoney=你的口袋不够深,没办法卖出此领地
reset.success=成功卖出领地与重置领地

; The /p clear Subcommand
clear.name=clear
clear.desc=重置领地状态,洗白此领地
clear.usage=/p clear
clear.confirm=你确定要重置领地 {%0} ? 如果确定,请输入 /p clear confirm
clear.nomoney=你的口袋不够深,没办法重置此领地
clear.success=成功重置领地

; The /p biome Subcommand
biome.name=biome
biome.desc=更改所在领地的生态系
biome.usage=/p biome [生态系名称]
biome.success=领地生态系成功更改为 {%0}
biome.invalid=不存在此生态系!
biome.possible=可以使用的生态系为: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=列出所有领地生态系
biomes.usage=/p biomes
biomes.possible=可用的领地生态系: {%0}

; The /p name Subcommand
name.name=name
name.desc=设置所在领地的昵称
name.usage=/p name <昵称>
name.success=成功将领地昵称设置为 {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=传送到自己的领地(简写是 h )
home.usage=/p home [领地编号]
home.noplots=你没有任何领地可以传送
home.notexist=你并没有编号为 {%0} 的领地!请输入 /p homes 来查看持有列表
home.success=成功传送到领地 {%0}
home.error=传送失败，请回报管理员

; The /p homes Subcommand
homes.name=homes
homes.desc=列出所有你持有的领地
homes.usage=/p homes
homes.noplots=你没有任何领地可以显示
homes.header=你拥有的领地为:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=显示你所在领地的详细资讯(简写是 i )
info.usage=/p info
info.about=领地 {%0} 的详细资讯
info.plotname=昵称: {%0}
info.owner=领主: {%0}
info.helpers=助手: {%0}
info.denied=
info.biome=生态系: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=创立一个新的住宅区
generate.usage=/p g <名称>
generate.exists=名称 {%0} 的地图已经存在
generate.gexists=
generate.success=成功创立住宅区 {%0}
generate.error=创立失败，请回报管理员

; The /p give Subcommand
give.name=give
give.desc=将你的领地赠送给其他人
give.usage=/p give <玩家名称>
give.notonline=这位玩家尚未在线，无法赠送领地给他
give.maxedout=这位玩家已经达到最大领地数量，无法赠送领地给他
give.toself=你不能把领地赠送给自己
give.confirm=你确定要赠送领地 {%0} 给 {%1} ? 如果确定,请输入 /p give {%1} confirm
give.success=成功将该块领地赠送给 {%0}
give.received={%0} 赠送领地给你, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=传送到某个领地
warp.usage=/p warp <领地编号>
warp.wrongid=领地编号应该使用 X;Z 的格式
warp.notinplotworld=你没有在住宅区，无法传送
warp.unclaimed=你不能传送到一个无主领地
warp.success=成功传送到领地 {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=传送到领地的中心点
middle.usage=/p mid
middle.success=成功传送到领地中心点

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=设置领地的新领主
setowner.usage=/p setowner <玩家名称>
setowner.maxplots=该名玩家已达领地上限!领地上限: {%0}
setowner.success={%0} 现在成为领地的领主了

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=列出一名玩家的所有持有领地
list.usage=/p list <玩家名称>
list.found="领地 {%0} 座标为 ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=
pvp.world=
pvp.plot=
pvp.success=#########################################
# ___  ___       ______  _         _    #
# |  \/  |       | ___ \| |       | |   #
# | .  . | _   _ | |_/ /| |  ___  | |_  #
# | |\/| || | | ||  __/ | | / _ \ | __| #
# | |  | || |_| || |    | || (_) || |_  #
# \_|  |_/ \__, |\_|    |_| \___/  \__| #
#           __/ |                       #
#          |___/                        #
#########################################

# The language that should be used in MyPlot
# Available languages: eng, nld, vie, spa, chs, zho, deu, cze, tur, kor, fre
#
# English language pack by @jasonwynn10
# Dutch language pack by @Wies
# Vietnamese language pack by @daany123
# Spanish language pack by @thelucyclub
# Chinese ( ROC ) pack by @jerryzooyoyo
# Chinese ( PRC ) pack by @jerryzooyoyo
# German language pack by @morpheusTP and @SalmonGER
# Czech language pack by @GamakCZ
# Turkish language pack by @Eren5960
# Korean language pack by @Johnmacrocraft
# French language pack by @ad5001
language: eng

# The data provider where plot data is stored.
# Current providers are: sqlite, mysql, json, and yaml.
DataProvider: sqlite

# contains settings for mysql provider to use when selected
MySQLSettings:
  Host: 127.0.0.1
  Port: 3306
  Username: default
  Password: password
  DatabaseName: MyPlot
  ShutdownOnFailure: false

# Use an economy with MyPlot. This will allow for plot pricing such as claiming, clearing, etc.
# Currently supported economy plugins: Economy$, PocketMoney, EssentialsPE, EconomyPlus
# Be sure not to use more than 1 economy plugin!
UseEconomy: false

# Amount of plots to be cached.
# Increasing this number will improve performance, but also increase memory usage.
PlotCacheSize: 256

# When a player enters a plot, a popup with basic info will be shown
ShowPlotPopup: true

# Amount of blocks to reset per tick.
# Increasing this number will speed up '/p clear' and '/p reset' but also increases lag
ClearBlocksPerTick: 256

# These settings will be used when creating a new world with the default generator.
DefaultWorld:

  # Restrict entities (e.g. tnt) from moving except falling
  # This will prevent things like tnt cannons from ruining other plots
  RestrictEntityMovement: true

  # Restrict battles between players in plot worlds
  # This setting overrides the settings of individual plots on world generation
  RestrictPVP: false

  # Update liquids (e.g. Water) from updating and moving
  # This will allow things like water to lag the server in plot worlds
  UpdatePlotLiquids: false

  # How much it costs to claim a plot (Economy must be set to 'true')
  ClaimPrice: 0
  # How much it costs to clear a plot (Economy must be set to 'true')
  ClearPrice: 0
  # How much it costs to dispose a plot (Economy must be set to 'true')
  DisposePrice: 0
  # How much it costs to reset a plot (Economy must be set to 'true')
  ResetPrice: 0

  # The size of a plot
  PlotSize: 32
  # The height of a plot
  GroundHeight: 64
  # The width of the road
  RoadWidth: 7

  # The block that the road is made of (Default is Oak Planks)
  RoadBlock: '5:0'
  # The block that plot walls are made of (Default is Stone Slabs)
  WallBlock: '44:0'
  # The block used as the plot floor (Default is Grass)
  PlotFloorBlock: '2:0'
  # The block that fills the rest of the plot (Default is Dirt)
  PlotFillBlock: '3:0'
  # The block at the bottom (Default is Bedrock)
  BottomBlock: '7:0'; Czech language pack for MyPlot
; Created by GamakCZ and PikyCZ
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Vstoupil jsi na pozemek na místě {%0}
popup.owner=Tento pozemek vlastni {%0}
popup.available=Tento pozemek je volny! Muzes si ho zabrat pomoci /p claim
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=prikazy PlotMe
command.usage=Pouziti: /plot <help|prikaz> [nastaveni]
command.unknown=Neznamy prikaz. Prikazy najdes v /p help

subcommand.usage=Pouzij: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Neco se pokazilo!
notinplot=Nestojis na pozemku!
notowner=Tento pozemek ti nepatri!
plugin.disabled=

confirm=potvrdit

; The /p help Subcommand
help.name=help
help.desc=Zobrazi pomoc
help.usage=/p help [stranka]
help.header=--- Zobrazuji MyPlot pomocnou stranku {%0} z {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Prida Kamarada(ku) Na tvuj pozemek.
addhelper.usage=/p addhelper <kamarad>
addhelper.alreadyone={%0} tento(tato) kamarad(ka) ti jiz pomaha.
addhelper.success={%0} se stal(a) tvim pomocnikem.

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Odstrani kamarada(ku) z pozemku.
removehelper.usage=/p removehelper <hrac>
removehelper.notone={%0} nebyl(a) tvuj pomocnik na tvem pozemku!
removehelper.success={%0} byl(a) odstranen z tvych pomocniku!

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=odepre pristup hraci na tvem pozemku.
denyplayer.usage=/p deny <hrac>
denyplayer.helper={%0} je pomocnik!
denyplayer.alreadyone={%0} jiz byl odepren pristup.
denyplayer.notaplayer=Tento hrac neni online!
denyplayer.cannotdeny={%0} nelze odeprit prisup!
denyplayer.attempteddeny={%0} pokousel vam odeprit pristup!
denyplayer.success1={%0} Nyni je odepren pristup k pozemku.
denyplayer.success2=Byl ti odepren pristup k pozemku {%0};{%1} od {%2}

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=umozni hraci pristup na pozemek!
undenyplayer.usage=/p undeny <hrac>
undenyplayer.notone={%0} jiz je povolen!
undenyplayer.success1={%0} byl povolen na pozemek!
undenyplayer.success2=Mas pristup na pozemek {%0};{%1} od {%2}
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=Zabere pozemek, na kterem se nachazis
claim.usage=/p claim [jmeno]
claim.yourplot=Jiz jsi si zabral(a) tento pozemek.
claim.alreadyclaimed=Tento pozemek jiz vlastni hrac {%0}
claim.maxplots=Muzes mit maximalne {%0} pozemku!
claim.nomoney=Nemas penize pro zakoupeni tohoto pozemku!
claim.success=Uspesne jsi si zabral(a) tento pozemek.

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleportuje te na volny pozemek.
auto.usage=/p auto
auto.notplotworld=Aby tento prikaz fungoval, musis byt v Plot svete.
auto.success=Byl(a) jsi teleportovan(a) na pozemek ({%0}, {%1}).
auto.noplots=Nejsou tu zadne pozemky!

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Odebere ti pozemek
dispose.usage=/p dispose
dispose.confirm=Opravdu se chces zbacit pozemku {%0} ? pokud ano, napis /p dispose confirm
dispose.nomoney=Nemas dostatek penez na prodani pozemku!
dispose.success=Plot byl znicen.

; The /p reset Subcommand
reset.name=reset
reset.desc=resetuje pozemek
reset.usage=/p reset
reset.confirm=Opravdu chces resetovat pozemek {%0} ? pokud ano napis, /p reset confirm
reset.nomoney=Nemas penize na resetovani pozemku!
reset.success=Plot byl resetovan.

; The /p clear Subcommand
clear.name=clear
clear.desc=Vycisti pozemek
clear.usage=/p clear
clear.confirm=Opravdu chces vycistit pozemek {%0} ? pokud ano napis, /p clear confirm
clear.nomoney=Nemas penize na pozemek!
clear.success=Pozemek vycisten.

; The /p biome Subcommand
biome.name=biome
biome.desc=Zmeni biom tveho plotu
biome.usage=/p biome [biome]
biome.success=Pozemkovy biom je {%0}
biome.invalid=Tenot biom neexistuje!
biome.possible=Mozne biomy jsou: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List dostupnych biomu
biomes.usage=/p biomes
biomes.possible=Mozne biommy jsou: {%0}

; The /p name Subcommand
name.name=name
name.desc=Nastavi nebo zmeni nazev tveho pozemku
name.usage=/p name <nazev>
name.success=Nazev pozemku byl zmenen na {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Teleportuje te na pozemek
home.usage=/p home [cislo]
home.noplots=ty nemas zadne pozemky!
home.notexist=Pozemek si id {%0} nebyl nalezen!
home.success=Byl jsi teleportovan na pozemek {%0}
home.error=Nelze se teleportovat na tento pozemek!

; The /p homes Subcommand
homes.name=homes
homes.desc=Zobrazi tve pozemky.
homes.usage=/p homes
homes.noplots=Nemas zadne pozemky.
homes.header=Tve pozemky:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Zobrazi informace o pozemku
info.usage=/p info
info.about=Informace o plotu {%0}
info.plotname=Nazev pozemku: {%0}
info.owner=Majitel pozemku: {%0}
info.helpers=Pomocnici Majitele pozemku: {%0}
info.denied=
info.biome=Biom pozemku: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Vytvori novy MyPlot svet
generate.usage=/p generate <NazveSveta>
generate.exists=Svet s nazvem {%0} jiz existuje
generate.gexists=Generator {%0} neexistuje
generate.success=Byl vytvoren svet s nazvem {%0}
generate.error=Svet nemuze byt vytvoren

; The /p give Subcommand
give.name=give
give.desc=Preda pozemek danemu hraci
give.usage=/p give [name]
give.notonline=Hrac, kteremu chces pozemek predat musi byt pripojen.
give.maxedout=Tento hrac ma hodne plotu!
give.toself=Nemuzes rozdavat pozemky!
give.confirm=Opravdu chces dat pozemek {%0} hraci {%1}? Pokud ano napis /p give {%1} confirm
give.success=Predal(a) jsi pozemek hraci(ce) {%0}
give.received={%0} ti daroval pozemek, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleportuje te na pozemek
warp.usage=/p warp <id>
warp.wrongid=Plot ID musi byt ve formatu X;Z.
warp.notinplotworld=Musis byt v Plot svete.
warp.unclaimed=Nemuzes se warpovat na plot, ktery nikomu nepatri!
warp.success=Byl jsi teleportovan na pozemek {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleportuje te presne do prosted pozemku!
middle.usage=/p mid
middle.success=Teleportace byla uspesna!

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Nastavi noveho majitele pozemku!
setowner.usage=/p setowner <hrac>
setowner.maxplots=Tento hrac dosahl maximalniho poctu pozemku {%0}!
setowner.success={%0} je novy majitel pozemku!

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Zobrazi vsechny pozemky hrace
list.usage=/p list [hrac]
list.found="Pozemek {%0} na ({%1},{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.success=Pvp is now {%0} for the plot; German language pack for MyPlot
; Created by SalmonDE and morpheus132
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Du hast das Grundstück {%0} betreten.
popup.owner=Dieses Grundstück gehört {%0}.
popup.available=Dieses Grundstück ist verfügbar! Benutze /p claim, um es zu beanspruchen.
popup.denied=Du darfst dieses Grundstück nicht betreten!

; /p info
command.name=plot
command.alias=p
command.desc=Verwalte Grundstücke.
command.usage=/plot <help|Unterbefehl> [Optionen]
command.unknown=Unbekannter Befehl! Benutze /p help, um eine Liste von Befehlen zu erhalten.

subcommand.usage=Syntax: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Ups! Irgendetwas ist falsch gelaufen!
notinplot=Du befindest dich nicht auf einem Grundstück.
notowner=Dieses Grundstück gehört dir nicht!
plugin.disabled=Dieses Plugin ist deaktiviert

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Zeige das Hilfemenü an.
help.usage=/p help [Seite]
help.header=--- Zeige MyPlot Hilfeseite {%0} von {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Füge einen Helfer zu einem Grundstück hinzu.
addhelper.usage=/p addhelper <Spieler>
addhelper.alreadyone={%0} ist bereits ein Helfer von diesem Grundstück!
addhelper.success={%0} wurde zu einem Helfer von diesem Grundstück ernannt.

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Entferne einen Helfer von einem Grundstück.
removehelper.usage=/p removehelper <Spieler>
removehelper.notone={%0} ist kein Helfer von diesem Grundstück!
removehelper.success={%0} ist kein Helfer mehr.

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Verbiete einem Spieler dein Grundstück zu betreten.
denyplayer.usage=/p deny <Spieler>
denyplayer.helper={%0} ist ein Helfer!
denyplayer.alreadyone={%0} ist es bereits verboten, dein Grundstück zu betreten!
denyplayer.notaplayer=Dieser Spieler ist momentan nicht online.
denyplayer.cannotdeny=Du kannst {%0} nicht verbieten, dein Grundstück zu betreten!
denyplayer.attempteddeny={%0} versucht, dich von einem Grundstück zu sperren!
denyplayer.success1={%0} darf dein Grundstück nun nicht mehr betreten.
denyplayer.success2="Du darfst nicht mehr das Grundstück {%0};{%1} von {%2} betreten!"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Entsperre einen Spieler von einem Grundstück.
undenyplayer.usage=/p undeny <player>
undenyplayer.notone={%0} ist bereits entsperrt!
undenyplayer.success1={%0} ist nun entsperrt!
undenyplayer.success2="Du darfst das Grundstück {%0};{%1} von {%2} nun wieder betreten!"
undenyplayer.failure={%0} ist immer noch gesperrt.

; The /p claim Subcommand
claim.name=claim
claim.desc=Beanspruche das Grundstück, auf dem du dich befindest.
claim.usage=/p claim [Name]
claim.yourplot=Dir gehört dieses Grundstück bereits!
claim.alreadyclaimed=Dieses Grundstück gehört bereits {%0}.
claim.maxplots=Du darfst das Limit von {%0} Grundstücken pro Spieler nicht überschreiten!
claim.nomoney=Du besitzt nicht genug Geld, um dieses Grundstück zu kaufen!
claim.success=Du hast dieses Grundstück erfolgreich für dich beansprucht.

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleportiere dich zum nächsten, freien Grundstück.
auto.usage=/p auto
auto.notplotworld=Du bist nicht in einer Grundstückswelt!
auto.success="Du wurdest erfolgreich zu dem Grundstück ({%0};{%1}) teleportiert."
auto.noplots=Es wurde kein verfügbares Grundstück gefunden.

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Gebe dein Grundstück frei.
dispose.usage=/p dispose
dispose.confirm=Bist du sicher, dass du das Grundstück {%0} freigeben möchtest? Wenn ja, benutze /p dispose confirm.
dispose.nomoney=Du besitzt nicht genug Geld, um dieses Grundstück freizugeben.
dispose.success=Das Grundstück wurde freigegeben.

; The /p reset Subcommand
reset.name=reset
reset.desc=Setze ein Grundstück zurück.
reset.usage=/p reset
reset.confirm=Bist du sicher, dass du das Grundstück {%0} zurücksetzen möchtest? Wenn ja, benutze /p reset confirm.
reset.nomoney=Du besitzt nicht genug Geld, um dieses Grundstück zurückzusetzen.
reset.success=Grundstück zurückgesetzt.

; The /p clear Subcommand
clear.name=clear
clear.desc=Leere dein Grundstück
clear.usage=/p clear
clear.confirm=Bist du sicher, dass du das Grundstück {%0} leeren möchtest? Wenn ja, benutze /p clear confirm.
clear.nomoney=Du besitzt nicht genug Geld, um dieses Grundstück zurückzusetzen.
clear.success=Grundstück geleert.

; The /p biome Subcommand
biome.name=biome
biome.desc=Ändere das Biom von einem Grundstück.
biome.usage=/p biome [Biom]
biome.success=Das Grundstücksbiom wurde zu {%0} geändert.
biome.invalid=Dieses Biom existiert nicht!
biome.possible=Verfügbare Biome: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=Liste alle verfügbaren Biome auf.
biomes.usage=/p biomes
biomes.possible=Verfügbare Biome: {%0}

; The /p name Subcommand
name.name=name
name.desc=Benenne ein Grundstück um.
name.usage=/p name <Name>
name.success=Der Name dieses Grundstücks ist nun {%0}.

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Teleportiere dich zu deinem Grundstück
home.usage=/p home [Nummer] [Welt]
home.noplots=Du besitzt keine Grundstücke in dieser Welt.
home.notexist=Du besitzt kein Grundstück mit der ID {%0} in dieser Welt.
home.success=Du wurdest erfolgreich zu dem Grundstück {%0} in der Welt {%1} teleportiert.
home.error=Du konntest nicht zu deinem Grundstück teleportiert werden.

; The /p homes Subcommand
homes.name=homes
homes.desc=Zeige deine beanspruchten Grundstücke an.
homes.usage=/p homes
homes.noplots=Du beanspruchst keine Grundstücke.
homes.header=Grundstücke, die du beanspruchst:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Zeige Informationen über ein Grundstück an.
info.usage=/p info
info.about=Informationen über Grundstück: {%0}
info.plotname=Name: {%0}
info.owner=Besitzer: {%0}
info.helpers=Helfer: {%0}
info.denied=Gesperrt: {%0}
info.biome=Biom: {%0}
info.notfound=Das Grundstück wurde nicht gefunden.

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Generiere eine neue Grundstückswelt.
generate.usage=/p generate <Name> [Generator]
generate.exists=Die Welt {%0} existiert bereits!
generate.gexists=Der Generator {%0} existiert nicht!
generate.success=Die Grundstückswelt {%0} wurde erfolgreich erstellt.
generate.error=Die Welt konnte nicht erstellt werden!

; The /p give Subcommand
give.name=give
give.desc=Gebe dein Grundstück jemand anderen.
give.usage=/p give [Name]
give.notonline=Dieser Spieler ist nicht online.
give.maxedout=Dieser Spieler hat die maximale Anzahl seiner Grundstücke erreicht.
give.toself=Du kannst dir dein Grundstück nicht selbst geben.
give.confirm=Bist du sicher, dass du das Grundstück {%0} dem Spieler {%1} geben möchtest? Wenn ja, benutze /p give {%1} confirm.
give.success=Du hast das Grundstück an {%0} gegeben.
give.received={%0} gab dir das Grundstück: {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleportiere dich zu einem bestimmten Grundstück.
warp.usage=/p warp <ID>
warp.wrongid="Die Grundstück ID sollte in diesem Format sein: X;Z"
warp.notinplotworld=Du bist nicht in einer Grundstückswelt!
warp.unclaimed=Du kannst dich nicht zu einem Grundstück teleportieren, das niemanden gehört.
warp.success=Du wurdest zu dem Grundstück {%0} teleportiert!

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleportiere dich zu dem Mittelpunkt eines Grundstücks
middle.usage=/p mid
middle.success=Du wurdest in die Mitte des Grundstücks teleportiert.

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Setzt einen neuen Besitzer eines Grundstücks.
setowner.usage=/p setowner <Name>
setowner.maxplots=Dieser Spieler hat die maximale Anzahl an Grundstücke von {%0} erreicht.
setowner.success={%0} ist nun der Besitzer von diesem Grundstück.

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Liste alle Grundstücke auf, die ein Spieler beansprucht.
list.usage=/p list [Spieler]
list.found="Grundstück {%0} bei ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Schaltet den PvP-Modus um für das Grundstück
pvp.usage=/p pvp
pvp.world=PvP ist in dieser Grundstückswelt deaktiviert.
pvp.plot=PvP ist auf diesem Grundstück deaktiviert.
pvp.success=PvP-Modus ist nun "{%0}" für das Grundstück
; French language pack for MyPlot
; Created by @Ad5001 and updated by @LeoBdt
; Updated time : 2/17/2019

; Popup lors d'une entrée dans le plot
popup=Vous êtes sur le plot {%0}
popup.owner=Créé par {%0}
popup.available=Ce plot est disponible! Fait /p claim pour te l'approprier
popup.denied=Tu as refusé ce plot.

; /p info
command.name=plot
command.alias=p
command.desc=Donne des informations à propos du plot où vous êtes actuellement
command.usage=/p [help]
command.unknown=Commande inconnue, fait /p help

subcommand.usage=Usage: {%0}

; Les erreurs affichées lorsque le plugin bugue.
error=oops ! quelque chose ne va pas.
notinplot="Vous n'êtes pas sur un plot"
notowner=Ce plot ne vous appartient pas
plugin.disabled=Ce plugin est désactivé

confirm=confirm

; La commande /p help
help.name=help
help.desc=Affiche la liste des commandes relatives à MyPlot
help.usage=/p help [page: int]
help.header=--- Pages d'aide de MyPlot {%0} sur {%1} ---

; La commande /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Ajouter un joueur à votre plot (ce joueur sera en mesures de casser ou poser des blocs.)
addhelper.usage=/p addhelper <player: string>
addhelper.alreadyone={%0} est déjà avec vous sur ce plot.
addhelper.success={%0} est désormais admis sur votre plot.

; La commande /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Supprimer un joueur de votre plot
removehelper.usage=/p removehelper <player: string>
removehelper.notone="{%0} n'est pas admis sur votre plot."
removehelper.success="{%0} n'est désormais plus admis sur votre plot et il ne pourra plus poser n'y casser de blocs."

; La commande /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Banni un joueur de votre plot
denyplayer.usage=/p deny <player: string>
denyplayer.helper={%0} fait partie de votre plot, merci de retirer son rang de helper.
denyplayer.alreadyone={%0} est déjà banni de votre plot
denyplayer.notaplayer=Ce joueur est hors-ligne.
denyplayer.cannotdeny={%0} ne peut être banni de votre plot
denyplayer.attempteddeny={0} a essayé de vous bannir de son plot.
denyplayer.success1={%0} est désormais banni de votre plot.
denyplayer.success2=Vous avez été banni du plot {%0};{%1} de {%2}

; La commande /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Retire le bannissement d'un joueur sur votre plot
undenyplayer.usage=/p undeny <player: string>
undenyplayer.notone="{%0} n'est pas banni."
undenyplayer.success1="{%0} n'est plus banni"
undenyplayer.success2="Vous n'êtes plus banni du plot {%0};{%1} de {%2}"
undenyplayer.failure=Impossible de retirer le ban de {%0}

; La commande /p claim Subcommand
claim.name=claim
claim.desc=Prendre/acheter le plot sur lequel vous êtes
claim.usage=/p claim [nom du plot]
claim.yourplot=Vous possédez déjà ce plot
claim.alreadyclaimed=Ce plot appartient déjà à {%0}
claim.maxplots=Vous avez atteint la limite de plot autorisés {%0}
claim.nomoney="Vous n'avez pas assez d'argent pour acheter ce plot"
claim.success=Félicitations, ce plot vous appartient désormais.

; La commande /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Téléporte au plot libre le plus proche
auto.usage=/p auto [claim: bool] [name: string]
auto.notplotworld="Vous n'êtes pas sur un monde avec des plot"
auto.success="Téléportation au plot ({%0};{%1})"
auto.noplots="Il n'y a plus de plots disponibles."

; La commande /p dispose Subcommand
dispose.name=dispose
dispose.desc="Mettre à disposition votre plot, ce qui le rend disponible à l'achat"
dispose.usage=/p dispose
dispose.confirm=Êtes vous sûr de vouloir mettre à disposition votre plot? Si oui, merci de faire /p dispose confirm
dispose.nomoney="Vous n'avez pas assez d'argent pour mettre à disposition ce plot"
dispose.success=Votre plot a bien été mit à disposition

; La commande /p reset Subcommand
reset.name=reset
reset.desc=Réinitialiser votre plot (le mettre à disposition et le remettre à 0)
reset.usage=/p reset
reset.confirm=Êtes vous sûr de vouloir remettre à zéro votre plot? Si oui, merci de faire /p reset confirm
reset.nomoney="Vous n'avez pas assez d'argent pour réinitialiser ce plot"
reset.success=Votre plot a bien été réinitialiser, merci de patienter...

; La commande /p clear Subcommand
clear.name=clear
clear.desc=Remettre à 0 votre plot
clear.usage=/p clear
clear.confirm="Êtes-vous sûr de vouloir remettre à zéro votre plot? Si oui, merci de faire /p plot confirm"
clear.nomoney="Vous n'avez pas assez d'argent pour remettre à 0 ce plot"
clear.success=Votre plot a bien été remis à zéro.

; La commande /p biome Subcommand
biome.name=biome
biome.desc=Changer le biome de votre plot
biome.usage=/p biome [biome: string]
biome.success=Votre plot a bien changer de biome
biome.invalid="Ce biome n'existe pas"
biome.possible=Les biomes disponibles sont: {%0}

; La commande /p biomes Subcommand
biomes.name=biomes
biomes.desc=Affiche la liste des biomes
biomes.usage=/p biomes
biomes.possible=Les biomes disponibles sont: {%0}

; La commande /p name Subcommand
name.name=name
name.desc=Donner un nom à votre plot
name.usage=/p name <name: string>
name.success=Le nom de votre plot est désormais

; La commande /p home Subcommand
home.name=home
home.alias=h
home.desc=Se téléporter à votre plot.
home.usage=/p home [nombre: int] [monde: string]
home.noplots="Vous n'avez aucun plot"
home.notexist="Vous n'avez pas de plot avec le numéro"
home.success=Télportation au plot {%0}
home.error=Impossible de se télépoter à ce plot

; La commande /p homes Subcommand
homes.name=homes
homes.desc=Affiche vos plots
homes.usage=/p homes [monde: string]
homes.noplots=Vous n'avez pas de plot(s).
homes.header=Vos plot(s):

; La commande /p info Subcommand
info.name=info
info.alias=i
info.desc=Voir les informations du plot sur lequel vous êtes
info.usage=/p info [joueur] [plot]
info.about=Informations du plot
info.plotname=Nom: {%0}
info.owner=Propriétaire: {%0}
info.helpers=Autres joueurs sur le plot: {%0}
info.denied=Joueurs bannis:
info.biome=Biome: {%0}
info.notfound=Ce plot n'est pas trouvé

; La commande /p generate Subcommand - OP ou perm myplot.command.generatepermission
generate.name=generate
generate.alias=gen
generate.desc=
generate.usage=/p generate <name: string> [generator name: string]
generate.exists=Ce monde existe déjà
generate.gexists="Ce générateur n'éxiste pas"
generate.success=Monde généré!
generate.error=le monde ne peut être générer

; La commande /p give Subcommand
give.name=give
give.desc=Donne votre plot au joueur souhaité.
give.usage=/p give [joueur: string]
give.notonline=Ce joueur est hors-ligne.
give.maxedout=Ce joueur possède trop de plots
give.toself=Vous ne pouvez pas donner votre plot à vous même
give.confirm=Êtes-vous sûr de vouloir donner le plot {%0} à {%1}? Si oui, merci de faire /p give {%1} confirm
give.success=Vous avez donné votre plot à {%0}
give.received={%0} vous a donné le plot {%1}

; La commande /p warp Subcommand
warp.name=warp
warp.desc=Téléporte a un warp
warp.usage=/p warp <monde: int> [world: string]
warp.wrongid=Mauvais id ( doit être X;Z )
warp.notinplotworld="Vous n'êtes pas dans un monde avec des plots"
warp.unclaimed=Vous ne pouvez vous téléporter dans un plot unclaum
warp.success=Téléporté à {%0}

; La commande /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Téléporte au milieu du plot sur lequel vous êtes
middle.usage=/p mid
middle.success=Téléporté au milieu du plot

; La commande /p setowner Subcommand
setowner.name=setowner
setowner.desc=Définit le nouveau propriétaire du plot
setowner.usage=/p setowner <player: string>
setowner.maxplots=Ce joueur a déjà un maximum de plots
setowner.success={%0} est désormais le propriétaire du plot

; La commande /p list Subcommand
list.name=list
list.alias=l
list.desc=Voir la liste de vos plots
list.usage=/p list [joueur: string]
list.found="Plot {%0} à ({%1};{%2}),"

; La commande /p pvp Subcomand
pvp.name=pvp
pvp.desc=Active ou désactive le pvp dans votre plot
pvp.usage=/p pvp
pvp.world="Le pvp n'est pas activé dans ce monde"
pvp.plot=Le pvp est désactivé dans ce plot
pvp.success=Le pvp est désormais {%0} pour ce plot
; Korean language pack for MyPlot
; Created by Johnmacrocraft
; Updated time : 2/17/2019

; Popup when entering a plot
popup={%0} 땅에 들어갔습니다
popup.owner={%0}이(가) 소유함
popup.available=이 땅은 개방되어 있습니다. /p claim를 사용해 땅을 차지할 수 있습니다.
popup.denied=이 땅에 대한 접근이 금지되었습니다

; /p info
command.name=plot
command.alias=p
command.desc=땅을 차지하고 관리합니다
command.usage=/p [help]
command.unknown=알 수 없는 명령입니다. /p help에서 명령어 목록을 참조하세요

subcommand.usage=사용법: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=앗! 문제가 발생했습니다
notinplot=땅 안에 서 있지 않습니다
notowner=이 땅을 소유하고 있지 않습니다
plugin.disabled=이 플러그인은 비활성화되어 있습니다

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=도움말 메뉴를 보여줍니다
help.usage=/p help [쪽 번호: int]
help.header=--- MyPlot 도움말 {%1}쪽 중 {%0}쪽 ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=땅에 도우미를 추가합니다
addhelper.usage=/p addhelper <플레이어: string>
addhelper.alreadyone={%0}은(는) 이미 이 땅의 도우미입니다
addhelper.success={%0}이(가) 이제 이 땅의 도우미입니다

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=땅에서 도우미를 제거합니다
removehelper.usage=/p removehelper <플레이어: string>
removehelper.notone={%0}은(는) 도우미가 아닙니다
removehelper.success={%0}을(를) 땅 도우미에서 제거했습니다

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=플레이어의 땅 접근을 금지합니다
denyplayer.usage=/p deny <플레이어: string>
denyplayer.helper={%0}은(는) 도우미입니다
denyplayer.alreadyone={%0}은(는) 이미 이 땅에서 금지되었습니다
denyplayer.notaplayer=해당 플레이어는 지금 온라인 상태가 아닙니다
denyplayer.cannotdeny={%0}은(는) 금지할 수 없습니다
denyplayer.attempteddeny={%0}이(가) 땅에서 당신을 금지하려고 시도했습니다
denyplayer.success1={%0}이(가) 이제 땅에 대한 접근이 금지되었습니다
denyplayer.success2="{%0};{%1} 땅에 대해 {%2}에게 접근을 금지당했습니다"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=플레이어의 땅 접근 금지를 해제합니다
undenyplayer.usage=/p undeny <플레이어: string>
undenyplayer.notone={%0}은(는) 이미 허용되어 있습니다
undenyplayer.success1={%0}이(가) 땅에서 허용되었습니다
undenyplayer.success2="{%0};{%1}에 대해 {%2}에게 접근이 허용되었습니다"
undenyplayer.failure={%0}은(는) 아직 금지되어 있습니다

; The /p claim Subcommand
claim.name=claim
claim.desc=서 있는 현재 땅을 차지합니다
claim.usage=/p claim [이름: string]
claim.yourplot=이미 이 땅을 차지했습니다
claim.alreadyclaimed=이 땅은 이미 {%0}이(가) 차지하고 있습니다
claim.maxplots=플레이어당 땅 {%0}개 한계에 도달했습니다
claim.nomoney=이 땅을 차지하기에 충분한 금액이 없습니다
claim.success=땅을 성공적으로 차지했습니다

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=다음 빈 땅으로 순간이동합니다
auto.usage=/p auto [차지 여부: bool] [이름: string]
auto.notplotworld=땅 세계에 있지 않습니다
auto.success="빈 ({%0};{%1}) 땅으로 순간이동했습니다"
auto.noplots=사용 가능한 땅을 찾을 수 없습니다

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=땅을 매각합니다
dispose.usage=/p dispose
dispose.confirm={%0} 땅을 매각하시겠습니까? 매각하려면 /p dispose confirm을 사용하세요
dispose.nomoney=이 땅을 매각하기에 충분한 금액이 없습니다
dispose.success=땅을 매각했습니다

; The /p reset Subcommand
reset.name=reset
reset.desc=땅을 매각하고 비웁니다
reset.usage=/p reset
reset.confirm={%0} 땅을 초기화하시겠습니까? 초기화하려면 /p reset confirm을 사용하세요
reset.nomoney=이 땅을 초기화하기에 충분한 금액이 없습니다
reset.success=땅을 초기화했습니다

; The /p clear Subcommand
clear.name=clear
clear.desc=땅을 비웁니다
clear.usage=/p clear
clear.confirm={%0} 땅을 비우시겠습니까? 비우려면 /p clear confirm을 사용하세요
clear.nomoney=이 땅을 비우기에 충분한 금액이 없습니다
clear.success=땅을 비웠습니다

; The /p biome Subcommand
biome.name=biome
biome.desc=땅 생물 군계를 변경합니다
biome.usage=/p biome [생물 군계: string]
biome.success=땅 생물 군계를 {%0}(으)로 변경했습니다
biome.invalid=해당 생물 군계는 존재하지 않습니다
biome.possible=가능한 생물 군계는 다음과 같습니다: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=사용 가능한 생물 군계 목록을 보여줍니다
biomes.usage=/p biomes
biomes.possible=가능한 생물 군계는 다음과 같습니다: {%0}

; The /p name Subcommand
name.name=name
name.desc=땅 이름을 설정하거나 변경합니다
name.usage=/p name <이름: string>
name.success=땅 이름을 {%0}(으)로 설정했습니다

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=땅으로 이동합니다
home.usage=/p home [번호: int] [세계: string]
home.noplots=이 세계에서 땅을 소유하고 있지 않습니다
home.notexist=이 세계에서 id {%0}(으)로 땅을 소유하고 있지 않습니다
home.success={%1} 세계 안의 {%0}(으)로 순간이동했습니다
home.error=땅으로 이동할 수 없습니다

; The /p homes Subcommand
homes.name=homes
homes.desc=차지한 땅을 보여줍니다
homes.usage=/p homes [세계: string]
homes.noplots=땅을 소유하고 있지 않습니다
homes.header=소유하는 땅:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=땅에 대한 정보를 보여줍니다
info.usage=/p info [플레이어] [땅 번호]
info.about={%0} 땅에 대한 정보
info.plotname=이름: {%0}
info.owner=소유자: {%0}
info.helpers=도우미: {%0}
info.denied=금지된 플레이어: {%0}
info.biome=생물 군계: {%0}
info.notfound=해당 땅을 찾을 수 없습니다

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=새로운 땅 세계를 생성합니다
generate.usage=/p generate <이름: string> [생성기 이름: string]
generate.exists={%0}(이)란 이름의 세계가 이미 존재합니다
generate.gexists=생성기 {%0}이(가) 존재하지 않습니다
generate.success={%0} 땅 세계를 성공적으로 생성했습니다
generate.error=땅을 생성할 수 없습니다

; The /p give Subcommand
give.name=give
give.desc=땅을 다른 누군가에게 줍니다
give.usage=/p give [플레이어: string]
give.notonline=해당 플레이어는 온라인 상태가 아닙니다
give.maxedout=해당 플레이어는 최대 땅 수에 도달했습니다
give.toself=자기 자신에게는 땅을 줄 수 없습니다
give.confirm=플레이어 {%1}에게 {%0} 땅을 주시겠습니까? 주려면 /p give {%1} confirm을 사용하세요
give.success={%0}에게 땅을 주었습니다
give.received={%0}이(가) {%1} 땅을 주었습니다

; The /p warp Subcommand
warp.name=warp
warp.desc=땅으로 순간이동합니다
warp.usage=/p warp <id: int> [세계: string]
warp.wrongid="땅 id는 X;Z 형식이어야 합니다"
warp.notinplotworld=땅 세계에 있지 않습니다
warp.unclaimed=차지하지 않은 땅으로는 순간이동할 수 없습니다
warp.success={%0} 땅으로 순간이동했습니다

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=지면에서 땅의 정가운데로 플레이어를 순간이동시킵니다
middle.usage=/p mid
middle.success=순간이동을 완료했습니다

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=아무것도 청구하지 않고 땅의 새로운 소유자를 설정합니다
setowner.usage=/p setowner <플레이어: string>
setowner.maxplots=해당 플레이어는 {%0}의 땅 제한에 도달했습니다
setowner.success={%0}이(가) 이제 이 땅의 소유자입니다

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=플레이어에게 있는 모든 땅을 보여줍니다
list.usage=/p list [플레이어: string]
list.found="({%1};{%2})에 {%0} 땅,"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=땅의 pvp 모드를 전환합니다
pvp.usage=/p pvp
pvp.world=Pvp는 이 땅 세계에서 구성으로 비활성화되어 있습니다
pvp.plot=Pvp는 이 땅에서 비활성화되어 있습니다
pvp.success=Pvp가 땅에서 이제 {%0} 상태가 되었습니다; lang language pack for MyPlot
; Created by username
; Updated time : 00/00/0000

; Popup when entering a plot
popup=
popup.owner=
popup.available=
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=
command.usage=/p [help]
command.unknown=

subcommand.usage=

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=
notinplot=
notowner=
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=
help.usage=/p help []
help.header=

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=
addhelper.usage=/p addhelper <>
addhelper.alreadyone=
addhelper.success=

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=
removehelper.usage=/p removehelper <>
removehelper.notone=
removehelper.success=

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper=
denyplayer.alreadyone=
denyplayer.notaplayer=
denyplayer.cannotdeny=
denyplayer.attempteddeny=
denyplayer.success1=
denyplayer.success2=

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone=
undenyplayer.success1=
undenyplayer.success2=
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=
claim.usage=/p claim []
claim.yourplot=
claim.alreadyclaimed=
claim.maxplots=
claim.nomoney=
claim.success=

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=
auto.usage=/p auto [] []
auto.notplotworld=
auto.success=
auto.noplots=

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=
dispose.usage=/p dispose
dispose.confirm=
dispose.nomoney=
dispose.success=

; The /p reset Subcommand
reset.name=reset
reset.desc=
reset.usage=/p reset
reset.confirm=
reset.nomoney=
reset.success=

; The /p clear Subcommand
clear.name=clear
clear.desc=
clear.usage=/p clear
clear.confirm=
clear.nomoney=
clear.success=

; The /p biome Subcommand
biome.name=biome
biome.desc=
biome.usage=/p biome []
biome.success=
biome.invalid=
biome.possible=

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=
biomes.usage=/p biomes
biomes.possible=

; The /p name Subcommand
name.name=name
name.desc=
name.usage=/p name <>
name.success=

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=
home.usage=/p home [] []
home.noplots=
home.notexist=
home.success=
home.error=

; The /p homes Subcommand
homes.name=homes
homes.desc=
homes.usage=/p homes []
homes.noplots=
homes.header=

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=
info.usage=/p info [] []
info.about=
info.plotname=
info.owner=
info.helpers=
info.denied=
info.biome=
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=
generate.usage=/p generate <> []
generate.exists=
generate.gexists=
generate.success=
generate.error=

; The /p give Subcommand
give.name=give
give.desc=
give.usage=/p give []
give.notonline=
give.maxedout=
give.toself=
give.confirm=
give.success=
give.received=

; The /p warp Subcommand
warp.name=warp
warp.desc=
warp.usage=/p warp <> []
warp.wrongid=
warp.notinplotworld=
warp.unclaimed=
warp.success=

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=
middle.usage=/p mid
middle.success=

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=
setowner.usage=/p setowner <>
setowner.maxplots=
setowner.success=

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=
list.usage=/p list []
list.found=

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=/p pvp
pvp.world=
pvp.plot=
pvp.success=; Dutch language pack for MyPlot
; Created by Wiez
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Dit is plot {%0}
popup.owner=Van {%0}
popup.available=
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=Beheer uw plots
command.usage=/plot <help|sub-cmd> [opties]
command.unknown=Onbekend commando. Gebruik /p help voor een lijst van alle commandos

subcommand.usage=Gebruik: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Oeps! Er is iets verkeerd gelopen
notinplot=Je staat niet in een plot
notowner=Dit is niet jouw plot
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Toont het help menu
help.usage=/p help [pagina]
help.header=--- MyPlot help pagina {%0} van de {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Voeg een helper toe aan jouw plot
addhelper.usage=/p addhelper <speler>
addhelper.alreadyone={%0} is al een helper van jouw plot
addhelper.success={%0} is nu een helper van jouw plot

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Verwijder een helper van jouw plot
removehelper.usage=/p removehelper <player>
removehelper.notone={%0} is geen helper
removehelper.success={%0} is verwijderd als helper

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper=
denyplayer.alreadyone=
denyplayer.cannotdeny=
denyplayer.attempteddeny=
denyplayer.success1=
denyplayer.success2=

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone=
undenyplayer.notaplayer=
undenyplayer.success1=
undenyplayer.success2=
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=Bemachtig het stukje land waar je op staat
claim.usage=/p claim [naam]
claim.yourplot=Dit is jouw plot al
claim.alreadyclaimed=Dit plot is al van {%0}
claim.maxplots=Je hebt de limiet bereikt van {%0} plots per speler
claim.nomoney=Je hebt niet genoeg geld om deze plot te bemachtigen
claim.success=Dit is nu jouw stukje land

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Teleporteer naar de volgende vrije plot
auto.usage=/p auto
auto.notplotworld=Je bent niet in een plot wereld
auto.success=Je bent geteleporteerd naar plot ({%0}, {%1})
auto.noplots=Er zijn geen vrije plots gevonden

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Doe afstand van deze plot
dispose.usage=/p dispose
dispose.confirm=Ben je zeker dat je niet meer de eigenaar wil zijn van plot {%0} ? Doe dan /p dispose confirm
dispose.nomoney=Je hebt hiervoor niet genoeg geld
dispose.success=Je bent niet meer de eigenaar van deze plot

; The /p reset Subcommand
reset.name=reset
reset.desc=Herstel een plot naar zijn begin toestand en doe er afstand van
reset.usage=/p reset
reset.confirm=Ben je zeker dat je plot {%0} wil resetten? Doe dan /p reset confirm
reset.nomoney=Je hebt niet genoeg geld om deze plot te resetten
reset.success=De plot is gereset

; The /p clear Subcommand
clear.name=clear
clear.desc=Herstelt deze plot naar zijn begin toestand
clear.usage=/p clear
clear.confirm=Ben je zeker dat je plot {%0} wil herstellen? Doe dan /p clear confirm
clear.nomoney=Je hebt niet genoeg geld om deze plot te herstellen
clear.success=De plot is hersteld

; The /p biome Subcommand
biome.name=biome
biome.desc=Verandert de biome in een ander type
biome.usage=/p biome [type]
biome.success=De biome van deze plot is veranderd naar {%0}
biome.invalid=Dat type bestaat niet
biome.possible=De mogelijke biome types zijn: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; The /p name Subcommand
name.name=name
name.desc=Verandert de naam van deze plot
name.usage=/p name <naam>
name.success=Deze plot noemt nu {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Ga naar een van je plots
home.usage=/p home [nummer]
home.noplots=Je hebt geen plots
home.notexist=Je hebt geen plot met nummer {%0}. Gebruik /p homes om al je plots te bekijken
home.success=Je bent geteleporteerd naar plot {%0}
home.error=Er is iets mis gegaan bij het teleporteren

; The /p homes Subcommand
homes.name=homes
homes.desc=Geeft een lijst van al jouw plots
homes.usage=/p homes
homes.noplots=Je hebt geen plots
homes.header=Jouw plots:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Toont informatie over een plot
info.usage=/p info
info.about=Info van plot {%0}
info.plotname=Naam: {%0}
info.owner=Eigenaar: {%0}
info.helpers=Helpers: {%0}
info.denied=
info.biome=Biome: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Genereert een nieuwe plot wereld
generate.usage=/p generate <naam>
generate.exists=Er bestaat al een wereld met naam {%0}
generate.gexists=
generate.success=De nieuwe plot wereld {%0} is gegenereerd
generate.error=De wereld kon niet gegenereerd worden

; The /p give Subcommand
give.name=give
give.desc=Geef je plot aan iemand anders
give.usage=/p give [speler]
give.notonline=Die speler is niet online
give.maxedout=Die speler heeft de maximale plot limiet bereikt
give.toself=Je kan de plot niet aan jezelf geven
give.confirm=Ben je zeker dat je plot {%0} wil geven aan {%1}? Doe dan /p give {%1} confirm
give.success=Je hebt jouw plot gegeven aan {%0}
give.received={%0} heeft plot {%1} aan jouw gegeven

; The /p warp Subcommand
warp.name=warp
warp.desc=Teleporteer naar een plot
warp.usage=/p warp <x;z>
warp.wrongid=De plot nummer moet in het formaat X;Z zijn
warp.notinplotworld=Je bent niet in een plot wereld
warp.unclaimed=Je kan niet naar een leeg plot teleporteren
warp.success=Je bent geteleporteerd naar {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleports the player to exact center of plot at ground level
middle.usage=/p mid
middle.success=Teleporting complete

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Sets the new owner of the plot without charging anything
setowner.usage=/p setowner <player: string>
setowner.maxplots=That player reached their plots limit of {%0}
setowner.success={%0} is now the owner of this plot

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Shows all plots a player has
list.usage=/p list [player: string]
list.found="Plot {%0} at ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.success=Pvp is now {%0} for the plot; Spanish language pack for MyPlot
; Created by kenygamer
; Updated time: 2/17/2019

; Popup al entrar en un terreno
popup=Has ingresado al terreno {%0}
popup.owner=Propiedad de {%0}
popup.available=Este terreno está abierto. Usa /p claim para reclamar.
popup.denied=

; Main Command (/plot)
command.name=plot 
command.alias=p 
command.desc=Reclamar y gestionar sus parcelas.
command.usage=/p [help]
command.unknown=Comando desconocido. Utiliza /p help para la lista de comandos

subcommand.usage=Uso: {%0}

; Errores que aparecen cuando el jugador hace algo mal, o el plugin se averia
error=Oops! Ocurrió un error
notinplot=No estás dentro de una parcela
notowner=No eres el dueño de esta parcela
plugin.disabled=

confirm=confirmar

; El subcomando /p help
help.name=help 
help.desc=Help menú 
help.usage=/p help [pagina] 
help.header=---MyPlot Mostrando ayuda {%0} de {%1}---

; El subcomando /p addhelper
addhelper.name=addhelper 
addhelper.alias=addh 
addhelper.desc=Add un ayudante a su parcela 
addhelper.usage=/p addhelper
addhelper.alreadyone={%0} es un ayudante de esta parcela
addhelper.success={%0} es ahora un ayudante de esta parcela

;El subcomando /p removehelper
removehelper.name=removehelper 
removehelper.alias=delh 
removehelper.desc=Añadir un ayudante a su terreno
removehelper.usage=/p removehelper
removehelper.notone={%0} no es un ayudante
removehelper.success={%0} se ha quitado de los ayudantes de su parcela

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=
denyplayer.usage=/p deny <>
denyplayer.helper=
denyplayer.alreadyone=
denyplayer.notaplayer=
denyplayer.cannotdeny=
denyplayer.attempteddeny=
denyplayer.success1=
denyplayer.success2=

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=
undenyplayer.usage=/p undeny <>
undenyplayer.notone=
undenyplayer.success1=
undenyplayer.success2=
undenyplayer.failure=

; El subcomando /p claim
claim.name=claim 
claim.desc=Reclame la parcela en la que estás
claim.usage=/p claim [nombre: cadena]
claim.yourplot=Esta ya es su parcela
claim.alreadyclaimed=Esta parcela ya fue reclamada por {0%}
claim.maxplots=Ha alcanzado el límite de parcelas por jugador {%0}
claim.nomoney=No tiene suficiente dinero para reclamar este terreno
claim.success=Ha reclamado con éxito esta parcela

; El subcomando /p auto
auto.name=auto 
auto.alias=a 
auto.desc=Teletransporta a la parcela libre más cercana
auto.usage=/p auto
auto.notplotworld=No está en un mundo de parcelas
auto.success=Teletransportado a parcela libre ({%0}, {1%}) 
auto.noplots=No hay parcelas disponibles aquí

; El subcomnado /p dispose
dispose.name=dispose
dispose.desc=Deshacerse de su parcela
dispose.usage=Está seguro de deshacerse de su parcela {%0}? Si es así, use /p dispose confirm
dispose.confirm=
dispose.nomoney=No tiene suficiente dinero para deshacerse de esta parcela
dispose.success=Terreno eliminado

; El subcomando /p reset
reset.name=reset 
reset.desc=Se deshace de su terreno como también lo borra
reset.usage=Está seguro de deshacer su terreno y borrarlo {%0}? Si es así, use /p reset confirm
reset.confirm=
reset.nomoney=No tiene suficiente dinero para borarr este terreno
reset.success=Plot reset

; El subcomando /p clear
clear.name=clear 
clear.desc=Limpiar su terreno 
clear.usage=Está seguro de limpiar su terreno {%0}? Si es así, use /p clear confirm
clear.confirm=
clear.nomoney=No tiene suficiente dinero para limpiar este terreno
clear.success=Plot despejado

; El subcomando /p biome
biome.name=biome 
biome.desc=Cambia el bioma de su parcela 
biome.usage=/p biome [bioma] 
biome.success=Bioma de su terreno cambiado a {%0}
biome.invalid=Ese bioma no existe 
biome.possible=Los biomas posibles son: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; El subcomando /p name
name.name=name 
name.desc=Establece o cambia el nombre de su parcela 
name.usage=/p name 
name.success=Nombre del terreno cambiado a {%0}

; El subcomando /p home
home.name=home 
home.alias=h 
home.desc=Regresar a su parcela 
home.usage=/p home [número] 
home.noplots=No posees ninguna parcela
home.notexist=No posees ninguna parcela con el identificador {%0} 
home.success=Teletransportado a la parcela {%0} 
home.error=No se pudo regresar a su parcela

; El subcomando /p homes
homes.name=homes 
homes.desc=Muestra sus parcelas reclamadas 
homes.usage=/p homes 
homes.noplots=No posees ninguna parcela reclamada 
homes.header=Tus parcelas:

; El subcomando /p info
info.name=info 
info.alias=i 
info.desc=Muestra información sobre una parcela
info.usage=/p info 
info.about=Información sobre la parcela {%0} 
info.plotname= Nombre: {%0} 
info.owner=Dueño: {%0} 
info.helpers=Ayudantes: {%0}
info.denied=
info.biome=Bioma: {%0}
info.notfound=

; El subcomando /p generate - sólo puede ser utilizado por OPs o los jugadores con el permiso de myplot.command.generate
generate.name=generate
generate.alias=gen 
generate.desc=Genera un nuevo mundo de parcelas
generate.usage=/p generate 
generate.exists=Un mundo con nombre {%0} ya existe
generate.gexists=
generate.success=Se ha generado con éxito el mundo de parcelas {%0}
generate.error=El mundo no se pudo generar

; El subcomando /p give
give.name=give 
give.desc=Darle su parcela a alguien 
give.usage=/p give [nombre]
give.notonline=El jugador no está en línea 
give.maxedout=El jugador ha alcanzado el número máximo de parcelas
give.toself=No te puedes dar una parcela a ti mismo
give.confirm=Está seguro de que desea darle su parcela {%0} al jugador {%1}? Si es así, use /p {%1} confirm
give.success=Ha dado su parcela {0%} 
give.received={%0} te dio su parcela, {%1}

; El subcomando /p warp
warp.name=warp 
warp.desc=Teletransportarse a un terreno
warp.usage=/p warp [x;z]
warp.wrongid=
warp.notinplotworld=No estás en un mundo de terrenos
warp.unclaimed=No puedes teletransportarte a un terreno no reclamado
warp.success=Has sido teletransportado a la parcela {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Teleports the player to exact center of plot at ground level
middle.usage=/p mid
middle.success=Teleporting complete

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Sets the new owner of the plot without charging anything
setowner.usage=/p setowner <player: string>
setowner.maxplots=That player reached their plots limit of {%0}
setowner.success={%0} is now the owner of this plot

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Shows all plots a player has
list.usage=/p list [player: string]
list.found="Plot {%0} at ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Toggles the pvp mode for the plot
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp is disabled in this plot
pvp.success=Pvp is now {%0} for the plot; Turkish language pack for MyPlot
; Created by Eren5960
; Updated time : 2/17/2019

; Popup when entering a plot
popup={%0} arsasına giriş yaptın
popup.owner=Sahibi: {%0}
popup.available=Bu arsa sahipsiz. /p al komutu ile sahip olabilirsin.
popup.denied=Bu arsaya girişimin engellenmiş.

; /p info
command.name=plot
command.alias=p
command.desc=Arsa alma ve yönetme komutları.
command.usage=/p [help]
command.unknown=Bilinmeyen komut. /p yardim yazarak komutları öğrenebilirsin.

subcommand.usage=Kullanım: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Tüh! Bir şeyler yanlış gitti
notinplot=Bir arsa içerisinde durmuyorsun
notowner=Bu arsaya sahip değilsin
plugin.disabled=Bu eklenti aktif değil

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Yardım sayfasını görüntüler
help.usage=/p help [sayfa: sayı]
help.header=--- MyPlot Yardım Sayfası {%0}/{%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Arsana ortak ekler
addhelper.usage=/p addhelper <oyuncu: dizi>
addhelper.alreadyone={%0} zaten arsanda ortak
addhelper.success={%0} başarıyla arsanda ortak oldu

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Arsandan ortak kaldır
removehelper.usage=/p removehelper <oyuncu: dizi>
removehelper.notone={%0} arsanda ortak değil
removehelper.success={%0} ortaklar arasından kaldırıldı

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Oyuncunun arsana erişimini engeller
denyplayer.usage=/p deny <oyuncu: dizi>
denyplayer.helper={%0} oyuncusu bir ortak
denyplayer.alreadyone={%0} zaten bu arsadan engellendi
denyplayer.notaplayer=Oyuncu şuan da aktif değil
denyplayer.cannotdeny={%0} oyuncusunun erişimi engellenemez
denyplayer.attempteddeny={%0} arsasına erişimini engellemeye çalıştı
denyplayer.success1={%0} oyuncusunun arsana erişimi engellendi
denyplayer.success2="{%0};{%1} arsasına erişimin {%2} tarafından engellendi"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Oyuncunun arsana erişim engelini kaldırır
undenyplayer.usage=/p undenyplayer <oyuncu: dizi>
undenyplayer.notone={%0} oyuncusunun erişim engeli zaten yok
undenyplayer.success1={%0} oyuncusunun erişim engeli kaldırıldı
undenyplayer.success2="{%0};{%1} arsasına erişim engelin {%2} tarafından kaldırıldı"
undenyplayer.failure={%0} hâlâ reddedildi

; The /p claim Subcommand
claim.name=claim
claim.desc=Arsaya sahip olursun
claim.usage=/p claim [isim: dizi]
claim.yourplot=Bu arsaya zaten sahipsin
claim.alreadyclaimed=Bu arsa zaten {%0} tarafından alınmış
claim.maxplots=Oyuncu başına {%0} arsa sınırına ulaştın
claim.nomoney=Bu arsayı alabilmek için yeterli paraya sahip değilsin
claim.success=Arsayı başarıyla aldın

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Rastgele bir arsaya ışınlar
auto.usage=/p auto [sahipsiz: mantıksal] [isim: dizi]
auto.notplotworld=Arsa dünyasında değilsin
auto.success="({%0};{%1}) arsası bulundu"
auto.noplots=Sahipsiz arsa bulunamadı

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Arsanı siler
dispose.usage=/p dispose
dispose.confirm={%0} arsasını silmek istediğine emin misin? Eğer onaylıyorsan /p sil onay komutunu kullan
dispose.nomoney=Arsayı silmek için yeterli paraya sahip değilsin
dispose.success=Arsa silindi

; The /p reset Subcommand
reset.name=reset
reset.desc=Arsanı siler ve temizler
reset.usage=/p reset
reset.confirm={%0} arsasını silmek istediğine emin misin? Eğer onaylıyorsan /p sifirla onay komutunu kullan
reset.nomoney=Arsayı sıfırlamak için yeterli paraya sahip değilsin
reset.success=Arsa sıfırlandı

; The /p clear Subcommand
clear.name=clear
clear.desc=Arsanı temizler
clear.usage=/p clear
clear.confirm={%0} arsasını silmek istediğine emin misin? Eğer onaylıyorsan /p temizle onay komutunu kullan
clear.nomoney=Arsayı temizlemek için yeterli paraya sahip değilsin
clear.success=Arsa temizlendi

; The /p biome Subcommand
biome.name=biome
biome.desc=Arsanın biomunu değiştir
biome.usage=/p biome [biom: dizi]
biome.success=Arsa biomu {%0} olarak ayarlandı
biome.invalid=Seçtiğiniz biom bulunamadı
biome.possible=Olası biyomlar: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=Biom listesini görüntüler
biomes.usage=/p biomes
biomes.possible=Olası biomlar: {%0}

; The /p name Subcommand
name.name=name
name.desc=Arsanın ismini ayarlar
name.usage=/p name <isim: dizi>
name.success=Arsa ismi {%0} olarak ayarlandı

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Arsa evini ziyaret eder
home.usage=/p home [id: sayı] [dünya: dizi]
home.noplots=Arsa dünyasında değilsin
home.notexist="Bu dünyada {%0} ID'li bir ev noktası bulunamadı"
home.success="{%1} dünyasındaki {%0} ID'li ev noktasına ışınlandın"
home.error=Ev noktası bulunamadı

; The /p homes Subcommand
homes.name=homes
homes.desc=Sahip olduğun evleri gösterir
homes.usage=/p homes [dünya: dizi]
homes.noplots=Hiçbir eve sahip değilsin
homes.header=Evler:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Arsa hakkında bilgileri görüntüler
info.usage=/p info [oyuncu: dizi] [plot sayısı: sayı]
info.about={%0} arsası hakkında bilgiler
info.plotname=İsim: {%0}
info.owner=Sahip: {%0}
info.helpers=Ortaklar: {%0}
info.denied=Yasaklılar: {%0}
info.biome=Biom: {%0}
info.notfound=Arsa hakkında bilgi bulunamadı

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Bir arsa dünyası oluştur
generate.usage=/p generate <isim: dizi> [oluşturucu ismi: dizi]
generate.exists={%0} isimli dünya zaten var
generate.gexists={%0} isimli oluşturucu bulunamadı
generate.success=Başarıyla {%0} isimli arsa dünyası oluşturuldu
generate.error=Dünya oluşturulamadı

; The /p give Subcommand
give.name=give
give.desc=Arsayı başka bir oyuncuya devreder
give.usage=/p give [oyuncu: dizi]
give.notonline=Oyuncu şuan da aktif değil
give.maxedout=Bu oyuncu azami {%0} sayısına ulaştı
give.toself=Kendi arsanı kendine aktaramazsın
give.confirm={%1} oyuncusuna {%0} arsanı devretmek istediğine emin misin? Eğer onaylıyorsan /p devret {%1} onay komutunu kullan
give.success=Arsanı {%0} oyuncusuna devrettin
give.received={%0} oyuncusu arsasını sana devretti, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Bir plota ışınlar
warp.usage=/p warp <id: sayı> [dünya: dizi]
warp.wrongid="ID formatı X;Z şeklinde olmalıdır"
warp.notinplotworld=Arsa dünyasında değilsin
warp.unclaimed=Hiçbir arsaya sahip değilsin
warp.success={%0} arsasına ışınlandın

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=Bir arsanın ortasına ışınlar
middle.usage=/p mid
middle.success=Işınlandın

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=Herhangi bir şey değiştirmeden arsa sahibini ayarlar
setowner.usage=/p setowner <oyuncu: dizi>
setowner.maxplots=Bu oyuncu azami {%0} sayısına ulaştı
setowner.success={%0} artık arsanın yeni sahibi

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=Oyuncuya ait arsaları listeler
list.usage=/p list [oyuncu: dizi]
list.found="({%1};{%2}) da ki {%0} arsası"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=Arsadaki pvp durumunu ayarlar
pvp.usage=/p pvp
pvp.world=Pvp is config-disabled in this plot world
pvp.plot=Pvp özelliği bu arsada aktif değil
pvp.success=Pvp durumu şimdi: {%0}; Vietnamese language pack for MyPlot
; Created by QuangDo and Parroted
; Updated time : 2/17/2019

; Popup when entering a plot
popup=Bạn đã vào plot {%0}
popup.owner=Sở hữu bởi {%0}
popup.available=Plot này chưa có chủ! Dùng /p claim
popup.denied=

; /p info
command.name=plot
command.alias=p
command.desc=Nhận và quản lý plot
command.usage = /plot <help|sub-cmd> [options]
command.unknown=Lệnh không rõ. Nhập /p help để xem các lệnh

subcommand.usage=Cách dùng: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=Ồ! Có gì đó không ổn
notinplot=Bạn đang không đứng trong một plot
notowner=Bạn không phải là chủ của plot
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=Xem danh sách trợ giúp
help.usage=/p help [page]
help.header=--- Đang mở trang hướng dẫn {%0} of {%1} ---

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=Thêm người vào plot của bạn
addhelper.usage=/p addhelper <player>
addhelper.alreadyone={%0} hiện đã là helper của plot này rồi
addhelper.success={%0} đã trở thành helper của plot

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=Không cho người vào plot của bạn
removehelper.usage=/p removehelper <player>
removehelper.notone={%0} không phải là helper của plot
removehelper.success={%0} không còn là helper của plot

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=Deny a player from accessing your plot
denyplayer.usage=/p deny <player: string>
denyplayer.helper={%0} is a helper
denyplayer.alreadyone={%0} has already been denied from this plot
denyplayer.cannotdeny={%0} cannot be denied
denyplayer.attempteddeny={%0} attempted to deny you from their plot
denyplayer.success1={%0} is now denied access to the plot
denyplayer.success2="You were denied access to plot {%0};{%1} by {%2}"

; The /p undenyplayer Subcommand
undenyplayer.name=undenyplayer
undenyplayer.alias=undeny
undenyplayer.desc=Undeny a player from accessing your plot
undenyplayer.usage=/p undeny <player: string>
undenyplayer.notone={%0} is allowed already
undenyplayer.notaplayer=That player is not online right now
undenyplayer.success1={%0} has been allowed into the plot
undenyplayer.success2="You were allowed access to plot {%0};{%1} by {%2}"
undenyplayer.failure={%0} is still denied

; The /p claim Subcommand
claim.name=claim
claim.desc=Mua plot bạn đang đứng
claim.usage=/p claim [name]
claim.yourplot=Đây đã là plot của bạn
claim.alreadyclaimed=Plot đã có chủ {%0}
claim.maxplots=Bạn đã sở hữu tối đa {%0} plot
claim.nomoney=Bạn không đủ tiền để mua plot này
claim.success=Đã mua plot

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=Đi đến plot trống
auto.usage=/p auto
auto.notplotworld=Bạn đang ở ngoài world plot
auto.success=Đã đi đến ({%0}, {%1})
auto.noplots=Không có plot trống nào ở quanh đây

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=Bỏ hẳn plot của bạn
dispose.usage=/p dispose
dispose.confirm=Bạn có chắc muốn bỏ plot {%0} ? Nếu chắc dùng /p dispose confirm
dispose.nomoney=Bạn không đủ tiền để bỏ plot
dispose.success=Plot đã bị bỏ

; The /p reset Subcommand
reset.name=reset
reset.desc=Bỏ và xóa plot của bạn
reset.usage=/p reset
reset.confirm=Bạn có chắc muốn bỏ và xóa plot {%0} ? Nếu chắc dùng /p reset confirm
reset.nomoney=Bạn không đủ tiền để bỏ và xóa plot
reset.success=Plot đã bị bỏ và xóa

; The /p clear Subcommand
clear.name=clear
clear.desc=Xóa plot của bạn
clear.usage=/p clear
clear.confirm=Bạn có chắc muốn xóa plot {%0} ? Nếu chắc dùng /p clear confirm
clear.nomoney=Bạn không đủ tiền để xóa plot
clear.success=Plot đã bị xóa

; The /p biome Subcommand
biome.name=biome
biome.desc=Đổi hệ sinh thái trong plot của bạn
biome.usage=/p biome [biome]
biome.success=Hệ sinh thái của plot đổi thành {%0}
biome.invalid=Không có hệ sinh thái đó
biome.possible=Những hệ sinh thái đang có: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=List all available biomes
biomes.usage=/p biomes
biomes.possible=Possible biomes are: {%0}

; The /p name Subcommand
name.name=name
name.desc=Đặt hoặc đổi tên cho plot của bạn
name.usage=/p name <name>
name.success=Tên của plot được đổi thành: {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=Đi về plot của bạn
home.usage=/p home [number]
home.noplots=Bạn đang không có plot nào
home.notexist=Bạn không sở hữu plot số {%0} 
home.success=Đang đi đến plot {%0}
home.error=Không thể đi đến plot

; The /p homes Subcommand
homes.name=homes
homes.desc=Danh sách plot của bạn
homes.usage=/p homes
homes.noplots=Bạn không sở hữu plot nào
homes.header=Plots của bạn:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=Xem thông tin về plot
info.usage=/p info
info.about=Thông tin về {%0}
info.plotname=Tên: {%0}
info.owner=Chủ: {%0}
info.helpers=Người giúp: {%0}
info.denied=
info.biome=Hệ sinh thái: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=Tạo ra một world plot mới
generate.usage=/p generate <name>
generate.exists=World có tên {%0} đã có sẵn
generate.gexists=
generate.success=Đã tạo ra world plot {%0} thành công
generate.error=World không thể tạo ra được

; The /p give Subcommand
give.name=give
give.desc=Cho plot của mình cho người khác
give.usage=/p give [name]
give.notonline=Người chơi đó không online
give.maxedout=Người chơi đó đã có đủ số plot cho phép
give.toself=Bạn không thể gửi cho chính mình
give.confirm=Bạn chắc bạn muốn gửi plot {%0} cho {%1}? Nếu có, dùng /p give {%1} confirm
give.success=Bạn đã gửi plot cho {%0} thành công
give.received={%0} đã cho bạn plot của họ, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=Di chuyển tới plot
warp.usage=/p warp <id>
warp.wrongid=Mã plot phải theo dạng X;Z
warp.notinplotworld=Bạn đang không ở trong world plot
warp.unclaimed=Bạn không thể di chuyển tới plot chưa được mua
warp.success=Bạn đang di chuyển đến plot {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=
middle.usage=/p mid
middle.success=

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=
setowner.usage=/p setowner <>
setowner.maxplots=
setowner.success=

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=
list.usage=/p list []
list.found=

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=/p pvp
pvp.world=
pvp.plot=
pvp.success=; Chinese(ROC) language pack for MyPlot
; Created by jerryzooyoyo
; Updated time : 2/17/2019

; Popup when entering a plot
popup=你來到了領地 {%0}
popup.owner=這個領地的領主為 {%0}
popup.available=這個領地是無主地! 使用 /p claim 來購買
popup.denied=因為這個領地設置了黑名單,你不得進入!

; /p info
command.name=plot
command.alias=p
command.desc=領地系統總指令
command.usage=/p <help|其他項目> [資訊]
command.unknown=貌似你輸入錯誤了,試試看 /p help 來查看所有指令

subcommand.usage=用法: {%0}

; Errors that are displayed when the player does something wrong, or the plugin screws up.
error=發生錯誤了!麻煩立刻通報管理員!記得附上圖片
notinplot=你並沒有站立在指定的領地,請確認位置
notowner=你並不是這個領地的領主,無法使用管理指令
plugin.disabled=

confirm=confirm

; The /p help Subcommand
help.name=help
help.desc=顯示所有領地系統的指令
help.usage=/p help [頁數]
help.header=------ 領地系統指令大全(記得要寫/p開頭啊!) {%0} / {%1} ------

; The /p addhelper Subcommand
addhelper.name=addhelper
addhelper.alias=addh
addhelper.desc=對自己的領地添加助手(簡寫是 addh )
addhelper.usage=/p addh <玩家名稱>
addhelper.alreadyone={%0} 已經是這個領地的助手了!
addhelper.success={%0} 成功成為領地助手

; The /p removehelper Subcommand
removehelper.name=removehelper
removehelper.alias=delh
removehelper.desc=將一個領地助手移除(簡寫是 delh )
removehelper.usage=/p delh <玩家名稱>
removehelper.notone={%0} 並不是領地助手
removehelper.success={%0} 成功從領地助手列表移除

; The /p denyplayer Subcommand
denyplayer.name=denyplayer
denyplayer.alias=deny
denyplayer.desc=對自己的領地添加黑名單
denyplayer.usage=/p deny <玩家名稱>
denyplayer.helper={%0} 已經是這個領地的助手,不可將其加入黑名單!
denyplayer.alreadyone={%0} 已經被列在這個領地黑名單了!
denyplayer.cannotdeny={%0} 不能被列入黑名單!
denyplayer.attempteddeny={%0} 嘗試要將你列入他的領地黑名單!
denyplayer.success1={%0} 成功列入領地黑名單
denyplayer.success2=你被 {%2} 列入他的領地黑名單!領地: {%0};{%1}

; The /p undenyplayer Subcommand
undenyplayer.name=undeny
undenyplayer.alias=undeny
undenyplayer.desc=為自己的領地移除黑名單
undenyplayer.usage=/p undeny <玩家名稱>
undenyplayer.notone={%0} 並沒有在領地黑名單內!
undenyplayer.notaplayer=
undenyplayer.success1={%0} 成功從領地黑名單中移除
undenyplayer.success2=你可以進入 {%2} 的領地 {%0};{%1} 了!
undenyplayer.failure=

; The /p claim Subcommand
claim.name=claim
claim.desc=購買你所在的領地
claim.usage=/p claim [領地暱稱,可不填]
claim.yourplot=這塊領地已經是你的領地了
claim.alreadyclaimed=這塊領地已經有領主!領主為 {%0}
claim.maxplots=你已經達到玩家領地所有上限!上限為 {%0} 塊
claim.nomoney=你的口袋不夠深,沒辦法購買這個領地
claim.success=成功購買領地,開始你的新生活吧!

; The /p auto Subcommand
auto.name=auto
auto.alias=a
auto.desc=自動找尋無主領地,方便購買
auto.usage=/p auto (簡寫是 a )
auto.notplotworld=你並不在住宅區內,請確認位置
auto.success=成功傳送到無主領地 ({%0}, {%1})
auto.noplots=目前沒有無主領地可以購買喔~

; The /p dispose Subcommand
dispose.name=dispose
dispose.desc=賣出領地,保留領地狀態
dispose.usage=/p dispose
dispose.confirm=你確定要賣出領地 {%0} ? 如果確定,請輸入 /p dispose confirm
dispose.nomoney=你的口袋不夠深,沒辦法賣出此領地
dispose.success=成功賣出領地

; The /p reset Subcommand
reset.name=reset
reset.desc=賣出領地,同時重置領地
reset.usage=/p reset
reset.confirm=你確定要賣出領地 {%0} ? 如果確定,請輸入 /p reset confirm
reset.nomoney=你的口袋不夠深,沒辦法賣出此領地
reset.success=成功賣出領地與重置領地

; The /p clear Subcommand
clear.name=clear
clear.desc=重置領地狀態,洗白此領地
clear.usage=/p clear
clear.confirm=你確定要重置領地 {%0} ? 如果確定,請輸入 /p clear confirm
clear.nomoney=你的口袋不夠深,沒辦法重置此領地
clear.success=成功重置領地

; The /p biome Subcommand
biome.name=biome
biome.desc=更改所在領地的生態系
biome.usage=/p biome [生態系名稱]
biome.success=領地生態系成功更改為 {%0}
biome.invalid=不存在此生態系!
biome.possible=可以使用的生態系為: {%0}

; The /p biomes Subcommand
biomes.name=biomes
biomes.desc=列出所有領地生態系
biomes.usage=/p biomes
biomes.possible=可用的領地生態系: {%0}

; The /p name Subcommand
name.name=name
name.desc=設置所在領地的暱稱
name.usage=/p name <暱稱>
name.success=成功將領地暱稱設置為 {%0}

; The /p home Subcommand
home.name=home
home.alias=h
home.desc=傳送到自己的領地(簡寫是 h )
home.usage=/p home [領地編號]
home.noplots=你沒有任何領地可以傳送
home.notexist=你並沒有編號為 {%0} 的領地!請輸入 /p homes 來查看持有列表
home.success=成功傳送到領地 {%0}
home.error=傳送失敗,請回報管理員

; The /p homes Subcommand
homes.name=homes
homes.desc=列出所有你持有的領地
homes.usage=/p homes
homes.noplots=你沒有任何領地可以顯示
homes.header=你擁有的領地為:

; The /p info Subcommand
info.name=info
info.alias=i
info.desc=顯示你所在領地的詳細資訊(簡寫是 i )
info.usage=/p info
info.about=領地 {%0} 的詳細資訊
info.plotname=暱稱: {%0}
info.owner=領主: {%0}
info.helpers=助手: {%0}
info.denied=
info.biome=生態系: {%0}
info.notfound=

; The /p generate Subcommand - Can only be used by OPs or players with the myplot.command.generate permission
generate.name=generate
generate.alias=gen
generate.desc=創立一個新的住宅區
generate.usage=/p g <名稱>
generate.exists=名稱 {%0} 的地圖已經存在
generate.gexists=
generate.success=成功創立住宅區 {%0}
generate.error=創立失敗,請回報管理員

; The /p give Subcommand
give.name=give
give.desc=將你的領地贈送給其他人
give.usage=/p give <玩家名稱>
give.notonline=這位玩家尚未在線,無法贈送領地給他
give.maxedout=這位玩家已經達到最大領地數量,無法贈送領地給他
give.toself=你不能把領地贈送給自己
give.confirm=你確定要贈送領地 {%0} 給 {%1} ? 如果確定,請輸入 /p give {%1} confirm
give.success=成功將該塊領地贈送給 {%0}
give.received={%0} 贈送領地給你, {%1}

; The /p warp Subcommand
warp.name=warp
warp.desc=傳送到某個領地
warp.usage=/p warp <領地編號>
warp.wrongid=領地編號應該使用 X;Z 的格式
warp.notinplotworld=你沒有在住宅區,無法傳送
warp.unclaimed=你不能傳送到一個無主領地
warp.success=成功傳送到領地 {%0}

; The /p middle Subcommand
middle.name=middle
middle.alias=mid
middle.desc=傳送到領地的中心點
middle.usage=/p mid
middle.success=成功傳送到領地中心點

; The /p setowner Subcommand
setowner.name=setowner
setowner.desc=設置領地的新領主
setowner.usage=/p setowner <玩家名稱>
setowner.maxplots=該名玩家已達領地上限!領地上限: {%0}
setowner.success={%0} 現在成為領地的領主了

; The /p list Subcommand
list.name=list
list.alias=l
list.desc=列出一名玩家的所有持有領地
list.usage=/p list <玩家名稱>
list.found="領地 {%0} 座標為 ({%1};{%2}),"

; The /p pvp Subcomand
pvp.name=pvp
pvp.desc=
pvp.usage=/p pvp
pvp.world=
pvp.plot=
pvp.success=<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotClearEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;
	/** @var int $maxBlocksPerTick */
	private $maxBlocksPerTick = 256;

	/**
	 * MyPlotClearEvent constructor.
	 *
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 */
	public function __construct(Plot $plot, int $maxBlocksPerTick = 256) {
		$this->maxBlocksPerTick = $maxBlocksPerTick;
		parent::__construct($plot);
	}

	/**
	 * @return int
	 */
	public function getMaxBlocksPerTick() : int {
		return $this->maxBlocksPerTick;
	}

	/**
	 * @param int $maxBlocksPerTick
	 */
	public function setMaxBlocksPerTick(int $maxBlocksPerTick) : void {
		$this->maxBlocksPerTick = $maxBlocksPerTick;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\IPlayer;

class MyPlotDenyEvent extends MyPlotPlotEvent implements Cancellable {
	const ADD = 0;
	const REMOVE = 1;
	public static $handlerList = null;
	/** @var int $type */
	private $type;
	/** @var string $player */
	private $player;

	/**
	 * MyPlotDenyEvent constructor.
	 *
	 * @param Plot $plot
	 * @param int $type
	 * @param string $player
	 */
	public function __construct(Plot $plot, int $type, string $player) {
		$this->type = $type;
		$this->player = $player;
		parent::__construct($plot);
	}

	/**
	 * @return int
	 */
	public function getType() : int {
		return $this->type;
	}

	/**
	 * @param int $type
	 */
	public function setType(int $type) : void {
		$this->type = $type;
	}

	/**
	 * @return string
	 */
	public function getDenied() : string {
		return $this->player;
	}

	/**
	 * @param IPlayer|string $player
	 */
	public function setDenied($player) : void {
		if($player instanceof IPlayer) {
			$this->player = $player->getName();
		}elseif(is_string($player)) {
			$this->player = $player;
		}
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotDisposeEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;

	/**
	 * MyPlotClearEvent constructor.
	 *
	 * @param Plot $plot
	 */
	public function __construct(Plot $plot) {
		parent::__construct($plot);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use pocketmine\event\Cancellable;
use pocketmine\event\Event;

class MyPlotGenerationEvent extends Event implements Cancellable {
	/** @var string $levelName */
	private $levelName;
	/** @var string $generator */
	private $generator = "myplot";
	/** @var array $settings */
	private $settings = [];

	public function __construct(string $levelName, string $generator = "myplot", array $settings = []) {
		$this->levelName = $levelName;
		$this->generator = $generator;
		$this->settings = $settings;
	}

	/**
	 * @return string
	 */
	public function getLevelName() : string {
		return $this->levelName;
	}

	/**
	 * @param string $levelName
	 */
	public function setLevelName(string $levelName) : void {
		$this->levelName = $levelName;
	}

	/**
	 * @return string
	 */
	public function getGenerator() : string {
		return $this->generator;
	}

	/**
	 * @param string $generator
	 */
	public function setGenerator(string $generator) : void {
		$this->generator = $generator;
	}

	/**
	 * @return array
	 */
	public function getSettings() : array {
		return $this->settings;
	}

	/**
	 * @param array $settings
	 */
	public function setSettings(array $settings) : void {
		$this->settings = $settings;
		$this->settings["preset"] = json_encode($settings);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\Player;

class MyPlotPvpEvent extends MyPlotPlotEvent implements Cancellable {
	/** @var Player $attacker */
	private $attacker;
	/** @var Player $damaged */
	private $damaged;
	/** @var EntityDamageByEntityEvent|null $event */
	private $event;

	public function __construct(Plot $plot, Player $attacker, Player $damaged, ?EntityDamageByEntityEvent $event = null) {
		$this->attacker = $attacker;
		$this->damaged = $damaged;
		$this->event = $event;
		parent::__construct($plot);
	}

	/**
	 * @return Player
	 */
	public function getAttacker() : Player {
		return $this->attacker;
	}

	/**
	 * @return Player
	 */
	public function getDamaged() : Player {
		return $this->damaged;
	}

	/**
	 * @return EntityDamageByEntityEvent|null
	 */
	public function getEvent() : ?EntityDamageByEntityEvent {
		return $this->event;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotResetEvent extends MyPlotPlotEvent implements Cancellable {
	public static $handlerList = null;

	/**
	 * MyPlotClearEvent constructor.
	 *
	 * @param Plot $plot
	 */
	public function __construct(Plot $plot) {
		parent::__construct($plot);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotSaveEvent extends MyPlotPlotEvent implements Cancellable {
	const SQLITE3 = 0;
	const MySQL = 1;
	const JSON = 2;
	const YAML = 3;
	const OTHER = -1;
	public static $handlerList = null;
	/** @var int $type */
	private $type;

	public function __construct(int $type, Plot $plot) {
		$this->type = $type;
		parent::__construct($plot);
	}

	/**
	 * @return int
	 */
	public function getSaveType() : int {
		return $this->type;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\events;

use MyPlot\Plot;
use pocketmine\event\Cancellable;

class MyPlotSettingEvent extends MyPlotPlotEvent implements Cancellable {
	/** @var Plot $newPlot */
	private $oldPlot;

	public function __construct(Plot $oldPlot, Plot $newPlot) {
		$this->oldPlot = $oldPlot;
		parent::__construct($newPlot);
	}

	/**
	 * @return Plot
	 */
	public function getOldPlot() : Plot {
		return $this->oldPlot;
	}

	/**
	 * @param Plot $oldPlot
	 */
	public function setOldPlot(Plot $oldPlot) : void {
		$this->oldPlot = $oldPlot;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use EssentialsPE\Loader;
use pocketmine\Player;

class EssentialsPEProvider implements EconomyProvider {
	/** @var Loader $plugin */
	private $plugin;

	/**
	 * EssentialsPEProvider constructor.
	 *
	 * @param Loader $plugin
	 */
	public function __construct(Loader $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool {
		if($amount === 0) {
			return true;
		}elseif($amount < 0) {
			$amount = -$amount;
		}
		$pre = $this->plugin->getAPI()->getPlayerBalance($player);
		$this->plugin->getAPI()->addToPlayerBalance($player, (int) -$amount);
		if($this->plugin->getAPI()->getPlayerBalance($player) == $pre - (int) $amount) {
			$this->plugin->getLogger()->debug("MyPlot reduced money of ".$player->getName());
			return true;
		}
		$this->plugin->getLogger()->debug("MyPlot failed to reduce money of ".$player->getName());
		return false;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;
use pocketmine\utils\Config;

class JSONDataProvider extends DataProvider {
	/** @var MyPlot $plugin */
	protected $plugin;
	/** @var Config $json */
	private $json;

	/**
	 * JSONDataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		parent::__construct($plugin, $cacheSize);
		$this->json = new Config($this->plugin->getDataFolder() . "Data" . DIRECTORY_SEPARATOR . "plots.yml", Config::JSON, ["count" => 0, "plots" => []]);
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$plots = $this->json->get("plots", []);
		$plots[$plot->id] = ["level" => $plot->levelName, "x" => $plot->X, "z" => $plot->Z, "name" => $plot->name, "owner" => $plot->owner, "helpers" => $plot->helpers, "denied" => $plot->denied, "biome" => $plot->biome];
		$this->json->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->json->save();
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		$plots = $this->json->get("plots", []);
		unset($plots[$plot->id]);
		$this->json->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->json->save();
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) !== null) {
			return $plot;
		}
		$plots = $this->json->get("plots", []);
		$levelKeys = array_keys($plots, $levelName);
		$xKeys = array_keys($plots, $X);
		$zKeys = array_keys($plots, $Z);
		/** @var int|null $key */
		$key = null;
		foreach($levelKeys as $levelKey) {
			foreach($xKeys as $xKey) {
				foreach($zKeys as $zKey) {
					if($zKey == $xKey and $xKey == $levelKey and $zKey == $levelKey) {
						$key = $levelKey;
						break 3;
					}
				}
			}
		}
		if($key != null) {
			$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
			$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
			$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
			$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
			$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
			$pvp = $plot[$key]["pvp"] == null ? false : $plot[$key]["pvp"];
			return new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
		}
		$count = $this->json->get("count", 0);
		$this->json->set("count", (int) $count++);
		$this->json->save();
		return new Plot($levelName, $X, $Z, "", "", [], [], "PLAINS", (int) $count);
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		$plots = $this->json->get("plots", []);
		$ownerPlots = [];
		if($levelName != "") {
			$levelKeys = array_keys($plots, $levelName);
			$ownerKeys = array_keys($plots, $owner);
			foreach($levelKeys as $levelKey) {
				foreach($ownerKeys as $ownerKey) {
					if($levelKey == $ownerKey) {
						$X = $plots[$levelKey]["x"];
						$Z = $plots[$levelKey]["z"];
						$plotName = $plots[$levelKey]["name"] == "" ? "" : $plots[$levelKey]["name"];
						$owner = $plots[$levelKey]["owner"] == "" ? "" : $plots[$levelKey]["owner"];
						$helpers = $plots[$levelKey]["helpers"] == [] ? [] : $plots[$levelKey]["helpers"];
						$denied = $plots[$levelKey]["denied"] == [] ? [] : $plots[$levelKey]["denied"];
						$biome = strtoupper($plots[$levelKey]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$levelKey]["biome"]);
						$pvp = $plots[$levelKey]["pvp"] == null ? false : $plots[$levelKey]["pvp"];
						$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $levelKey);
					}
				}
			}
		}else{
			$ownerKeys = array_keys($plots, $owner);
			foreach($ownerKeys as $key) {
				$levelName = $plots[$key]["level"];
				$X = $plots[$key]["x"];
				$Z = $plots[$key]["z"];
				$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
				$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
				$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
				$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
				$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
				$pvp = $plots[$key]["pvp"] == null ? false : $plots[$key]["pvp"];
				$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
			}
		}
		return $ownerPlots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		$plotsArr = $this->json->get("plots", []);
		for($i = 0; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$existing = [];
			foreach($plotsArr as $id => $data) {
				if($data["level"] === $levelName) {
					if(abs($data["x"]) === $i and abs($data["z"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}elseif(abs($data["z"]) === $i and abs($data["x"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}
				}
			}
			$plots = [];
			foreach($existing as $XZ) {
				$plots[$XZ[0]][$XZ[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		$this->json->save();
		unset($this->json);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;

class MySQLProvider extends DataProvider {
	/** @var MyPlot $plugin */
	protected $plugin;
	/** @var \mysqli $db */
	private $db;
	/** @var array $settings */
	private $settings;
	/** @var \mysqli_stmt */
	private $sqlGetPlot, $sqlSavePlot, $sqlSavePlotById, $sqlRemovePlot, $sqlRemovePlotById, $sqlGetPlotsByOwner, $sqlGetPlotsByOwnerAndLevel, $sqlGetExistingXZ;

	/**
	 * MySQLProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 * @param array $settings
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0, array $settings = []) {
		ini_set("mysqli.reconnect", "1");
		ini_set('mysqli.allow_persistent', "1");
		ini_set('mysql.connect_timeout', "300");
		ini_set('default_socket_timeout', "300");
		$this->plugin = $plugin;
		parent::__construct($plugin, $cacheSize);
		$this->settings = $settings;
		$this->db = new \mysqli($settings['Host'], $settings['Username'], $settings['Password'], $settings['DatabaseName'], $settings['Port']);
		$this->db->query("CREATE TABLE IF NOT EXISTS plots (id INT PRIMARY KEY AUTO_INCREMENT, level TEXT, X INT, Z INT, name TEXT, owner TEXT, helpers TEXT, denied TEXT, biome TEXT, pvp INT);");
		try{
			$this->db->query("ALTER TABLE plots ADD COLUMN pvp INT AFTER biome;");
		}catch(\Exception $e) {
			// do nothing :P
		}
		$this->prepare();
		$this->plugin->getLogger()->debug("MySQL data provider registered");
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$this->reconnect();
		$helpers = implode(',', $plot->helpers);
		$denied = implode(',', $plot->denied);
		if($plot->id >= 0) {
			$stmt = $this->sqlSavePlotById;
			$stmt->bind_param('isiisssssi', $plot->id, $plot->levelName, $plot->X, $plot->Z, $plot->name, $plot->owner, $helpers, $denied, $plot->biome, $plot->pvp);
		}else{
			$stmt = $this->sqlSavePlot;
			$stmt->bind_param('siisiisssssi', $plot->levelName, $plot->X, $plot->Z, $plot->levelName, $plot->X, $plot->Z, $plot->name, $plot->owner, $helpers, $denied, $plot->biome, $plot->pvp);
		}
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return false;
		}
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		$this->reconnect();
		if($plot->id >= 0) {
			$stmt = $this->sqlRemovePlot;
			$stmt->bind_param('i', $plot->id);
		}else{
			$stmt = $this->sqlRemovePlotById;
			$stmt->bind_param('sii', $plot->levelName, $plot->X, $plot->Z);
		}
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return false;
		}
		$plot = new Plot($plot->levelName, $plot->X, $plot->Z);
		$this->cachePlot($plot);
		return true;
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		$this->reconnect();
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) != null) {
			return $plot;
		}
		$stmt = $this->sqlGetPlot;
		$stmt->bind_param('sii', $levelName, $X, $Z);
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return null;
		}
		$result = $stmt->get_result();
		if($val = $result->fetch_array(MYSQLI_ASSOC)) {
			if(empty($val["helpers"])) {
				$helpers = [];
			}else{
				$helpers = explode(",", (string) $val["helpers"]);
			}
			if(empty($val["denied"])) {
				$denied = [];
			}else{
				$denied = explode(",", (string) $val["denied"]);
			}
			$plot = new Plot($levelName, $X, $Z, (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}else{
			$plot = new Plot($levelName, $X, $Z);
		}
		$this->cachePlot($plot);
		return $plot;
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return array
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		$this->reconnect();
		if(empty($levelName)) {
			$stmt = $this->sqlGetPlotsByOwner;
			$stmt->bind_param('s', $owner);
		}else{
			$stmt = $this->sqlGetPlotsByOwnerAndLevel;
			$stmt->bind_param('ss', $owner, $levelName);
		}
		$plots = [];
		$result = $stmt->execute();
		if($result === false) {
			$this->plugin->getLogger()->error($stmt->error);
			return $plots;
		}
		$result = $stmt->get_result();
		while($val = $result->fetch_array()) {
			$helpers = explode(",", (string) $val["helpers"]);
			$denied = explode(",", (string) $val["denied"]);
			$plots[] = new Plot((string) $val["level"], (int) $val["X"], (int) $val["Z"], (string) $val["name"], (string) $val["owner"], $helpers, $denied, (string) $val["biome"], (bool) $val["pvp"], (int) $val["id"]);
		}
		// Remove unloaded plots
		$plots = array_filter($plots, function($plot) {
			return $this->plugin->isLevelLoaded($plot->levelName);
		});
		// Sort plots by level
		usort($plots, function($plot1, $plot2) {
			return strcmp($plot1->levelName, $plot2->levelName);
		});
		return $plots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?Plot {
		$this->reconnect();
		$i = 0;
		for(; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$stmt = $this->sqlGetExistingXZ;
			$stmt->bind_param('siiii', $levelName, $i, $i, $i, $i);
			$result = $stmt->execute();
			if($result === false) {
				$this->plugin->getLogger()->error($stmt->error);
				continue;
			}
			$result = $stmt->get_result();
			$plots = [];
			while($val = $result->fetch_array(MYSQLI_NUM)) {
				$plots[$val[0]][$val[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		if($this->db->close())
			$this->plugin->getLogger()->debug("MySQL database closed!");
	}

	/**
	 * @return bool
	 */
	private function reconnect() : bool {
		if(!$this->db->ping()) {
			$this->plugin->getLogger()->error("The MySQL server can not be reached! Trying to reconnect!");
			$this->close();
			$this->db->connect($this->settings['Host'], $this->settings['Username'], $this->settings['Password'], $this->settings['DatabaseName'], $this->settings['Port']);
			$this->prepare();
			if($this->db->ping()) {
				$this->plugin->getLogger()->notice("The MySQL connection has been re-established!");
				return true;
			}else{
				$this->plugin->getLogger()->critical("The MySQL connection could not be re-established!");
				$this->plugin->getLogger()->critical("Closing level to prevent griefing!");
				foreach($this->plugin->getPlotLevels() as $levelName => $settings) {
					$level = $this->plugin->getServer()->getLevelByName($levelName);
					$level->save(); // don't force in case owner doesn't want it saved
					$level->unload(true); // force unload to prevent possible griefing
				}
				if($this->plugin->getConfig()->getNested("MySQLSettings.ShutdownOnFailure", false)) {
					$this->plugin->getServer()->shutdown();
				}
				return false;
			}
		}
		return true;
	}

	private function prepare() : void {
		$this->sqlGetPlot = $this->db->prepare("SELECT id, name, owner, helpers, denied, biome FROM plots WHERE level = ? AND X = ? AND Z = ?;");
		$this->sqlSavePlot = $this->db->prepare("INSERT INTO plots (`id`, `level`, `X`, `Z`, `name`, `owner`, `helpers`, `denied`, `biome`, `pvp`) VALUES((SELECT id FROM plots p WHERE p.level = ? AND X = ? AND Z = ?),?,?,?,?,?,?,?,?,?) ON DUPLICATE KEY UPDATE name = VALUES(name), owner = VALUES(owner), helpers = VALUES(helpers), denied = VALUES(denied), biome = VALUES(biome), pvp = VALUES(pvp);");
		$this->sqlSavePlotById = $this->db->prepare("UPDATE plots SET id = ?, level = ?, X = ?, Z = ?, name = ?, owner = ?, helpers = ?, denied = ?, biome = ?, pvp = ? WHERE id = VALUES(id);");
		$this->sqlRemovePlot = $this->db->prepare("DELETE FROM plots WHERE id = ?;");
		$this->sqlRemovePlotById = $this->db->prepare("DELETE FROM plots WHERE level = ? AND X = ? AND Z = ?;");
		$this->sqlGetPlotsByOwner = $this->db->prepare("SELECT * FROM plots WHERE owner = ?;");
		$this->sqlGetPlotsByOwnerAndLevel = $this->db->prepare("SELECT * FROM plots WHERE owner = ? AND level = ?;");
		$this->sqlGetExistingXZ = $this->db->prepare("SELECT X, Z FROM plots WHERE (level = ? AND ((abs(X) = ? AND abs(Z) <= ?) OR (abs(Z) = ? AND abs(X) <= ?)));");
	}
}
<?php
declare(strict_types=1);
namespace MyPlot\provider;

use pocketmine\Player;
use PocketMoney\PocketMoney;

class PocketMoneyProvider implements EconomyProvider
{
	/** @var PocketMoney $plugin */
	private $plugin;

	/**
	 * PocketMoneyProvider constructor.
	 *
	 * @param PocketMoney $plugin
	 */
	public function __construct(PocketMoney $plugin) {
		$this->plugin = $plugin;
	}

	/**
	 * @param Player $player
	 * @param float $amount
	 *
	 * @return bool
	 */
	public function reduceMoney(Player $player, float $amount) : bool {
		if($amount === 0) {
			return true;
		}elseif($amount < 0) {
			$amount = -$amount;
		}
		$money = $this->plugin->getMoney($player->getName());
		if($money === false or ($money - $amount) < 0) {
			return false;
		}
		if($this->plugin->setMoney($player->getName(), $money - $amount)) {
			$this->plugin->getLogger()->debug("MyPlot reduced money of " . $player->getName());
			return true;
		}
		$this->plugin->getLogger()->debug("MyPlot failed to reduce money of " . $player->getName());
		return false;
	}
}<?php
declare(strict_types=1);
namespace MyPlot\provider;

use MyPlot\MyPlot;
use MyPlot\Plot;
use pocketmine\utils\Config;

class YAMLDataProvider extends DataProvider {
	/** @var MyPlot $plugin */
	protected $plugin;
	/** @var Config $yaml */
	private $yaml;

	/**
	 * YAMLDataProvider constructor.
	 *
	 * @param MyPlot $plugin
	 * @param int $cacheSize
	 */
	public function __construct(MyPlot $plugin, int $cacheSize = 0) {
		parent::__construct($plugin, $cacheSize);
		$this->yaml = new Config($this->plugin->getDataFolder() . "Data" . DIRECTORY_SEPARATOR . "plots.yml", Config::YAML, ["count" => 0, "plots" => []]);
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function savePlot(Plot $plot) : bool {
		$plots = $this->yaml->get("plots", []);
		$plots[$plot->id] = ["level" => $plot->levelName, "x" => $plot->X, "z" => $plot->Z, "name" => $plot->name, "owner" => $plot->owner, "helpers" => $plot->helpers, "denied" => $plot->denied, "biome" => $plot->biome, "pvp" => $plot->pvp];
		$this->yaml->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->yaml->save();
	}

	/**
	 * @param Plot $plot
	 *
	 * @return bool
	 */
	public function deletePlot(Plot $plot) : bool {
		$plots = $this->yaml->get("plots", []);
		unset($plots[$plot->id]);
		$this->yaml->set("plots", $plots);
		$this->cachePlot($plot);
		return $this->yaml->save();
	}

	/**
	 * @param string $levelName
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Plot
	 */
	public function getPlot(string $levelName, int $X, int $Z) : Plot {
		if(($plot = $this->getPlotFromCache($levelName, $X, $Z)) !== null) {
			return $plot;
		}
		$plots = $this->yaml->get("plots");
		$levelKeys = array_keys($plots, $levelName);
		$xKeys = array_keys($plots, $X);
		$zKeys = array_keys($plots, $Z);
		/** @var int|null $key */
		$key = null;
		foreach($levelKeys as $levelKey) {
			foreach($xKeys as $xKey) {
				foreach($zKeys as $zKey) {
					if($zKey == $xKey and $xKey == $levelKey and $zKey == $levelKey) {
						$key = $levelKey;
						break 3;
					}
				}
			}
		}
		if($key != null) {
			$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
			$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
			$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
			$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
			$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
			$pvp = $plot[$key]["pvp"] == null ? false : $plot[$key]["pvp"];
			return new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
		}
		$count = $this->yaml->get("count", 0);
		$this->yaml->set("count", (int) $count++);
		$this->yaml->save();
		return new Plot($levelName, $X, $Z, "", "", [], [], "PLAINS", true, (int) $count);
	}

	/**
	 * @param string $owner
	 * @param string $levelName
	 *
	 * @return Plot[]
	 */
	public function getPlotsByOwner(string $owner, string $levelName = "") : array {
		$plots = $this->yaml->get("plots", []);
		$ownerPlots = [];
		if($levelName != "") {
			$levelKeys = array_keys($plots, $levelName);
			$ownerKeys = array_keys($plots, $owner);
			foreach($levelKeys as $levelKey) {
				foreach($ownerKeys as $ownerKey) {
					if($levelKey == $ownerKey) {
						$X = $plots[$levelKey]["x"];
						$Z = $plots[$levelKey]["z"];
						$plotName = $plots[$levelKey]["name"] == "" ? "" : $plots[$levelKey]["name"];
						$owner = $plots[$levelKey]["owner"] == "" ? "" : $plots[$levelKey]["owner"];
						$helpers = $plots[$levelKey]["helpers"] == [] ? [] : $plots[$levelKey]["helpers"];
						$denied = $plots[$levelKey]["denied"] == [] ? [] : $plots[$levelKey]["denied"];
						$biome = strtoupper($plots[$levelKey]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$levelKey]["biome"]);
						$pvp = $plots[$levelKey]["pvp"] == null ? false : $plots[$levelKey]["pvp"];
						$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $levelKey);
					}
				}
			}
		}else{
			$ownerKeys = array_keys($plots, $owner);
			foreach($ownerKeys as $key) {
				$levelName = $plots[$key]["level"];
				$X = $plots[$key]["x"];
				$Z = $plots[$key]["z"];
				$plotName = $plots[$key]["name"] == "" ? "" : $plots[$key]["name"];
				$owner = $plots[$key]["owner"] == "" ? "" : $plots[$key]["owner"];
				$helpers = $plots[$key]["helpers"] == [] ? [] : $plots[$key]["helpers"];
				$denied = $plots[$key]["denied"] == [] ? [] : $plots[$key]["denied"];
				$biome = strtoupper($plots[$key]["biome"]) == "PLAINS" ? "PLAINS" : strtoupper($plots[$key]["biome"]);
				$pvp = $plots[$key]["pvp"] == null ? false : $plots[$key]["pvp"];
				$ownerPlots[] = new Plot($levelName, $X, $Z, $plotName, $owner, $helpers, $denied, $biome, $pvp, $key);
			}
		}
		return $ownerPlots;
	}

	/**
	 * @param string $levelName
	 * @param int $limitXZ
	 *
	 * @return Plot|null
	 */
	public function getNextFreePlot(string $levelName, int $limitXZ = 0) : ?plot {
		$plotsArr = $this->yaml->get("plots", []);
		for($i = 0; $limitXZ <= 0 or $i < $limitXZ; $i++) {
			$existing = [];
			foreach($plotsArr as $id => $data) {
				if($data["level"] === $levelName) {
					if(abs($data["x"]) === $i and abs($data["z"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}elseif(abs($data["z"]) === $i and abs($data["x"]) <= $i) {
						$existing[] = [$data["x"], $data["z"]];
					}
				}
			}
			$plots = [];
			foreach($existing as $arr) {
				$plots[$arr[0]][$arr[1]] = true;
			}
			if(count($plots) === max(1, 8 * $i)) {
				continue;
			}
			if($ret = self::findEmptyPlotSquared(0, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
			for($a = 1; $a < $i; $a++) {
				if($ret = self::findEmptyPlotSquared($a, $i, $plots)) {
					list($X, $Z) = $ret;
					$plot = new Plot($levelName, $X, $Z);
					$this->cachePlot($plot);
					return $plot;
				}
			}
			if($ret = self::findEmptyPlotSquared($i, $i, $plots)) {
				list($X, $Z) = $ret;
				$plot = new Plot($levelName, $X, $Z);
				$this->cachePlot($plot);
				return $plot;
			}
		}
		return null;
	}

	public function close() : void {
		unset($this->yaml);
	}
}<?php
declare(strict_types=1);
namespace MyPlot\task;

use MyPlot\MyPlot;
use MyPlot\Plot;
use pocketmine\block\Block;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\scheduler\Task;

class ClearPlotTask extends Task {
	/** @var MyPlot $plugin */
	private $plugin;
	private $plot, $level, $height, $bottomBlock, $plotFillBlock, $plotFloorBlock, $plotBeginPos, $xMax, $zMax, $maxBlocksPerTick, $pos;

	/**
	 * ClearPlotTask constructor.
	 *
	 * @param MyPlot $plugin
	 * @param Plot $plot
	 * @param int $maxBlocksPerTick
	 */
	public function __construct(MyPlot $plugin, Plot $plot, int $maxBlocksPerTick = 256) {
		$this->plugin = $plugin;
		$this->plot = $plot;
		$this->plotBeginPos = $plugin->getPlotPosition($plot);
		$this->level = $this->plotBeginPos->getLevel();
		$plotLevel = $plugin->getLevelSettings($plot->levelName);
		$plotSize = $plotLevel->plotSize;
		$this->xMax = $this->plotBeginPos->x + $plotSize;
		$this->zMax = $this->plotBeginPos->z + $plotSize;
		$this->height = $plotLevel->groundHeight;
		$this->bottomBlock = $plotLevel->bottomBlock;
		$this->plotFillBlock = $plotLevel->plotFillBlock;
		$this->plotFloorBlock = $plotLevel->plotFloorBlock;
		$this->maxBlocksPerTick = $maxBlocksPerTick;
		$this->pos = new Vector3($this->plotBeginPos->x, 0, $this->plotBeginPos->z);
		$this->plugin = $plugin;
		$plugin->getLogger()->debug("Clear Task started at plot {$plot->X};{$plot->Z}");
	}

	/**
	 * @param int $currentTick
	 */
	public function onRun(int $currentTick) : void {
		foreach($this->level->getEntities() as $entity) {
			if($this->plugin->getPlotBB($this->plot)->isVectorInXZ($entity)) {
				if(!$entity instanceof Player) {
					$entity->flagForDespawn();
				}else{
					$this->plugin->teleportPlayerToPlot($entity, $this->plot);
				}
			}
		}
		$blocks = 0;
		while($this->pos->x < $this->xMax) {
			while($this->pos->z < $this->zMax) {
				while($this->pos->y < $this->level->getWorldHeight()) {
					if($this->pos->y === 0) {
						$block = $this->bottomBlock;
					}elseif($this->pos->y < $this->height) {
						$block = $this->plotFillBlock;
					}elseif($this->pos->y === $this->height) {
						$block = $this->plotFloorBlock;
					}else{
						$block = Block::get(0);
					}
					$this->level->setBlock($this->pos, $block, false, false);
					$blocks++;
					if($blocks >= $this->maxBlocksPerTick) {
						$this->plugin->getScheduler()->scheduleDelayedTask($this, 1);
						return;
					}
					$this->pos->y++;
				}
				$this->pos->y = 0;
				$this->pos->z++;
			}
			$this->pos->z = $this->plotBeginPos->z;
			$this->pos->x++;
		}
		foreach($this->level->getTiles() as $tile) {
			if(($plot = $this->plugin->getPlotByPosition($tile)) != null) {
				if($plot->X === $this->plot->X and $plot->Z === $this->plot->Z) {
					$tile->close();
				}
			}
		}
		$this->plugin->getLogger()->debug("Clear task completed at {$this->plotBeginPos->x};{$this->plotBeginPos->z}");
	}
}{"MyPlot\\libs\\spoondetector":{"name":"SpoonDetector","version":"0.0.0","antigen":"spoondetector","api":["2.0.0","3.0.0-ALPHA1","3.0.0-ALPHA2","3.0.0-ALPHA3","3.0.0-ALPHA4","3.0.0-ALPHA5"],"php":[7],"author":"Falk","build":{"builder":"PoggitCI\/1.0-beta poggit-virion\/1.0","buildTime":"2017-05-30T23:37:02+0000","poggitBuildId":23779,"projectBuildNumber":4,"class":"Dev"}}}